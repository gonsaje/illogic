{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/standardized-audio-context/build/es2019/globals.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","webpack:///./node_modules/standardized-audio-context/build/es2019/constants.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","webpack:///./node_modules/standardized-audio-context/build/es2019/module.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","webpack:///./node_modules/automation-events/build/es5/bundle.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js","webpack:///./node_modules/standardized-audio-context/build/es2019/read-only-map.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js","webpack:///./node_modules/standardized-audio-context/build/es2019/interfaces/index.js","webpack:///./node_modules/standardized-audio-context/build/es2019/types/index.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-backup-native-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-delay-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-gain-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/window.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/delay-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node-factory.js","webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack:///./node_modules/@babel/runtime/helpers/createClass.js","webpack:///./node_modules/tone/build/esm/core/util/Debug.js","webpack:///./node_modules/tone/build/esm/core/util/TypeCheck.js","webpack:///./node_modules/tone/build/esm/core/context/AudioContext.js","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./node_modules/tone/build/esm/core/clock/Ticker.js","webpack:///./node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","webpack:///./node_modules/tone/build/esm/core/util/Defaults.js","webpack:///./node_modules/tone/build/esm/core/Tone.js","webpack:///./node_modules/tone/build/esm/version.js","webpack:///./node_modules/tone/build/esm/core/util/Math.js","webpack:///./node_modules/tone/build/esm/core/util/Timeline.js","webpack:///./node_modules/tone/build/esm/core/context/ContextInitialization.js","webpack:///./node_modules/tone/build/esm/core/util/Emitter.js","webpack:///./node_modules/tone/build/esm/core/context/BaseContext.js","webpack:///./node_modules/tone/build/esm/core/context/Context.js","webpack:///./node_modules/tone/build/esm/core/util/Interface.js","webpack:///./node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","webpack:///./node_modules/tone/build/esm/core/context/OfflineContext.js","webpack:///./node_modules/tone/build/esm/core/Global.js","webpack:///./node_modules/tone/build/esm/core/context/DummyContext.js","webpack:///./node_modules/tone/build/esm/core/type/Conversions.js","webpack:///./node_modules/tone/build/esm/core/type/TimeBase.js","webpack:///./node_modules/tone/build/esm/core/type/Time.js","webpack:///./node_modules/tone/build/esm/core/type/Frequency.js","webpack:///./node_modules/tone/build/esm/core/type/TransportTime.js","webpack:///./node_modules/tone/build/esm/core/context/ToneWithContext.js","webpack:///./node_modules/tone/build/esm/core/util/StateTimeline.js","webpack:///./node_modules/tone/build/esm/core/context/Param.js","webpack:///./node_modules/tone/build/esm/core/context/ToneAudioNode.js","webpack:///./node_modules/tone/build/esm/core/context/Gain.js","webpack:///./node_modules/tone/build/esm/source/OneShotSource.js","webpack:///./node_modules/tone/build/esm/signal/ToneConstantSource.js","webpack:///./node_modules/tone/build/esm/signal/Signal.js","webpack:///./node_modules/tone/build/esm/core/clock/TickParam.js","webpack:///./node_modules/tone/build/esm/core/clock/TickSignal.js","webpack:///./node_modules/tone/build/esm/core/clock/TickSource.js","webpack:///./node_modules/tone/build/esm/core/clock/Clock.js","webpack:///./node_modules/tone/build/esm/core/util/TimelineValue.js","webpack:///./node_modules/tone/build/esm/core/type/Ticks.js","webpack:///./node_modules/tone/build/esm/core/util/IntervalTimeline.js","webpack:///./node_modules/tone/build/esm/core/clock/TransportEvent.js","webpack:///./node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js","webpack:///./node_modules/tone/build/esm/core/clock/Transport.js","webpack:///./node_modules/tone/build/esm/component/channel/Volume.js","webpack:///./node_modules/tone/build/esm/core/context/Destination.js","webpack:///./node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","webpack:///./node_modules/tone/build/esm/core/util/Draw.js","webpack:///./node_modules/tone/build/esm/source/Source.js","webpack:///./node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","webpack:///./node_modules/tone/build/esm/source/Noise.js","webpack:///./node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","webpack:///./node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js","webpack:///./node_modules/tone/build/esm/source/oscillator/Oscillator.js","webpack:///./node_modules/tone/build/esm/signal/SignalOperator.js","webpack:///./node_modules/tone/build/esm/signal/WaveShaper.js","webpack:///./node_modules/tone/build/esm/signal/AudioToGain.js","webpack:///./node_modules/tone/build/esm/signal/Multiply.js","webpack:///./node_modules/tone/build/esm/source/oscillator/AMOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/FMOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/PulseOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/FatOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/PWMOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","webpack:///./node_modules/tone/build/esm/core/util/Decorator.js","webpack:///./node_modules/tone/build/esm/source/buffer/Player.js","webpack:///./node_modules/tone/build/esm/signal/GainToAudio.js","webpack:///./node_modules/tone/build/esm/component/envelope/Envelope.js","webpack:///./node_modules/tone/build/esm/instrument/Instrument.js","webpack:///./node_modules/tone/build/esm/instrument/Monophonic.js","webpack:///./node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","webpack:///./node_modules/tone/build/esm/instrument/Synth.js","webpack:///./node_modules/tone/build/esm/instrument/ModulationSynth.js","webpack:///./node_modules/tone/build/esm/instrument/FMSynth.js","webpack:///./node_modules/tone/build/esm/instrument/MembraneSynth.js","webpack:///./node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js","webpack:///./node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/AudioWorkletProcessor.worklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","webpack:///./node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js","webpack:///./node_modules/tone/build/esm/instrument/Sampler.js","webpack:///./node_modules/tone/build/esm/component/channel/CrossFade.js","webpack:///./node_modules/tone/build/esm/effect/Effect.js","webpack:///./node_modules/tone/build/esm/component/channel/Panner.js","webpack:///./node_modules/tone/build/esm/effect/BitCrusher.worklet.js","webpack:///./node_modules/tone/build/esm/component/channel/Merge.js","webpack:///./node_modules/tone/build/esm/effect/Reverb.js","webpack:///./node_modules/tone/build/esm/component/channel/Solo.js","webpack:///./node_modules/tone/build/esm/component/channel/PanVol.js","webpack:///./node_modules/tone/build/esm/component/channel/Channel.js","webpack:///./node_modules/tone/build/esm/core/context/Listener.js","webpack:///./node_modules/tone/build/esm/index.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","WeakMap","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","assignNativeAudioNodeOptions","nativeAudioNode","options","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isOwnedByContext","nativeContext","context","assignNativeAudioNodeOption","option","undefined","assignNativeAudioNodeAudioParamValue","audioParam","getNativeAudioNode","audioNode","createInvalidStateError","DOMException","err","code","getAudioNodeConnections","getValueForKey","map","Error","createNotSupportedError","interceptConnections","original","interceptor","connect","disconnect","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","cacheTestResult","Map","window","nativeOfflineAudioContextConstructor","isNativeOfflineAudioContext","nativeAudioContextConstructor","getBackupNativeContext","createNativeAudioNode","createNativeAnalyserNode","getAudioNodeRenderer","renderInputsOfAudioNode","createAnalyserNodeRenderer","auxiliaryGainNodeStore","getNativeContext","audioParamAudioNodeStore","eventTargetConstructor","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","audioNodeConstructor","analyserNodeConstructor","audioBufferStore","nativeAudioBufferConstructor","convertNumberToUnsignedLong","Uint32Array","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","createNativeGainNode","addSilentConnection","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","renderInputsOfAudioParam","connectAudioParam","createNativeAudioBufferSourceNode","renderAutomation","createAudioBufferSourceNodeRenderer","createAudioParam","audioBufferSourceNodeConstructor","audioDestinationNodeConstructor","createNativeBiquadFilterNode","createBiquadFilterNodeRenderer","biquadFilterNodeConstructor","monitorConnections","wrapChannelMergerNode","createNativeChannelMergerNode","createChannelMergerNodeRenderer","channelMergerNodeConstructor","createNativeChannelSplitterNode","createChannelSplitterNodeRenderer","channelSplitterNodeConstructor","createNativeConstantSourceNodeFaker","createNativeConstantSourceNode","createConstantSourceNodeRenderer","constantSourceNodeConstructor","createNativeConvolverNodeFaker","createNativeConvolverNode","createConvolverNodeRenderer","convolverNodeConstructor","createNativeDelayNode","createDelayNodeRenderer","delayNodeConstructor","createNativeDynamicsCompressorNode","createDynamicsCompressorNodeRenderer","dynamicsCompressorNodeConstructor","createGainNodeRenderer","gainNodeConstructor","createNativeScriptProcessorNode","createNativeIIRFilterNodeFaker","renderNativeOfflineAudioContext","createIIRFilterNodeRenderer","createNativeIIRFilterNode","iIRFilterNodeConstructor","createAudioListener","unrenderedAudioWorkletNodeStore","minimalBaseAudioContextConstructor","createNativeOscillatorNode","createOscillatorNodeRenderer","oscillatorNodeConstructor","createConnectedNativeAudioBufferSourceNode","createNativeWaveShaperNodeFaker","createNativeWaveShaperNode","createNativePannerNodeFaker","createNativePannerNode","createPannerNodeRenderer","pannerNodeConstructor","createNativePeriodicWave","periodicWaveConstructor","nativeStereoPannerNodeFakerFactory","createNativeStereoPannerNode","createStereoPannerNodeRenderer","stereoPannerNodeConstructor","createWaveShaperNodeRenderer","waveShaperNodeConstructor","isSecureContext","exposeCurrentFrameAndCurrentTime","addAudioWorkletModule","isNativeContext","decodeAudioData","baseAudioContextConstructor","createNativeMediaElementAudioSourceNode","mediaElementAudioSourceNodeConstructor","createNativeMediaStreamAudioDestinationNode","mediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioSourceNode","mediaStreamAudioSourceNodeConstructor","createNativeMediaStreamTrackAudioSourceNode","mediaStreamTrackAudioSourceNodeConstructor","audioContextConstructor","getUnrenderedAudioWorkletNodes","addUnrenderedAudioWorkletNode","connectMultipleOutputs","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","createNativeAudioWorkletNodeFaker","createNativeAudioWorkletNode","nativeAudioWorkletNodeConstructor","createAudioWorkletNodeRenderer","audioWorkletNodeConstructor","createNativeOfflineAudioContext","startRendering","offlineAudioContextConstructor","isAnyAudioContext","isAnyAudioNode","isAnyAudioParam","isAnyOfflineAudioContext","testPromiseSupport","uint32Array","promise","buffer","catch","createIndexSizeError","insertElementInSet","set","element","predicate","ignoreDuplicates","lmnt","add","setInternalStateToActive","has","forEach","eventListener","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","floor","upperIndex","ceil","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","this","_automationEvents","_currenTime","_defaultValue","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","factory","isPartOfACycle","getEventListenersOfAudioNode","setInternalStateToPassive","delete","isAudioNodeOutputConnection","outputConnection","isActiveAudioNode","isAudioNode","audioNodeOrAudioParam","nativeAudioNodeOrAudioParam","getAudioParamConnections","getNativeAudioParam","wrapEventListener","event","descriptor","defineProperties","currentTarget","handleEvent","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","start","when","offset","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","stop","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","copyToChannel","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","output","input","fakeNativeDestinationAudioNode","inputs","disconnectNativeAudioNodeFromNativeAudioNode","copyFromChannel","parent","channelNumber","bufferOffset","byteLength","channelData","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","createInvalidAccessError","overwriteAccessors","createGetter","createSetter","getPrototypeOf","getOwnPropertyDescriptor","runtime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","state","method","arg","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","done","makeInvokeMethod","fn","obj","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","reverse","pop","skipTempReset","prev","charAt","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","isValidLatencyHint","latencyHint","ReadOnlyMap","parameters","_map","size","entries","callback","thisArg","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","k","computeBufferSize","baseLatency","sampleRate","max","min","round","log2","createUnknownError","isDCCurve","curve","createAbortError","createAddAudioNodeConnections","audioNodeConnectionsStore","audioNodeRenderer","activeInputs","numberOfInputs","Set","outputs","passiveInputs","renderer","createAddAudioParamConnections","audioParamConnectionsStore","audioParamRenderer","createAddSilentConnection","nativeGainNode","channelCount","channelCountMode","channelInterpretation","gain","destination","removeEventListener","addEventListener","createAddUnrenderedAudioWorkletNode","audioWorkletNode","DEFAULT_OPTIONS","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","createAnalyserNodeConstructor","audionNodeConstructor","mergedOptions","nativeAnalyserNode","super","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getByteTimeDomainData","getFloatFrequencyData","getFloatTimeDomainData","createAnalyserNodeRendererFactory","renderedNativeAnalyserNodes","proxy","nativeOfflineAudioContext","trace","renderedNativeAnalyserNode","createAnalyserNode","numberOfChannels","createAudioBufferConstructor","testNativeAudioBufferConstructorSupport","AudioBuffer","createBuffer","hasInstance","instance","loop","loopEnd","loopStart","playbackRate","createAudioBufferSourceNodeConstructor","nativeAudioBufferSourceNode","isOffline","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","fill","wrappedListener","onended","nativeOnEnded","resetInternalStateToPassive","setTimeout","createAudioBufferSourceNodeRendererFactory","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioContextConstructor","nativeAudioContext","_baseLatency","_nativeAudioContext","_state","revokeState","close","mediaElement","mediaStream","mediaStreamTrack","resolvePromise","resume","suspend","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","nativeAudioDestinationNodePromise","render","createAudioDestinationNode","createAudioListenerFactory","nativeListener","listener","forwardX","forwardY","forwardZ","positionX","positionY","positionZ","upX","upY","upZ","channelMergerNode","scriptProcessorNode","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","onaudioprocess","inputBuffer","orientation","some","setOrientation","positon","setPosition","createFakeAudioParams","createAudioParamFactory","addAudioParamConnections","audioParamStore","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","nativeAudioParam","maxValue","minValue","automationEventList","setValueAtTime","currentTime","cancelAndHoldAtTime","flush","previousLastEvent","Array","from","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","setTargetAtTime","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","numberOfOutputs","outputChannelCount","parameterData","processorOptions","createChannelCount","createAudioWorkletNodeConstructor","sanitizedOptions","nodeNameToProcessorConstructorMap","processorConstructor","nativeAudioWorkletNode","nm","_nativeAudioWorkletNode","_onprocessorerror","_parameters","onprocessorerror","nativeOnProcessorError","port","createBaseAudioContextConstructor","_nativeContext","_audioWorklet","addModule","moduleURL","maxDelayTime","real","imag","constraints","disableNormalization","audioData","successCallback","errorCallback","Q","detune","frequency","createBiquadFilterNodeConstructor","nativeBiquadFilterNode","_Q","_detune","_frequency","_gain","log10","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeRendererFactory","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createCacheTestResult","ongoingTests","testResults","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createChannelMergerNodeConstructor","createChannelMergerNodeRendererFactory","renderedNativeAudioNodes","renderedNativeAudioNode","createAudioNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","createConnectAudioParam","createConnectMultipleOutputs","outputAudioNodes","outputAudioNode","createConnectedNativeAudioBufferSourceNodeFactory","createConstantSourceNodeConstructor","createConstantSourceNodeRendererFactory","nativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","createConvertNumberToUnsignedLong","unit32Array","createConvolverNodeConstructor","nativeConvolverNode","_nativeConvolverNode","normalize","createConvolverNodeRendererFactory","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createCreateNativeOfflineAudioContext","createDataCloneError","createDecrementCycleCounter","cycleCounters","count","cycleCounter","nativeDestinationAudioParam","delayTime","createDelayNodeConstructor","nativeDelayNode","_delayTime","createDelayNodeRendererFactory","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDeleteUnrenderedAudioWorkletNode","getOutputAudioNodeAtIndex","createDisconnectMultipleOutputs","destinationOrOutput","attack","knee","ratio","release","threshold","createDynamicsCompressorNodeConstructor","nativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeRendererFactory","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createEncodingError","createEvaluateSource","source","SyntaxError","head","document","script","createElement","blob","Blob","url","URL","createObjectURL","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","revokeObjectURL","message","src","lineno","colno","location","href","onload","appendChild","createEventTargetConstructor","_nativeEventTarget","_listeners","wrappedEventListener","dispatchEvent","createExposeCurrentFrameAndCurrentTime","currentFrame","configurable","createFetchSource","response","fetch","ok","text","createGainNodeConstructor","createGainNodeRendererFactory","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGetAudioNodeRenderer","audioNodeConnections","createGetAudioParamRenderer","audioParamConnections","createGetBackupNativeContext","backupNativeContext","bckpNtveCntxt","createGetNativeContext","contextStore","createGetUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodes","createIIRFilterNodeRendererFactory","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","ntvCntxt","partialOfflineAudioContext","renderedBuffer","filteredBuffer","filterFullBuffer","createIncrementCycleCounterFactory","createIsAnyAudioContext","anything","createIsAnyAudioNode","audioNodeStore","createIsAnyAudioParam","createIsAnyOfflineAudioContext","createIsNativeAudioContext","createIsNativeAudioNode","AudioNode","createIsNativeAudioParam","AudioParam","createIsNativeContext","createIsNativeOfflineAudioContext","createIsSecureContext","createIsSupportedPromise","testAudioBufferCopyChannelMethodsSubarraySupport","testAudioContextCloseMethodSupport","testAudioContextDecodeAudioDataMethodTypeErrorSupport","testAudioContextOptionsSupport","testAudioNodeConnectMethodSupport","testAudioWorkletProcessorNoOutputsSupport","testChannelMergerNodeChannelCountSupport","testConstantSourceNodeAccurateSchedulingSupport","testConvolverNodeBufferReassignabilitySupport","testIsSecureContextSupport","testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","testStereoPannerNodeDefaultValueSupport","testTransferablesSupport","all","every","createMediaElementAudioSourceNodeConstructor","nativeMediaElementAudioSourceNode","_mediaElement","_nativeMediaElementAudioSourceNode","createMediaStreamAudioDestinationNodeConstructor","nativeMediaStreamAudioDestinationNode","_nativeMediaStreamAudioDestinationNode","stream","createMediaStreamAudioSourceNodeConstructor","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","createMinimalAudioContextConstructor","createMinimalBaseAudioContextConstructor","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalOfflineAudioContextConstructor","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","createMonitorConnections","whenConnected","whenDisconnected","connections","wasDisconnected","connection","wasConnected","apply","clear","isDisconnected","createNativeAudioBufferConstructor","createNativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","gainNode","createNativeAudioNodeFactory","factoryFunction","createNativeAudioWorkletNodeConstructor","AudioWorkletNode","createNativeBiquadFilterNodeFactory","createBiquadFilter","createNativeChannelMergerNodeFactory","nativeChannelMergerNode","createChannelMerger","createNativeConstantSourceNodeFactory","createConstantSource","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","audioBufferSourceNode","nativeConstantSourceNodeFaker","args","createNativeConvolverNodeFactory","createConvolver","createNativeConvolverNodeFakerFactory","convolverNode","nativeConvolverNodeFaker","createNativeDelayNodeFactory","createDelay","createNativeDynamicsCompressorNodeFactory","createDynamicsCompressor","createNativeGainNodeFactory","createGain","createNativeIIRFilterNodeFactory","divide","a","b","denominator","evaluatePolynomial","coefficient","z","createNativeIIRFilterNodeFakerFactory","bufferSize","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","nativeIIRFilterNodeFaker","omega","PI","cos","sin","sqrt","atan2","createNativeMediaElementAudioSourceNodeFactory","ntvDCntxt","createMediaElementSource","createNativeMediaStreamAudioDestinationNodeFactory","createMediaStreamDestination","createNativeMediaStreamAudioSourceNodeFactory","audioStreamTracks","getAudioTracks","filteredAudioStreamTracks","sort","id","createMediaStreamSource","MediaStream","createNativeMediaStreamTrackAudioSourceNodeFactory","createMediaStreamTrackSource","kind","createNativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOscillatorNodeFactory","nativeOscillatorNode","createOscillator","periodicWave","setPeriodicWave","createNativePannerNodeFactory","nativePannerNode","createPanner","orientationX","createNativePannerNodeFakerFactory","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationY","orientationZ","panningModel","refDistance","rolloffFactor","pannerNode","SINGLE_CHANNEL_OPTIONS","inputGainNode","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","oversample","nativePannerNodeFaker","createNativePeriodicWaveFactory","wrappedImag","wrappedReal","createPeriodicWave","createNativeScriptProcessorNodeFactory","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","createNativeStereoPannerNodeFactory","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFakerFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","CURVE_SIZE","channelSplitterNode","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","pan","connectGraph","disconnectGraph","isConnected","createNativeWaveShaperNodeFactory","nativeWaveShaperNode","createWaveShaper","disconnectNativeAudioBufferSourceNode","createNativeWaveShaperNodeFakerFactory","negativeWaveShaperNode","positiveWaveShaperNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","createOfflineAudioContextConstructor","createOscillatorNodeConstructor","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeRendererFactory","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createPannerNodeConstructor","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeRendererFactory","renderedBufferPromise","renderedNativeGainNodeOrNativePannerNode","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","createPeriodicWaveConstructor","periodicWaveStore","PeriodicWave","createRenderAutomation","getAudioParamRenderer","replay","createRenderInputsOfAudioNode","nextTrace","filter","includes","reduce","allRenderingPromises","renderingPromises","createRenderInputsOfAudioParam","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","oncomplete","createStartRendering","createStereoPannerNodeConstructor","_pan","createStereoPannerNodeRendererFactory","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createTestAudioBufferConstructorSupport","createTestAudioBufferCopyChannelMethodsSubarraySupport","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","createBufferSource","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","offlineAudioContext","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport","createTestAudioContextCloseMethodSupport","audioContext","isAudioContextClosable","createTestAudioContextDecodeAudioDataMethodTypeErrorSupport","isPending","createTestAudioContextOptionsSupport","createTestAudioNodeConnectMethodSupport","isSupported","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","createTestAudioWorkletProcessorNoOutputsSupport","isCallingProcess","audioWorklet","onmessage","createTestChannelMergerNodeChannelCountSupport","createTestConstantSourceNodeAccurateSchedulingSupport","Number","POSITIVE_INFINITY","createTestConvolverNodeBufferReassignabilitySupport","createTestIsSecureContextSupport","createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","createTestOfflineAudioContextCurrentTimeSupport","createTestStereoPannerNodeDefaultValueSupport","stereoPanner","createWaveShaperNodeConstructor","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeRendererFactory","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWindow","createWrapAudioBufferCopyChannelMethods","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","nullifiedBuffer","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","isStopped","createWrapChannelMergerNode","monitorConnectionsFunction","arrayBuffer","ArrayBuffer","port1","port2","MessageChannel","data","postMessage","wrapAudioBufferSourceNodeStartMethodOffsetClamping","clampedOffset","isAudioWorkletNode","deleteEventListenerOfAudioNode","isPassiveAudioNode","pickElementFromSet","matchingElements","matchingElement","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","analyzer","dummy","ones","chnnlDt","sample","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputConnections","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","eventListeners","isActive","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","createAudioNodeConstructor","addAudioNodeConnections","createIncrementCycleCounter","decrementCycleCounter","detectCycles","_context","_nativeAudioNode","returnValue","connectionsToDestination","filteredConnections","wrapAudioNodeDisconnectMethod","auxiliaryGainNodes","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","destinations","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","onmessageerror","cloneAudioWorkletNodeOptions","createNativeAudioWorkletNodeFakerFactory","sum","numberOfParameters","parameterDescriptors","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","patchedEventListener","audioWorkletProcessor","nodeToProcessorMap","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","prmtrs","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","potentiallyEmptyInputs","activeSourceFlag","process","ErrorEvent","disconnectFakeGraph","connectFakeGraph","createNativeAudioBufferSourceNodeFactory","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","stopTime","actualStartTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","importStatements","sourceWithoutImportStatements","replace","match","unresolvedUrl","importStatementWithResolvedUrl","join","verifyParameterDescriptors","isArray","verifyProcessorCtor","processorCtor","constructible","Proxy","isConstructible","createAddAudioWorkletModule","evaluateSource","fetchSource","ongoingRequests","resolvedRequests","credentials","absoluteUrl","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","evaluateAudioWorkletGlobalScope","_AWGS","trim","rslvdRqstsFCntxt","ngngRqstsFCntxt","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","createNativeAnalyserNodeFactory","createAnalyser","byteTimeDomainData","Uint8Array","wrapAnalyserNodeGetFloatTimeDomainDataMethod","createIIRFilterNodeConstructor","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createDetectCycles","chain","nextLink","isDelayNode","mergedCycles","nestedCycles","concat","createDecodeAudioData","detachedArrayBuffers","anyContext","detachArrayBuffer","fail","createNativeAudioWorkletNodeFactory","testClonabilityOfAudioWorkletNodeOptions","processBuffer","processedBuffer","getAudioWorkletProcessor","createAudioWorkletNodeRendererFactory","processedBufferPromise","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","createNativeChannelSplitterNodeFactory","nativeChannelSplitterNode","createChannelSplitter","wrapChannelSplitterNode","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","arr","_arr","_n","_d","_e","_s","_i","arrayLikeToArray","minLen","len","arr2","Constructor","_defineProperties","props","writable","protoProps","staticProps","assert","statement","assertRange","gte","lte","Infinity","assertContextRunning","warn","defaultLogger","console","isUndef","isDefined","isNumber","isObject","isBoolean","isString","isNote","createOfflineAudioContext","channels","theWindow","hasAudioContext","__decorate","decorators","desc","arguments","Reflect","decorate","__awaiter","_arguments","P","fulfilled","step","e","rejected","Ticker","updateInterval","_callback","_type","_updateInterval","_createClock","toFixed","blobUrl","worker","Worker","_worker","_timeout","_createTimeout","_createWorker","clearTimeout","terminate","interval","_disposeClock","isAudioParam","isOfflineAudioContext","isAudioContext","isAudioBuffer","noCopy","deepMerge","sources","shift","assign","optionsFromArguments","defaults","argsArray","objKey","opts","indexOf","defaultArg","given","fallback","omitFromObject","omit","prop","debug","_wasDisposed","TONE_DEBUG_CLASS","log","version","GT","GTE","EQ","LT","abs","clamp","_timeline","getDefaults","memory","increasing","valueOf","lastValue","_search","diff","param","after","beginning","end","midPoint","nextEvent","lowerBound","upperBound","_iterate","dispose","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","split","eventName","_events","boundCallback","off","on","eventList","constr","_constants","_timeouts","_timeoutIds","_initialized","_workletModules","_latencyHint","lookAhead","_ticker","emit","clockSource","_timeoutLoop","ctx","feedForward","initialize","_transport","_draw","createAudioWorkletNode","rawContext","promises","hint","lookAheadValue","val","constant","now","firstEvent","peek","timeout","remove","intervalFn","readOnly","str","noOp","load","_buffer","getContext","loaded","_reversed","_reverse","doneLoading","downloads","isMultidimensional","multiChannelArray","chanNum","fromArray","toArray","outputArray","numChannels","channelArray","ret","startSamples","endSamples","retBuffer","subarray","rev","matches","extensions","extension","ext","supportsType","baseUrl","endsWith","canPlayType","_currentTime","_duration","asynchronous","yieldEvery","workletsAreReady","_renderClock","dummyContext","_numberOfChannels","_sampleRate","_numberOfInputs","_numberOfOutputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_audioData","_name","_options","_url","_fn","_id","_interval","_val","globalContext","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","units","defaultUnits","_units","_expressions","_getExpressions","hz","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","transport","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","testNotations","power","closest","closestSeconds","notation","notationSeconds","quarterTime","quarters","measures","sixteenths","sixteenthString","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","intervals","transpose","scaleIndexToNote","cbb","cx","dbb","dx","ebb","eb","ex","fbb","fb","f","fx","gbb","gb","g","gx","abb","ab","ax","bbb","bb","bx","defaultContext","attribute","member","_getPartialProperties","initial","_initial","setStateAtTime","overridden","_minOutput","_param","_swappable","swappable","_initialValue","convert","_minValue","_maxValue","_toType","getValueAtTime","_fromType","_is","computedTime","isFinite","JSON","stringify","_assertRange","getAfter","before","beforeValue","previous","getBefore","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","currentVal","rampTime","setRampPoint","exponentialApproachValueAtTime","scaling","startingValue","segTime","cancel","valueAtTime","sampleTime","exponentialRampTo","linearRampTo","previousEvent","subdivisions","forEachAfter","t0","v0","v1","t1","_internalChannels","node","nodeList","_isAudioNode","_getInternalNodes","_getChannelProperties","_setChannelProperties","outputNum","inputNum","toDestination","nodes","connectSeries","first","current","srcNode","dstNode","outputNumber","inputNumber","_gainNode","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","fadeInTime","_stopGain","cancelStop","fadeOutTime","targetRampTo","additionalTail","_stopSource","_source","_startGain","override","_constantSource","connectSignal","rampTo","signal","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","currentTick","getTicksAtTime","getTimeOfTick","tick","delta","sol1","sol2","getDurationOfTicks","computedDuration","startTicks","ticksToTime","timeToTicks","_tickOffset","setTicksAtTime","stopEvent","getLastState","tmpEvent","lastState","elapsedTicks","forEachBetween","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","lastStateEvent","forEachTickBetween","maxStartTime","nextTickTime","_lastUpdate","_boundLoop","_loop","_tickSource","pause","mixin","initialValue","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","_removeNode","forEachFrom","replacement","isLeftChild","left","right","_setRoot","_replaceNodeInParent","temp","getBalance","pivotNode","balance","_rotateLeft","_rotateRight","low","allNodes","traverse","searchAfter","high","_left","_right","height","point","_eventId","_once","once","_currentId","_nextId","_nextTick","_boundRestart","_restart","_createEvents","scheduleOnce","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","forEachAtTime","_addEvent","eventId","item","timeline","computedAfter","offsetTicks","timeSig","startPosition","endPosition","toNotation","toBarsBeatsSixteenths","remainingTicks","computedFreq","ratioSignal","syncedSignal","volume","_unmutedVolume","mute","_buffers","_loadingCount","urls","_bufferLoaded","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","draw","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","sched","schedule","_start","restart","getNextState","_stop","stateEvent","startOffset","unsync","_sourceStarted","_sourceStopped","computedOffset","loopDuration","computedDur","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","generateWaveform","_oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","oscillator","_wave","syncSignal","unsyncSignal","_periodicWaveCache","find","description","_phase","arrayA","arrayB","oscProps","isBasicType","cache","_getCachedPeriodicWave","wave","_getRealImaginary","partial","exec","fullPartials","v","periodicWaveSize","piFactor","twoPi","_inverseFFT","_shaper","mapping","setMap","normalized","oversampling","_norm","_mult","factor","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","modulationIndex","_widthGate","_thresh","width","_triangle","_oscillators","_spread","spread","_forEach","osc","sourceType","_scale","_pulse","modulationFrequency","carrierType","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc","blockTime","sType","mType","range","valueMap","propertyKey","newValue","timeRange","_activeSources","_onload","autostart","origDuration","_onSourceEnd","implicitEnd","_sig","decay","sustain","attackCurve","releaseCurve","decayCurve","direction","curveName","EnvelopeCurves","curveDef","_getCurve","_attackCurve","_setCurve","_releaseCurve","_decayCurve","velocity","currentValue","decayValue","decayStart","triggerAttack","triggerRelease","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedFrequency","getLevelAtTime","portTime","envelope","computedAttack","computedDecay","modulation","modulationEnvelope","fan","pitchDecay","octaves","hertz","maxNote","workletContext","addToWorklet","classOrFunction","classOrFunctionToString","RegExp","registerProcessor","classDesc","processor","MessagePort","_inputs","_outputs","disposed","blockSize","params","paramName","updateParams","inputSample","generate","writeHead","delay","readHead","delayLine","DelayLine","delayedSample","urlMap","mid","notes","difference","_findClosest","closestNote","_panner","_split","_g2a","fade","getConstant","_dryWet","wet","effectSend","effectReturn","effect","_channel","bits","_merger","_convolver","ready","_decay","_preDelay","preDelay","connectEffect","previousReady","noiseL","noiseR","merge","renderPromise","_allSolos","solo","_isSoloed","_addSolo","_removeSolo","_updateSolo","_soloed","_noSolos","_solo","_panVol","muted","buses","bus","_getBus","sendKnob","immediate","getElementById","modal","modalChild","preventDefault","style","display","synths","Tone","synth","$rows","body","querySelectorAll","scheduleRepeat","querySelector","checked","play","wavetype","waveval","selectedIndex"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 686);\n","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap(); // This clunky name is borrowed from the spec. :-)\n\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n  assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n  assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n  assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n  return nativeAudioNode.context === nativeContext;\n};","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n  const value = options[option];\n\n  if (value !== undefined && value !== nativeAudioNode[option]) {\n    nativeAudioNode[option] = value;\n  }\n};","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n  const value = options[audioParam];\n\n  if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n    nativeAudioNode[audioParam].value = value;\n  }\n};","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = audioNode => {\n  return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};","export const createInvalidStateError = () => {\n  try {\n    return new DOMException('', 'InvalidStateError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 11;\n    err.name = 'InvalidStateError';\n    return err;\n  }\n};","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = audioNode => {\n  return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};","export const getValueForKey = (map, key) => {\n  const value = map.get(key);\n\n  if (value === undefined) {\n    throw new Error('A value with the given key could not be found.');\n  }\n\n  return value;\n};","export const createNotSupportedError = () => {\n  try {\n    return new DOMException('', 'NotSupportedError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 9;\n    err.name = 'NotSupportedError';\n    return err;\n  }\n};","export const interceptConnections = (original, interceptor) => {\n  original.connect = interceptor.connect.bind(interceptor);\n  original.disconnect = interceptor.disconnect.bind(interceptor);\n  return original;\n};","export const isNativeAudioNodeFaker = nativeAudioNodeOrNativeAudioNodeFaker => {\n  return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeConvolverNodeFakerFactory } from './factories/native-convolver-node-faker-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioDestinationNodeFactory } from './factories/native-media-stream-audio-destination-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\n\nexport * from './interfaces/index';\nexport * from './types/index';\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst auxiliaryGainNodeStore = new WeakMap();\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNodeFaker = createNativeConvolverNodeFakerFactory(createNativeAudioNode, createNativeGainNode, monitorConnections);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet());\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window); // The addAudioWorkletModule() function is only available in a SecureContext.\n\nexport const addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, getNativeContext, new WeakMap(), new WeakMap(), // @todo window is guaranteed to be defined because isSecureContext checks that as well.\nwindow) : undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext); // The AudioWorkletNode constructor is only available in a SecureContext.\n\nconst audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) : undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);","export const testPromiseSupport = nativeContext => {\n  // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n  const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n  try {\n    // Bug #1: Safari requires a successCallback.\n    const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {// Ignore the success callback.\n    });\n\n    if (promise === undefined) {\n      return false;\n    }\n\n    promise.catch(() => {// Ignore rejected errors.\n    });\n    return true;\n  } catch {// Ignore errors.\n  }\n\n  return false;\n};","export const createIndexSizeError = () => {\n  try {\n    return new DOMException('', 'IndexSizeError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 1;\n    err.name = 'IndexSizeError';\n    return err;\n  }\n};","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n  for (const lmnt of set) {\n    if (predicate(lmnt)) {\n      if (ignoreDuplicates) {\n        return false;\n      }\n\n      throw Error('The set contains at least one similar element.');\n    }\n  }\n\n  set.add(element);\n  return true;\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = audioNode => {\n  if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n    throw new Error('The AudioNode is already stored.');\n  }\n\n  ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n  getEventListenersOfAudioNode(audioNode).forEach(eventListener => eventListener(true));\n};","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) : (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, function (exports, _slicedToArray, _classCallCheck, _createClass) {\n  'use strict';\n\n  _slicedToArray = _slicedToArray && Object.prototype.hasOwnProperty.call(_slicedToArray, 'default') ? _slicedToArray['default'] : _slicedToArray;\n  _classCallCheck = _classCallCheck && Object.prototype.hasOwnProperty.call(_classCallCheck, 'default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && Object.prototype.hasOwnProperty.call(_createClass, 'default') ? _createClass['default'] : _createClass;\n\n  var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n    return {\n      endTime: endTime,\n      insertTime: insertTime,\n      type: 'exponentialRampToValue',\n      value: value\n    };\n  };\n\n  var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n    return {\n      endTime: endTime,\n      insertTime: insertTime,\n      type: 'linearRampToValue',\n      value: value\n    };\n  };\n\n  var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n    return {\n      startTime: startTime,\n      type: 'setValue',\n      value: value\n    };\n  };\n\n  var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n    return {\n      duration: duration,\n      startTime: startTime,\n      type: 'setValueCurve',\n      values: values\n    };\n  };\n\n  var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n    var startTime = _ref.startTime,\n        target = _ref.target,\n        timeConstant = _ref.timeConstant;\n    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n  };\n\n  var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'exponentialRampToValue';\n  };\n\n  var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'linearRampToValue';\n  };\n\n  var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n  };\n\n  var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setValue';\n  };\n\n  var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setValueCurve';\n  };\n\n  var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n    var automationEvent = automationEvents[index];\n    return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n  };\n\n  var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n    return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n  };\n\n  var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n    return automationEvent.type === 'cancelAndHold';\n  };\n\n  var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n    return automationEvent.type === 'cancelScheduledValues';\n  };\n\n  var getEventTime = function getEventTime(automationEvent) {\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n      return automationEvent.cancelTime;\n    }\n\n    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n      return automationEvent.endTime;\n    }\n\n    return automationEvent.startTime;\n  };\n\n  var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n    var endTime = _ref.endTime,\n        value = _ref.value;\n\n    if (valueAtStartTime === value) {\n      return value;\n    }\n\n    if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n      return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n    }\n\n    return 0;\n  };\n\n  var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n    var endTime = _ref.endTime,\n        value = _ref.value;\n    return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n  };\n\n  var interpolateValue = function interpolateValue(values, theoreticIndex) {\n    var lowerIndex = Math.floor(theoreticIndex);\n    var upperIndex = Math.ceil(theoreticIndex);\n\n    if (lowerIndex === upperIndex) {\n      return values[lowerIndex];\n    }\n\n    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n  };\n\n  var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n    var duration = _ref.duration,\n        startTime = _ref.startTime,\n        values = _ref.values;\n    var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n    return interpolateValue(values, theoreticIndex);\n  };\n\n  var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setTarget';\n  };\n\n  var AutomationEventList = /*#__PURE__*/function () {\n    function AutomationEventList(defaultValue) {\n      _classCallCheck(this, AutomationEventList);\n\n      this._automationEvents = [];\n      this._currenTime = 0;\n      this._defaultValue = defaultValue;\n    }\n\n    _createClass(AutomationEventList, [{\n      key: Symbol.iterator,\n      value: function value() {\n        return this._automationEvents[Symbol.iterator]();\n      }\n    }, {\n      key: \"add\",\n      value: function add(automationEvent) {\n        var eventTime = getEventTime(automationEvent);\n\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) >= eventTime;\n          });\n\n          var removedAutomationEvent = this._automationEvents[index];\n\n          if (index !== -1) {\n            this._automationEvents = this._automationEvents.slice(0, index);\n          }\n\n          if (isCancelAndHoldAutomationEvent(automationEvent)) {\n            var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n            if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n              if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                throw new Error('The internal list is malformed.');\n              }\n\n              var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n              var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n              var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n              var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n              this._automationEvents.push(truncatedAutomationEvent);\n            }\n\n            if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n              this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n            }\n\n            if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n              this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n            }\n          }\n        } else {\n          var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > eventTime;\n          });\n\n          var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n          if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n            return false;\n          }\n\n          var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n          if (_index === -1) {\n            this._automationEvents.push(persistentAutomationEvent);\n          } else {\n            if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n              return false;\n            }\n\n            this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n          }\n        }\n\n        return true;\n      }\n    }, {\n      key: \"flush\",\n      value: function flush(time) {\n        var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n          return getEventTime(currentAutomationEvent) > time;\n        });\n\n        if (index > 1) {\n          var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n          var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n          if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n            remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n          }\n\n          this._automationEvents = remainingAutomationEvents;\n        }\n      }\n    }, {\n      key: \"getValue\",\n      value: function getValue(time) {\n        if (this._automationEvents.length === 0) {\n          return this._defaultValue;\n        }\n\n        var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n        var index = this._automationEvents.findIndex(function (automationEvent) {\n          return getEventTime(automationEvent) > time;\n        });\n\n        var nextAutomationEvent = this._automationEvents[index];\n        var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n        if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n          return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n        }\n\n        if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n          return currentAutomationEvent.value;\n        }\n\n        if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n          if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n            return getValueCurveValueAtTime(time, currentAutomationEvent);\n          }\n\n          return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n\n        if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n          return currentAutomationEvent.value;\n        }\n\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n          var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n              startTime = _getEndTimeAndValueOf2[0],\n              value = _getEndTimeAndValueOf2[1];\n\n          return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n          var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n              _startTime = _getEndTimeAndValueOf4[0],\n              _value = _getEndTimeAndValueOf4[1];\n\n          return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n        }\n\n        return this._defaultValue;\n      }\n    }]);\n\n    return AutomationEventList;\n  }();\n\n  var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n    return {\n      cancelTime: cancelTime,\n      type: 'cancelAndHold'\n    };\n  };\n\n  var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n    return {\n      cancelTime: cancelTime,\n      type: 'cancelScheduledValues'\n    };\n  };\n\n  var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n    return {\n      endTime: endTime,\n      type: 'exponentialRampToValue',\n      value: value\n    };\n  };\n\n  var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n    return {\n      endTime: endTime,\n      type: 'linearRampToValue',\n      value: value\n    };\n  };\n\n  var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n    return {\n      startTime: startTime,\n      target: target,\n      timeConstant: timeConstant,\n      type: 'setTarget'\n    };\n  };\n\n  exports.AutomationEventList = AutomationEventList;\n  exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n  exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n  exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n  exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n  exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n  exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n  exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = audioNode => {\n  return CYCLE_COUNTERS.has(audioNode);\n};","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = audioNode => {\n  return getValueForKey(EVENT_LISTENERS, audioNode);\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = audioNode => {\n  if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n    throw new Error('The AudioNode is not stored.');\n  }\n\n  ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n  getEventListenersOfAudioNode(audioNode).forEach(eventListener => eventListener(false));\n};","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = outputConnection => {\n  return isAudioNode(outputConnection[0]);\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = audioNode => ACTIVE_AUDIO_NODE_STORE.has(audioNode);","export const isAudioNode = audioNodeOrAudioParam => {\n  return 'context' in audioNodeOrAudioParam;\n};","export const isNativeAudioNode = nativeAudioNodeOrAudioParam => {\n  return 'context' in nativeAudioNodeOrAudioParam;\n};","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = audioParam => {\n  return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = audioParam => {\n  return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};","export const wrapEventListener = (target, eventListener) => {\n  return event => {\n    const descriptor = {\n      value: target\n    };\n    Object.defineProperties(event, {\n      currentTarget: descriptor,\n      target: descriptor\n    });\n\n    if (typeof eventListener === 'function') {\n      return eventListener.call(target, event);\n    }\n\n    return eventListener.handleEvent.call(target, event);\n  };\n};","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = audioBuffer => {\n  audioBuffer.getChannelData = (getChannelData => {\n    return channel => {\n      try {\n        return getChannelData.call(audioBuffer, channel);\n      } catch (err) {\n        if (err.code === 12) {\n          throw createIndexSizeError();\n        }\n\n        throw err;\n      }\n    };\n  })(audioBuffer.getChannelData);\n};","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = nativeAudioScheduledSourceNode => {\n  nativeAudioScheduledSourceNode.start = (start => {\n    return (when = 0, offset = 0, duration) => {\n      if (typeof duration === 'number' && duration < 0 || offset < 0 || when < 0) {\n        throw new RangeError(\"The parameters can't be negative.\");\n      } // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n\n\n      start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n    };\n  })(nativeAudioScheduledSourceNode.start);\n};","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = nativeAudioScheduledSourceNode => {\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    return (when = 0) => {\n      if (when < 0) {\n        throw new RangeError(\"The parameter can't be negative.\");\n      }\n\n      stop.call(nativeAudioScheduledSourceNode, when);\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = nativeAudioBuffer => {\n  try {\n    nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n  } catch {\n    return false;\n  }\n\n  return true;\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n    const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n    nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n    return [fakeNativeDestinationAudioNode, output, 0];\n  }\n\n  nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n  return [nativeDestinationAudioNode, output, input];\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n  } else {\n    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n  }\n};","export function copyFromChannel(audioBuffer, // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n  if (typeof audioBuffer.copyFromChannel === 'function') {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength === 0) {\n      parent[key] = new Float32Array(128);\n    }\n\n    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset); // Bug #5: Safari does not support copyFromChannel().\n  } else {\n    const channelData = audioBuffer.getChannelData(channelNumber); // The byteLength will be 0 when the ArrayBuffer was transferred.\n\n    if (parent[key].byteLength === 0) {\n      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n    } else {\n      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n      parent[key].set(slicedInput);\n    }\n  }\n}","export const createNestedArrays = (x, y) => {\n  const arrays = [];\n\n  for (let i = 0; i < x; i += 1) {\n    const array = [];\n    const length = typeof y === 'number' ? y : y[i];\n\n    for (let j = 0; j < length; j += 1) {\n      array.push(new Float32Array(128));\n    }\n\n    arrays.push(array);\n  }\n\n  return arrays;\n};","export const createInvalidAccessError = () => {\n  try {\n    return new DOMException('', 'InvalidAccessError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 15;\n    err.name = 'InvalidAccessError';\n    return err;\n  }\n};","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n  let prototype = Object.getPrototypeOf(object);\n\n  while (!prototype.hasOwnProperty(property)) {\n    prototype = Object.getPrototypeOf(prototype);\n  }\n\n  const {\n    get,\n    set\n  } = Object.getOwnPropertyDescriptor(prototype, property);\n  Object.defineProperty(object, property, {\n    get: createGetter(get),\n    set: createSetter(set)\n  });\n};","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\ntypeof module === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}","export const isValidLatencyHint = latencyHint => {\n  return latencyHint === undefined || typeof latencyHint === 'number' || typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback');\n};","export class ReadOnlyMap {\n  constructor(parameters) {\n    this._map = new Map(parameters);\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  forEach(callback, thisArg = null) {\n    return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n  }\n\n  get(name) {\n    return this._map.get(name);\n  }\n\n  has(name) {\n    return this._map.has(name);\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n}","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n  if (typeof audioBuffer.copyToChannel === 'function') {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength !== 0) {\n      audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n    } // Bug #5: Safari does not support copyToChannel().\n\n  } else {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength !== 0) {\n      audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n    }\n  }\n};","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n  const inputLength = input.length;\n  let i = bufferIndex;\n\n  for (let j = 0; j < inputLength; j += 1) {\n    let y = feedforward[0] * input[j];\n\n    for (let k = 1; k < minLength; k += 1) {\n      const x = i - k & bufferLength - 1; // tslint:disable-line:no-bitwise\n\n      y += feedforward[k] * xBuffer[x];\n      y -= feedback[k] * yBuffer[x];\n    }\n\n    for (let k = minLength; k < feedforwardLength; k += 1) {\n      y += feedforward[k] * xBuffer[i - k & bufferLength - 1]; // tslint:disable-line:no-bitwise\n    }\n\n    for (let k = minLength; k < feedbackLength; k += 1) {\n      y -= feedback[k] * yBuffer[i - k & bufferLength - 1]; // tslint:disable-line:no-bitwise\n    }\n\n    xBuffer[i] = input[j];\n    yBuffer[i] = y;\n    i = i + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise\n\n    output[j] = y;\n  }\n\n  return i;\n};","export const computeBufferSize = (baseLatency, sampleRate) => {\n  if (baseLatency === null) {\n    return 512;\n  }\n\n  return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};","export const createUnknownError = () => {\n  try {\n    return new DOMException('', 'UnknownError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.name = 'UnknownError';\n    return err;\n  }\n};","export const isDCCurve = curve => {\n  if (curve === null) {\n    return false;\n  }\n\n  const length = curve.length;\n\n  if (length % 2 !== 0) {\n    return curve[Math.floor(length / 2)] !== 0;\n  }\n\n  return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};","export * from './analyser-node';\nexport * from './analyser-options';\nexport * from './audio-buffer';\nexport * from './audio-buffer-options';\nexport * from './audio-buffer-source-node';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-options';\nexport * from './audio-context';\nexport * from './audio-context-options';\nexport * from './audio-destination-node';\nexport * from './audio-listener';\nexport * from './audio-node';\nexport * from './audio-node-options';\nexport * from './audio-node-renderer';\nexport * from './audio-param';\nexport * from './audio-param-descriptor';\nexport * from './audio-param-renderer';\nexport * from './audio-scheduled-source-node';\nexport * from './audio-scheduled-source-node-event-map';\nexport * from './audio-worklet';\nexport * from './audio-worklet-node';\nexport * from './audio-worklet-node-event-map';\nexport * from './audio-worklet-node-options';\nexport * from './audio-worklet-processor';\nexport * from './audio-worklet-processor-constructor';\nexport * from './automation';\nexport * from './base-audio-context';\nexport * from './biquad-filter-node';\nexport * from './biquad-filter-options';\nexport * from './channel-merger-options';\nexport * from './channel-splitter-options';\nexport * from './common-audio-context';\nexport * from './common-offline-audio-context';\nexport * from './constant-source-node';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-options';\nexport * from './convolver-node';\nexport * from './convolver-options';\nexport * from './delay-node';\nexport * from './delay-options';\nexport * from './dynamics-compressor-node';\nexport * from './dynamics-compressor-options';\nexport * from './gain-node';\nexport * from './gain-options';\nexport * from './iir-filter-node';\nexport * from './iir-filter-options';\nexport * from './media-element-audio-source-node';\nexport * from './media-element-audio-source-options';\nexport * from './media-stream-audio-destination-node';\nexport * from './media-stream-audio-source-node';\nexport * from './media-stream-audio-source-options';\nexport * from './media-stream-track-audio-source-node';\nexport * from './media-stream-track-audio-source-options';\nexport * from './minimal-audio-context';\nexport * from './minimal-base-audio-context';\nexport * from './minimal-base-audio-context-event-map';\nexport * from './minimal-offline-audio-context';\nexport * from './native-audio-node-faker';\nexport * from './native-audio-worklet-node-faker';\nexport * from './native-constant-source-node-faker';\nexport * from './native-convolver-node-faker';\nexport * from './native-iir-filter-node-faker';\nexport * from './native-panner-node-faker';\nexport * from './native-stereo-panner-node-faker';\nexport * from './native-wave-shaper-node-faker';\nexport * from './offline-audio-completion-event';\nexport * from './offline-audio-context';\nexport * from './offline-audio-context-constructor';\nexport * from './offline-audio-context-options';\nexport * from './oscillator-node';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-options';\nexport * from './panner-node';\nexport * from './panner-options';\nexport * from './periodic-wave';\nexport * from './periodic-wave-constraints';\nexport * from './periodic-wave-options';\nexport * from './read-only-map';\nexport * from './stereo-panner-node';\nexport * from './stereo-panner-options';\nexport * from './wave-shaper-node';\nexport * from './wave-shaper-options';\nexport * from './worklet-options';","export * from './abort-error-factory';\nexport * from './active-input-connection';\nexport * from './add-audio-node-connections-factory';\nexport * from './add-audio-node-connections-function';\nexport * from './add-audio-param-connections-factory';\nexport * from './add-audio-param-connections-function';\nexport * from './add-audio-worklet-module-factory';\nexport * from './add-audio-worklet-module-function';\nexport * from './add-silent-connection-factory';\nexport * from './add-silent-connection-function';\nexport * from './add-unrendered-audio-worklet-node-factory';\nexport * from './add-unrendered-audio-worklet-node-function';\nexport * from './analyser-node-constructor';\nexport * from './analyser-node-constructor-factory';\nexport * from './analyser-node-renderer-factory';\nexport * from './analyser-node-renderer-factory-factory';\nexport * from './any-audio-buffer';\nexport * from './any-context';\nexport * from './audio-buffer-constructor';\nexport * from './audio-buffer-constructor-factory';\nexport * from './audio-buffer-source-node-constructor';\nexport * from './audio-buffer-source-node-constructor-factory';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-node-renderer-factory';\nexport * from './audio-buffer-source-node-renderer-factory-factory';\nexport * from './audio-buffer-store';\nexport * from './audio-context-constructor';\nexport * from './audio-context-constructor-factory';\nexport * from './audio-context-latency-category';\nexport * from './audio-context-state';\nexport * from './audio-destination-node-constructor';\nexport * from './audio-destination-node-constructor-factory';\nexport * from './audio-destination-node-renderer-factory';\nexport * from './audio-listener-factory';\nexport * from './audio-listener-factory-factory';\nexport * from './audio-node-connections';\nexport * from './audio-node-connections-store';\nexport * from './audio-node-constructor';\nexport * from './audio-node-constructor-factory';\nexport * from './audio-node-output-connection';\nexport * from './audio-node-renderer';\nexport * from './audio-node-store';\nexport * from './audio-param-audio-node-store';\nexport * from './audio-param-connections';\nexport * from './audio-param-connections-store';\nexport * from './audio-param-factory';\nexport * from './audio-param-factory-factory';\nexport * from './audio-param-map';\nexport * from './audio-param-output-connection';\nexport * from './audio-param-renderer-factory';\nexport * from './audio-param-store';\nexport * from './audio-worklet-node-constructor';\nexport * from './audio-worklet-node-constructor-factory';\nexport * from './audio-worklet-node-renderer-factory';\nexport * from './audio-worklet-node-renderer-factory-factory';\nexport * from './auxiliary-gain-node-store';\nexport * from './base-audio-context-constructor';\nexport * from './base-audio-context-constructor-factory';\nexport * from './biquad-filter-node-constructor';\nexport * from './biquad-filter-node-constructor-factory';\nexport * from './biquad-filter-node-renderer-factory';\nexport * from './biquad-filter-node-renderer-factory-factory';\nexport * from './biquad-filter-type';\nexport * from './channel-count-mode';\nexport * from './channel-interpretation';\nexport * from './channel-merger-node-constructor';\nexport * from './channel-merger-node-constructor-factory';\nexport * from './channel-merger-node-renderer-factory';\nexport * from './channel-merger-node-renderer-factory-factory';\nexport * from './channel-splitter-node-constructor';\nexport * from './channel-splitter-node-constructor-factory';\nexport * from './channel-splitter-node-renderer-factory';\nexport * from './channel-splitter-node-renderer-factory-factory';\nexport * from './cache-test-result-factory';\nexport * from './cache-test-result-function';\nexport * from './connect-audio-param-factory';\nexport * from './connect-audio-param-function';\nexport * from './connect-multiple-outputs-factory';\nexport * from './connect-multiple-outputs-function';\nexport * from './connect-native-audio-node-to-native-audio-node-function';\nexport * from './connected-native-audio-buffer-source-node-factory';\nexport * from './connected-native-audio-buffer-source-node-factory-factory';\nexport * from './constant-source-node-constructor';\nexport * from './constant-source-node-constructor-factory';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-node-renderer-factory';\nexport * from './constant-source-node-renderer-factory-factory';\nexport * from './constructor';\nexport * from './context';\nexport * from './context-store';\nexport * from './convert-number-to-unsigned-long-factory';\nexport * from './convert-number-to-unsigned-long-function';\nexport * from './convolver-node-constructor';\nexport * from './convolver-node-constructor-factory';\nexport * from './convolver-node-renderer-factory';\nexport * from './convolver-node-renderer-factory-factory';\nexport * from './create-native-offline-audio-context-factory';\nexport * from './create-native-offline-audio-context-function';\nexport * from './cycle-counters';\nexport * from './data-clone-error-factory';\nexport * from './decode-audio-data-factory';\nexport * from './decode-audio-data-function';\nexport * from './decode-error-callback';\nexport * from './decode-success-callback';\nexport * from './decrement-cycle-counter-factory';\nexport * from './decrement-cycle-counter-function';\nexport * from './delay-node-constructor';\nexport * from './delay-node-constructor-factory';\nexport * from './delay-node-renderer-factory';\nexport * from './delay-node-renderer-factory-factory';\nexport * from './delete-unrendered-audio-worklet-node-factory';\nexport * from './delete-unrendered-audio-worklet-node-function';\nexport * from './detect-cycles-factory';\nexport * from './detect-cycles-function';\nexport * from './disconnect-multiple-outputs-factory';\nexport * from './disconnect-multiple-outputs-function';\nexport * from './disconnect-native-audio-node-from-native-audio-node-function';\nexport * from './distance-model-type';\nexport * from './dynamics-compressor-node-constructor';\nexport * from './dynamics-compressor-node-constructor-factory';\nexport * from './dynamics-compressor-node-renderer-factory';\nexport * from './dynamics-compressor-node-renderer-factory-factory';\nexport * from './encoding-error-factory';\nexport * from './error-event-handler';\nexport * from './evaluate-audio-worklet-global-scope-function';\nexport * from './evaluate-source-factory';\nexport * from './evaluate-source-function';\nexport * from './event-handler';\nexport * from './event-target-constructor';\nexport * from './event-target-constructor-factory';\nexport * from './expose-current-frame-and-current-time-factory';\nexport * from './expose-current-frame-and-current-time-function';\nexport * from './fetch-source-factory';\nexport * from './fetch-source-function';\nexport * from './gain-node-constructor';\nexport * from './gain-node-constructor-factory';\nexport * from './gain-node-renderer-factory';\nexport * from './gain-node-renderer-factory-factory';\nexport * from './get-audio-node-connections-function';\nexport * from './get-audio-node-renderer-factory';\nexport * from './get-audio-node-renderer-function';\nexport * from './get-audio-param-connections-function';\nexport * from './get-audio-param-renderer-factory';\nexport * from './get-audio-param-renderer-function';\nexport * from './get-backup-native-context-factory';\nexport * from './get-backup-native-context-function';\nexport * from './get-native-audio-node-function';\nexport * from './get-native-audio-param-function';\nexport * from './get-native-context-function';\nexport * from './get-native-context-factory';\nexport * from './get-unrendered-audio-worklet-nodes-factory';\nexport * from './get-unrendered-audio-worklet-nodes-function';\nexport * from './get-value-for-key-function';\nexport * from './iir-filter-node-constructor';\nexport * from './iir-filter-node-constructor-factory';\nexport * from './iir-filter-node-renderer-factory';\nexport * from './iir-filter-node-renderer-factory-factory';\nexport * from './increment-cycle-counter-factory';\nexport * from './increment-cycle-counter-factory-factory';\nexport * from './increment-cycle-counter-function';\nexport * from './index-size-error-factory';\nexport * from './insert-element-in-set-function';\nexport * from './internal-state-event-listener';\nexport * from './invalid-access-error-factory';\nexport * from './invalid-state-error-factory';\nexport * from './is-active-audio-node-function';\nexport * from './is-any-audio-context-factory';\nexport * from './is-any-audio-context-function';\nexport * from './is-any-audio-node-factory';\nexport * from './is-any-audio-node-function';\nexport * from './is-any-audio-param-factory';\nexport * from './is-any-audio-param-function';\nexport * from './is-any-offline-audio-context-factory';\nexport * from './is-any-offline-audio-context-function';\nexport * from './is-dc-curve-function';\nexport * from './is-native-audio-context-factory';\nexport * from './is-native-audio-context-function';\nexport * from './is-native-audio-node-factory';\nexport * from './is-native-audio-node-function';\nexport * from './is-native-audio-param-factory';\nexport * from './is-native-audio-param-function';\nexport * from './is-native-context-factory';\nexport * from './is-native-context-function';\nexport * from './is-native-offline-audio-context-factory';\nexport * from './is-native-offline-audio-context-function';\nexport * from './is-part-of-a-cycle-function';\nexport * from './is-secure-context-factory';\nexport * from './is-supported-promise-factory';\nexport * from './media-element-audio-source-node-constructor';\nexport * from './media-element-audio-source-node-constructor-factory';\nexport * from './media-stream-audio-destination-node-constructor';\nexport * from './media-stream-audio-destination-node-constructor-factory';\nexport * from './media-stream-audio-source-node-constructor';\nexport * from './media-stream-audio-source-node-constructor-factory';\nexport * from './media-stream-track-audio-source-node-constructor';\nexport * from './media-stream-track-audio-source-node-constructor-factory';\nexport * from './minimal-audio-context-constructor';\nexport * from './minimal-audio-context-constructor-factory';\nexport * from './minimal-base-audio-context-constructor';\nexport * from './minimal-base-audio-context-constructor-factory';\nexport * from './minimal-offline-audio-context-constructor';\nexport * from './minimal-offline-audio-context-constructor-factory';\nexport * from './monitor-connections-factory';\nexport * from './monitor-connections-function';\nexport * from './native-analyser-node';\nexport * from './native-analyser-node-factory';\nexport * from './native-analyser-node-factory-factory';\nexport * from './native-audio-buffer';\nexport * from './native-audio-buffer-constructor';\nexport * from './native-audio-buffer-constructor-factory';\nexport * from './native-audio-buffer-source-node';\nexport * from './native-audio-buffer-source-node-factory';\nexport * from './native-audio-buffer-source-node-factory-factory';\nexport * from './native-audio-context';\nexport * from './native-audio-context-constructor';\nexport * from './native-audio-context-constructor-factory';\nexport * from './native-audio-destination-node';\nexport * from './native-audio-destination-node-factory';\nexport * from './native-audio-destination-node-factory-factory';\nexport * from './native-audio-listener';\nexport * from './native-audio-node';\nexport * from './native-audio-node-factory';\nexport * from './native-audio-node-factory-factory';\nexport * from './native-audio-param';\nexport * from './native-audio-param-map';\nexport * from './native-audio-worklet';\nexport * from './native-audio-worklet-node';\nexport * from './native-audio-worklet-node-constructor';\nexport * from './native-audio-worklet-node-constructor-factory';\nexport * from './native-audio-worklet-node-factory';\nexport * from './native-audio-worklet-node-factory-factory';\nexport * from './native-audio-worklet-node-faker-factory';\nexport * from './native-audio-worklet-node-faker-factory-factory';\nexport * from './native-audio-worklet-node-options';\nexport * from './native-biquad-filter-node';\nexport * from './native-biquad-filter-node-factory';\nexport * from './native-biquad-filter-node-factory-factory';\nexport * from './native-channel-merger-node';\nexport * from './native-channel-merger-node-factory';\nexport * from './native-channel-merger-node-factory-factory';\nexport * from './native-channel-splitter-node';\nexport * from './native-channel-splitter-node-factory';\nexport * from './native-channel-splitter-node-factory-factory';\nexport * from './native-constant-source-node';\nexport * from './native-constant-source-node-factory';\nexport * from './native-constant-source-node-factory-factory';\nexport * from './native-constant-source-node-faker-factory';\nexport * from './native-constant-source-node-faker-factory-factory';\nexport * from './native-context';\nexport * from './native-convolver-node';\nexport * from './native-convolver-node-factory';\nexport * from './native-convolver-node-factory-factory';\nexport * from './native-convolver-node-faker-factory';\nexport * from './native-convolver-node-faker-factory-factory';\nexport * from './native-delay-node-factory';\nexport * from './native-delay-node-factory-factory';\nexport * from './native-delay-node';\nexport * from './native-dynamics-compressor-node';\nexport * from './native-dynamics-compressor-node-factory';\nexport * from './native-dynamics-compressor-node-factory-factory';\nexport * from './native-event-target';\nexport * from './native-gain-node';\nexport * from './native-gain-node-factory';\nexport * from './native-gain-node-factory-factory';\nexport * from './native-iir-filter-node';\nexport * from './native-iir-filter-node-factory';\nexport * from './native-iir-filter-node-factory-factory';\nexport * from './native-iir-filter-node-faker-factory';\nexport * from './native-iir-filter-node-faker-factory-factory';\nexport * from './native-media-element-audio-source-node';\nexport * from './native-media-element-audio-source-node-factory';\nexport * from './native-media-element-audio-source-node-factory-factory';\nexport * from './native-media-stream-audio-destination-node';\nexport * from './native-media-stream-audio-destination-node-factory';\nexport * from './native-media-stream-audio-destination-node-factory-factory';\nexport * from './native-media-stream-audio-source-node';\nexport * from './native-media-stream-audio-source-node-factory';\nexport * from './native-media-stream-audio-source-node-factory-factory';\nexport * from './native-media-stream-track-audio-source-node';\nexport * from './native-media-stream-track-audio-source-node-factory';\nexport * from './native-media-stream-track-audio-source-node-factory-factory';\nexport * from './native-offline-audio-context';\nexport * from './native-offline-audio-context-constructor';\nexport * from './native-offline-audio-context-constructor-factory';\nexport * from './native-oscillator-node';\nexport * from './native-oscillator-node-factory';\nexport * from './native-oscillator-node-factory-factory';\nexport * from './native-panner-node';\nexport * from './native-panner-node-factory';\nexport * from './native-panner-node-factory-factory';\nexport * from './native-panner-node-faker-factory';\nexport * from './native-panner-node-faker-factory-factory';\nexport * from './native-periodic-wave';\nexport * from './native-periodic-wave-factory';\nexport * from './native-periodic-wave-factory-factory';\nexport * from './native-script-processor-node';\nexport * from './native-script-processor-node-factory';\nexport * from './native-script-processor-node-factory-factory';\nexport * from './native-stereo-panner-node';\nexport * from './native-stereo-panner-node-factory';\nexport * from './native-stereo-panner-node-factory-factory';\nexport * from './native-stereo-panner-node-faker-factory';\nexport * from './native-stereo-panner-node-faker-factory-factory';\nexport * from './native-wave-shaper-node';\nexport * from './native-wave-shaper-node-factory';\nexport * from './native-wave-shaper-node-factory-factory';\nexport * from './native-wave-shaper-node-faker-factory';\nexport * from './native-wave-shaper-node-faker-factory-factory';\nexport * from './not-supported-error-factory';\nexport * from './offline-audio-context-constructor-factory';\nexport * from './oscillator-node-constructor';\nexport * from './oscillator-node-constructor-factory';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-node-renderer-factory';\nexport * from './oscillator-node-renderer-factory-factory';\nexport * from './oscillator-type';\nexport * from './output-connection';\nexport * from './over-sample-type';\nexport * from './overwrite-accessors-function';\nexport * from './panner-node-constructor';\nexport * from './panner-node-constructor-factory';\nexport * from './panner-node-renderer-factory';\nexport * from './panner-node-renderer-factory-factory';\nexport * from './panning-model-type';\nexport * from './passive-audio-node-input-connection';\nexport * from './passive-audio-param-input-connection';\nexport * from './periodic-wave-constructor';\nexport * from './periodic-wave-constructor-factory';\nexport * from './render-automation-factory';\nexport * from './render-automation-function';\nexport * from './render-inputs-of-audio-node-factory';\nexport * from './render-inputs-of-audio-node-function';\nexport * from './render-inputs-of-audio-param-factory';\nexport * from './render-inputs-of-audio-param-function';\nexport * from './render-native-offline-audio-context-factory';\nexport * from './render-native-offline-audio-context-function';\nexport * from './start-rendering-factory';\nexport * from './start-rendering-function';\nexport * from './stereo-panner-node-constructor';\nexport * from './stereo-panner-node-constructor-factory';\nexport * from './stereo-panner-node-renderer-factory-factory';\nexport * from './stereo-panner-node-renderer-factory';\nexport * from './test-audio-buffer-copy-channel-methods-subarray-support-factory';\nexport * from './test-audio-buffer-constructor-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-duration-parameter-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-offset-clamping-support-factory';\nexport * from './test-audio-buffer-source-node-stop-method-nullified-buffer-support-factory';\nexport * from './test-audio-context-close-method-support-factory';\nexport * from './test-audio-context-decode-audio-data-method-type-error-support-factory';\nexport * from './test-audio-context-options-support-factory';\nexport * from './test-audio-node-connect-method-support-factory';\nexport * from './test-audio-scheduled-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-negative-parameters-support-factory';\nexport * from './test-audio-worklet-processor-no-outputs-support-factory';\nexport * from './test-channel-merger-node-channel-count-support-factory';\nexport * from './test-constant-source-node-accurate-scheduling-support-factory';\nexport * from './test-convolver-node-buffer-reassignability-support-factory';\nexport * from './test-is-secure-context-support-factory';\nexport * from './test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nexport * from './test-offline-audio-context-current-time-support-factory';\nexport * from './test-stereo-panner-node-default-value-support-factory';\nexport * from './typed-array';\nexport * from './unknown-error-factory';\nexport * from './unrendered-audio-worklet-node-store';\nexport * from './unrendered-audio-worklet-nodes';\nexport * from './wave-shaper-node-constructor';\nexport * from './wave-shaper-node-constructor-factory';\nexport * from './wave-shaper-node-renderer-factory-factory';\nexport * from './wave-shaper-node-renderer-factory';\nexport * from './window-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-function';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-function';\nexport * from './wrap-audio-buffer-source-node-start-method-offset-clamping-function';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-function';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-factory';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function';\nexport * from './wrap-channel-merger-node-factory';\nexport * from './wrap-channel-merger-node-function';\nexport * from './wrap-event-listener-function';","export const createAbortError = () => {\n  try {\n    return new DOMException('', 'AbortError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 20;\n    err.name = 'AbortError';\n    return err;\n  }\n};","export const createAddAudioNodeConnections = audioNodeConnectionsStore => {\n  return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n    const activeInputs = [];\n\n    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n      activeInputs.push(new Set());\n    }\n\n    audioNodeConnectionsStore.set(audioNode, {\n      activeInputs,\n      outputs: new Set(),\n      passiveInputs: new WeakMap(),\n      renderer: audioNodeRenderer\n    });\n  };\n};","export const createAddAudioParamConnections = audioParamConnectionsStore => {\n  return (audioParam, audioParamRenderer) => {\n    audioParamConnectionsStore.set(audioParam, {\n      activeInputs: new Set(),\n      passiveInputs: new WeakMap(),\n      renderer: audioParamRenderer\n    });\n  };\n};","export const createAddSilentConnection = createNativeGainNode => {\n  return (nativeContext, nativeAudioScheduledSourceNode) => {\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n    nativeAudioScheduledSourceNode.connect(nativeGainNode)\n    /*\n     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n     * used here to make sure to connect the right destination.\n     */\n    .connect(nativeGainNode.context.destination);\n\n    const disconnect = () => {\n      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n      nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n  };\n};","export const createAddUnrenderedAudioWorkletNode = getUnrenderedAudioWorkletNodes => {\n  return (nativeContext, audioWorkletNode) => {\n    getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  fftSize: 2048,\n  maxDecibels: -30,\n  minDecibels: -100,\n  smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class AnalyserNode extends audionNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n      const analyserNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null;\n      super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n      this._nativeAnalyserNode = nativeAnalyserNode;\n    }\n\n    get fftSize() {\n      return this._nativeAnalyserNode.fftSize;\n    }\n\n    set fftSize(value) {\n      this._nativeAnalyserNode.fftSize = value;\n    }\n\n    get frequencyBinCount() {\n      return this._nativeAnalyserNode.frequencyBinCount;\n    }\n\n    get maxDecibels() {\n      return this._nativeAnalyserNode.maxDecibels;\n    }\n\n    set maxDecibels(value) {\n      // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n      const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n      this._nativeAnalyserNode.maxDecibels = value;\n\n      if (!(value > this._nativeAnalyserNode.minDecibels)) {\n        this._nativeAnalyserNode.maxDecibels = maxDecibels;\n        throw createIndexSizeError();\n      }\n    }\n\n    get minDecibels() {\n      return this._nativeAnalyserNode.minDecibels;\n    }\n\n    set minDecibels(value) {\n      // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n      const minDecibels = this._nativeAnalyserNode.minDecibels;\n      this._nativeAnalyserNode.minDecibels = value;\n\n      if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n        this._nativeAnalyserNode.minDecibels = minDecibels;\n        throw createIndexSizeError();\n      }\n    }\n\n    get smoothingTimeConstant() {\n      return this._nativeAnalyserNode.smoothingTimeConstant;\n    }\n\n    set smoothingTimeConstant(value) {\n      this._nativeAnalyserNode.smoothingTimeConstant = value;\n    }\n\n    getByteFrequencyData(array) {\n      this._nativeAnalyserNode.getByteFrequencyData(array);\n    }\n\n    getByteTimeDomainData(array) {\n      this._nativeAnalyserNode.getByteTimeDomainData(array);\n    }\n\n    getFloatFrequencyData(array) {\n      this._nativeAnalyserNode.getFloatFrequencyData(array);\n    }\n\n    getFloatTimeDomainData(array) {\n      this._nativeAnalyserNode.getFloatTimeDomainData(array);\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAnalyserNodes = new WeakMap();\n\n    const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAnalyserNode = getNativeAudioNode(proxy); // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n      if (!nativeAnalyserNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAnalyserNode.channelCount,\n          channelCountMode: nativeAnalyserNode.channelCountMode,\n          channelInterpretation: nativeAnalyserNode.channelInterpretation,\n          fftSize: nativeAnalyserNode.fftSize,\n          maxDecibels: nativeAnalyserNode.maxDecibels,\n          minDecibels: nativeAnalyserNode.minDecibels,\n          smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n        };\n        nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n      return nativeAnalyserNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAnalyserNode !== undefined) {\n          return Promise.resolve(renderedNativeAnalyserNode);\n        }\n\n        return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  let nativeOfflineAudioContext = null;\n  return class AudioBuffer {\n    constructor(options) {\n      if (nativeOfflineAudioContextConstructor === null) {\n        throw new Error('Missing the native OfflineAudioContext constructor.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n\n      if (nativeOfflineAudioContext === null) {\n        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n      }\n      /*\n       * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n       * factory function. But since Firefox also supports the constructor everything should be fine.\n       */\n\n\n      const audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n        length,\n        numberOfChannels,\n        sampleRate\n      }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate); // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n\n      if (audioBuffer.numberOfChannels === 0) {\n        throw createNotSupportedError();\n      } // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n\n\n      if (typeof audioBuffer.copyFromChannel !== 'function') {\n        wrapAudioBufferCopyChannelMethods(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n      } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n      }\n\n      audioBufferStore.add(audioBuffer);\n      /*\n       * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n       * (Offline)AudioContexts.\n       */\n\n      return audioBuffer;\n    }\n\n    static [Symbol.hasInstance](instance) {\n      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n    }\n\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  // Bug #149: Safari does not yet support the detune AudioParam.\n  loop: false,\n  loopEnd: 0,\n  loopStart: 0,\n  playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class AudioBufferSourceNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n      super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n      this._isBufferNullified = false;\n      this._isBufferSet = options.buffer !== null && options.buffer !== undefined;\n      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n      this._onended = null; // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get buffer() {\n      if (this._isBufferNullified) {\n        return null;\n      }\n\n      return this._nativeAudioBufferSourceNode.buffer;\n    }\n\n    set buffer(value) {\n      // Bug #71: Edge does not allow to set the buffer to null.\n      try {\n        this._nativeAudioBufferSourceNode.buffer = value;\n      } catch (err) {\n        if (value !== null || err.code !== 17) {\n          throw err;\n        } // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n\n\n        if (this._nativeAudioBufferSourceNode.buffer !== null) {\n          const buffer = this._nativeAudioBufferSourceNode.buffer;\n          const numberOfChannels = buffer.numberOfChannels;\n\n          for (let i = 0; i < numberOfChannels; i += 1) {\n            buffer.getChannelData(i).fill(0);\n          }\n\n          this._isBufferNullified = true;\n        }\n      } // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n\n\n      if (value !== null) {\n        if (this._isBufferSet) {\n          throw createInvalidStateError();\n        }\n\n        this._isBufferSet = true;\n      }\n    }\n\n    get loop() {\n      return this._nativeAudioBufferSourceNode.loop;\n    }\n\n    set loop(value) {\n      this._nativeAudioBufferSourceNode.loop = value;\n    }\n\n    get loopEnd() {\n      return this._nativeAudioBufferSourceNode.loopEnd;\n    }\n\n    set loopEnd(value) {\n      this._nativeAudioBufferSourceNode.loopEnd = value;\n    }\n\n    get loopStart() {\n      return this._nativeAudioBufferSourceNode.loopStart;\n    }\n\n    set loopStart(value) {\n      this._nativeAudioBufferSourceNode.loopStart = value;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioBufferSourceNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    get playbackRate() {\n      return this._playbackRate;\n    }\n\n    start(when = 0, offset = 0, duration) {\n      this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeAudioBufferSourceNode.stop(when);\n\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioBufferSourceNodes = new WeakMap();\n    let start = null;\n    let stop = null;\n\n    const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n        const options = {\n          buffer: nativeAudioBufferSourceNode.buffer,\n          channelCount: nativeAudioBufferSourceNode.channelCount,\n          channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n          channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n          // Bug #149: Safari does not yet support the detune AudioParam.\n          loop: nativeAudioBufferSourceNode.loop,\n          loopEnd: nativeAudioBufferSourceNode.loopEnd,\n          loopStart: nativeAudioBufferSourceNode.loopStart,\n          playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n        };\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n        if (start !== null) {\n          nativeAudioBufferSourceNode.start(...start);\n        }\n\n        if (stop !== null) {\n          nativeAudioBufferSourceNode.stop(stop);\n        }\n      }\n\n      renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n      } else {\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode, trace);\n      return nativeAudioBufferSourceNode;\n    };\n\n    return {\n      set start(value) {\n        start = value;\n      },\n\n      set stop(value) {\n        stop = value;\n      },\n\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioBufferSourceNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioBufferSourceNode);\n        }\n\n        return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n  return class AudioContext extends baseAudioContextConstructor {\n    constructor(options = {}) {\n      if (nativeAudioContextConstructor === null) {\n        throw new Error('Missing the native AudioContext constructor.');\n      }\n\n      const nativeAudioContext = new nativeAudioContextConstructor(options); // Bug #131 Safari returns null when there are four other AudioContexts running already.\n\n      if (nativeAudioContext === null) {\n        throw createUnknownError();\n      } // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n\n\n      if (!isValidLatencyHint(options.latencyHint)) {\n        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n      } // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n\n\n      if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n        throw createNotSupportedError();\n      }\n\n      super(nativeAudioContext, 2);\n      const {\n        latencyHint\n      } = options;\n      const {\n        sampleRate\n      } = nativeAudioContext; // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n\n      this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n      /*\n       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n       * ScriptProcessorNode.\n       */\n      Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n      this._nativeAudioContext = nativeAudioContext;\n      this._state = null;\n      /*\n       * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n       * to 'running'.\n       */\n\n      if (nativeAudioContext.state === 'running') {\n        this._state = 'suspended';\n\n        const revokeState = () => {\n          if (this._state === 'suspended') {\n            this._state = null;\n          }\n\n          nativeAudioContext.removeEventListener('statechange', revokeState);\n        };\n\n        nativeAudioContext.addEventListener('statechange', revokeState);\n      }\n    }\n\n    get baseLatency() {\n      return this._baseLatency;\n    }\n\n    get state() {\n      return this._state !== null ? this._state : this._nativeAudioContext.state;\n    }\n\n    close() {\n      // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n      if (this.state === 'closed') {\n        return this._nativeAudioContext.close().then(() => {\n          throw createInvalidStateError();\n        });\n      } // Bug #34: If the state was set to suspended before it should be revoked now.\n\n\n      if (this._state === 'suspended') {\n        this._state = null;\n      }\n\n      return this._nativeAudioContext.close();\n      /*\n       * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n       * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n       */\n    }\n\n    createMediaElementSource(mediaElement) {\n      return new mediaElementAudioSourceNodeConstructor(this, {\n        mediaElement\n      });\n    }\n\n    createMediaStreamDestination() {\n      return new mediaStreamAudioDestinationNodeConstructor(this);\n    }\n\n    createMediaStreamSource(mediaStream) {\n      return new mediaStreamAudioSourceNodeConstructor(this, {\n        mediaStream\n      });\n    }\n\n    createMediaStreamTrackSource(mediaStreamTrack) {\n      return new mediaStreamTrackAudioSourceNodeConstructor(this, {\n        mediaStreamTrack\n      });\n    }\n\n    resume() {\n      if (this._state === 'suspended') {\n        return new Promise((resolve, reject) => {\n          const resolvePromise = () => {\n            this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n            if (this._nativeAudioContext.state === 'running') {\n              resolve();\n            } else {\n              this.resume().then(resolve, reject);\n            }\n          };\n\n          this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n        });\n      }\n\n      return this._nativeAudioContext.resume().catch(err => {\n        // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined || err.code === 15) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n    suspend() {\n      return this._nativeAudioContext.suspend().catch(err => {\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n  };\n};","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n  return class AudioDestinationNode extends audioNodeConstructor {\n    constructor(context, channelCount) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n      const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null;\n      super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n      this._isNodeOfNativeOfflineAudioContext = isOffline;\n      this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n    }\n\n    get channelCount() {\n      return this._nativeAudioDestinationNode.channelCount;\n    }\n\n    set channelCount(value) {\n      // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n      // Bug #54: Firefox does throw an IndexSizeError.\n      if (this._isNodeOfNativeOfflineAudioContext) {\n        throw createInvalidStateError();\n      } // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n\n\n      if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n        throw createIndexSizeError();\n      }\n\n      this._nativeAudioDestinationNode.channelCount = value;\n    }\n\n    get channelCountMode() {\n      return this._nativeAudioDestinationNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      // Bug #53: No browser does throw an exception yet.\n      if (this._isNodeOfNativeOfflineAudioContext) {\n        throw createInvalidStateError();\n      }\n\n      this._nativeAudioDestinationNode.channelCountMode = value;\n    }\n\n    get maxChannelCount() {\n      return this._nativeAudioDestinationNode.maxChannelCount;\n    }\n\n  };\n};","export const createAudioDestinationNodeRenderer = renderInputsOfAudioNode => {\n  let nativeAudioDestinationNodePromise = null;\n\n  const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext, trace) => {\n    const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n    await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode, trace);\n    return nativeAudioDestinationNode;\n  };\n\n  return {\n    render(proxy, nativeOfflineAudioContext, trace) {\n      if (nativeAudioDestinationNodePromise === null) {\n        nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n      return nativeAudioDestinationNodePromise;\n    }\n\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n  return (context, nativeContext) => {\n    const nativeListener = nativeContext.listener; // Bug #117: Only Chrome & Opera support the new interface already.\n\n    const createFakeAudioParams = () => {\n      const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: 9\n      });\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n      const createFakeAudioParam = (input, value) => {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: value\n        });\n        constantSourceNode.connect(channelMergerNode, 0, input); // @todo This should be stopped when the context is closed.\n\n        constantSourceNode.start();\n        Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n          get() {\n            return value;\n          }\n\n        });\n        /*\n         * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n         * minValue for GainNodes.\n         */\n\n        return createAudioParam({\n          context\n        }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      };\n\n      let lastOrientation = [0, 0, -1, 0, 1, 0];\n      let lastPosition = [0, 0, 0];\n\n      scriptProcessorNode.onaudioprocess = ({\n        inputBuffer\n      }) => {\n        const orientation = [inputBuffer.getChannelData(0)[0], inputBuffer.getChannelData(1)[0], inputBuffer.getChannelData(2)[0], inputBuffer.getChannelData(3)[0], inputBuffer.getChannelData(4)[0], inputBuffer.getChannelData(5)[0]];\n\n        if (orientation.some((value, index) => value !== lastOrientation[index])) {\n          nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n          lastOrientation = orientation;\n        }\n\n        const positon = [inputBuffer.getChannelData(6)[0], inputBuffer.getChannelData(7)[0], inputBuffer.getChannelData(8)[0]];\n\n        if (positon.some((value, index) => value !== lastPosition[index])) {\n          nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n          lastPosition = positon;\n        }\n      };\n\n      channelMergerNode.connect(scriptProcessorNode);\n      return {\n        forwardX: createFakeAudioParam(0, 0),\n        forwardY: createFakeAudioParam(1, 0),\n        forwardZ: createFakeAudioParam(2, -1),\n        positionX: createFakeAudioParam(6, 0),\n        positionY: createFakeAudioParam(7, 0),\n        positionZ: createFakeAudioParam(8, 0),\n        upX: createFakeAudioParam(3, 0),\n        upY: createFakeAudioParam(4, 1),\n        upZ: createFakeAudioParam(5, 0)\n      };\n    };\n\n    const {\n      forwardX,\n      forwardY,\n      forwardZ,\n      positionX,\n      positionY,\n      positionZ,\n      upX,\n      upY,\n      upZ\n    } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n    return {\n      get forwardX() {\n        return forwardX;\n      },\n\n      get forwardY() {\n        return forwardY;\n      },\n\n      get forwardZ() {\n        return forwardZ;\n      },\n\n      get positionX() {\n        return positionX;\n      },\n\n      get positionY() {\n        return positionY;\n      },\n\n      get positionZ() {\n        return positionZ;\n      },\n\n      get upX() {\n        return upX;\n      },\n\n      get upY() {\n        return upY;\n      },\n\n      get upZ() {\n        return upZ;\n      }\n\n    };\n  };\n};","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n    const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return nativeAudioParam.defaultValue;\n      },\n\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n\n      get value() {\n        return nativeAudioParam.value;\n      },\n\n      set value(value) {\n        nativeAudioParam.value = value; // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n\n      cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n\n        return audioParam;\n      },\n\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n\n      exponentialRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      linearRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n\n      setValueCurveAtTime(values, startTime, duration) {\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (values.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? values[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n          }\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n\n          if (timeOfLastSample < endTime) {\n            audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n\n          audioParam.setValueAtTime(values[values.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n        }\n\n        return audioParam;\n      }\n\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","export const createAudioParamRenderer = automationEventList => {\n  return {\n    replay(audioParam) {\n      for (const automationEvent of automationEventList) {\n        if (automationEvent.type === 'exponentialRampToValue') {\n          const {\n            endTime,\n            value\n          } = automationEvent;\n          audioParam.exponentialRampToValueAtTime(value, endTime);\n        } else if (automationEvent.type === 'linearRampToValue') {\n          const {\n            endTime,\n            value\n          } = automationEvent;\n          audioParam.linearRampToValueAtTime(value, endTime);\n        } else if (automationEvent.type === 'setTarget') {\n          const {\n            startTime,\n            target,\n            timeConstant\n          } = automationEvent;\n          audioParam.setTargetAtTime(target, startTime, timeConstant);\n        } else if (automationEvent.type === 'setValue') {\n          const {\n            startTime,\n            value\n          } = automationEvent;\n          audioParam.setValueAtTime(value, startTime);\n        } else if (automationEvent.type === 'setValueCurve') {\n          const {\n            duration,\n            startTime,\n            values\n          } = automationEvent;\n          audioParam.setValueCurveAtTime(values, startTime, duration);\n        } else {\n          throw new Error(\"Can't apply an unknown automation.\");\n        }\n      }\n    }\n\n  };\n};","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  outputChannelCount: undefined,\n  parameterData: {},\n  processorOptions: {}\n};\n\nconst createChannelCount = length => {\n  const channelCount = [];\n\n  for (let i = 0; i < length; i += 1) {\n    channelCount.push(1);\n  }\n\n  return channelCount;\n};\n\nconst sanitizedOptions = options => {\n  return { ...options,\n    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n    /*\n     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n     */\n    [options.channelCount] : createChannelCount(options.numberOfOutputs)\n  };\n};\n\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      });\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, this);\n      }\n    }\n\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n\n      return this._parameters;\n    }\n\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n\n  };\n};","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n  return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(_nativeContext, numberOfChannels) {\n      super(_nativeContext, numberOfChannels);\n      this._nativeContext = _nativeContext;\n      this._audioWorklet = addAudioWorkletModule === undefined ? undefined : {\n        addModule: (moduleURL, options) => {\n          return addAudioWorkletModule(this, moduleURL, options);\n        }\n      };\n    }\n\n    get audioWorklet() {\n      return this._audioWorklet;\n    }\n\n    createAnalyser() {\n      return new analyserNodeConstructor(this);\n    }\n\n    createBiquadFilter() {\n      return new biquadFilterNodeConstructor(this);\n    }\n\n    createBuffer(numberOfChannels, length, sampleRate) {\n      return new audioBufferConstructor({\n        length,\n        numberOfChannels,\n        sampleRate\n      });\n    }\n\n    createBufferSource() {\n      return new audioBufferSourceNodeConstructor(this);\n    }\n\n    createChannelMerger(numberOfInputs = 6) {\n      return new channelMergerNodeConstructor(this, {\n        numberOfInputs\n      });\n    }\n\n    createChannelSplitter(numberOfOutputs = 6) {\n      return new channelSplitterNodeConstructor(this, {\n        numberOfOutputs\n      });\n    }\n\n    createConstantSource() {\n      return new constantSourceNodeConstructor(this);\n    }\n\n    createConvolver() {\n      return new convolverNodeConstructor(this);\n    }\n\n    createDelay(maxDelayTime = 1) {\n      return new delayNodeConstructor(this, {\n        maxDelayTime\n      });\n    }\n\n    createDynamicsCompressor() {\n      return new dynamicsCompressorNodeConstructor(this);\n    }\n\n    createGain() {\n      return new gainNodeConstructor(this);\n    }\n\n    createIIRFilter(feedforward, feedback) {\n      return new iIRFilterNodeConstructor(this, {\n        feedback,\n        feedforward\n      });\n    }\n\n    createOscillator() {\n      return new oscillatorNodeConstructor(this);\n    }\n\n    createPanner() {\n      return new pannerNodeConstructor(this);\n    }\n\n    createPeriodicWave(real, imag, constraints = {\n      disableNormalization: false\n    }) {\n      return new periodicWaveConstructor(this, { ...constraints,\n        imag,\n        real\n      });\n    }\n\n    createStereoPanner() {\n      return new stereoPannerNodeConstructor(this);\n    }\n\n    createWaveShaper() {\n      return new waveShaperNodeConstructor(this);\n    }\n\n    decodeAudioData(audioData, successCallback, errorCallback) {\n      return decodeAudioData(this._nativeContext, audioData).then(audioBuffer => {\n        if (typeof successCallback === 'function') {\n          successCallback(audioBuffer);\n        }\n\n        return audioBuffer;\n      }).catch(err => {\n        if (typeof errorCallback === 'function') {\n          errorCallback(err);\n        }\n\n        throw err;\n      });\n    }\n\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n  Q: 1,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  detune: 0,\n  frequency: 350,\n  gain: 0,\n  type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class BiquadFilterNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer() : null;\n      super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer); // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT); // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n\n      this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n      /*\n       * Bug #77: Edge does not export the correct values for maxValue and minValue. Firefox & Safari do not export the correct value\n       * for minValue.\n       */\n\n      this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0); // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n\n      this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n      this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n    }\n\n    get detune() {\n      return this._detune;\n    }\n\n    get frequency() {\n      return this._frequency;\n    }\n\n    get gain() {\n      return this._gain;\n    }\n\n    get Q() {\n      return this._Q;\n    }\n\n    get type() {\n      return this._nativeBiquadFilterNode.type;\n    }\n\n    set type(value) {\n      this._nativeBiquadFilterNode.type = value;\n    }\n\n    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n      this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse); // Bug #68: Only Chrome, Firefox & Opera do throw an error if the parameters differ in their length.\n\n\n      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n        throw createInvalidAccessError();\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeBiquadFilterNodes = new WeakMap();\n\n    const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n      if (!nativeBiquadFilterNodeIsOwnedByContext) {\n        const options = {\n          Q: nativeBiquadFilterNode.Q.value,\n          channelCount: nativeBiquadFilterNode.channelCount,\n          channelCountMode: nativeBiquadFilterNode.channelCountMode,\n          channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n          detune: nativeBiquadFilterNode.detune.value,\n          frequency: nativeBiquadFilterNode.frequency.value,\n          gain: nativeBiquadFilterNode.gain.value,\n          type: nativeBiquadFilterNode.type\n        };\n        nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n      if (!nativeBiquadFilterNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode, trace);\n      return nativeBiquadFilterNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeBiquadFilterNode !== undefined) {\n          return Promise.resolve(renderedNativeBiquadFilterNode);\n        }\n\n        return createBiquadFilterNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createCacheTestResult = (ongoingTests, testResults) => {\n  return (tester, test) => {\n    const cachedTestResult = testResults.get(tester);\n\n    if (cachedTestResult !== undefined) {\n      return cachedTestResult;\n    }\n\n    const ongoingTest = ongoingTests.get(tester);\n\n    if (ongoingTest !== undefined) {\n      return ongoingTest;\n    }\n\n    try {\n      const synchronousTestResult = test();\n\n      if (synchronousTestResult instanceof Promise) {\n        ongoingTests.set(tester, synchronousTestResult);\n        return synchronousTestResult.catch(() => false).then(finalTestResult => {\n          ongoingTests.delete(tester);\n          testResults.set(tester, finalTestResult);\n          return finalTestResult;\n        });\n      }\n\n      testResults.set(tester, synchronousTestResult);\n      return synchronousTestResult;\n    } catch {\n      testResults.set(tester, false);\n      return false;\n    }\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 1,\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class ChannelMergerNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n      const channelMergerNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null;\n      super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAudioNode.channelCount,\n          channelCountMode: nativeAudioNode.channelCountMode,\n          channelInterpretation: nativeAudioNode.channelInterpretation,\n          numberOfInputs: nativeAudioNode.numberOfInputs\n        };\n        nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n      return nativeAudioNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 6,\n  channelCountMode: 'explicit',\n  channelInterpretation: 'discrete',\n  numberOfOutputs: 6\n};\n\nconst sanitizedOptions = options => {\n  return { ...options,\n    channelCount: options.numberOfOutputs\n  };\n};\n\nexport const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class ChannelSplitterNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      });\n      const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n      const channelSplitterNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null;\n      super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAudioNode.channelCount,\n          channelCountMode: nativeAudioNode.channelCountMode,\n          channelInterpretation: nativeAudioNode.channelInterpretation,\n          numberOfOutputs: nativeAudioNode.numberOfOutputs\n        };\n        nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n      return nativeAudioNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createConnectAudioParam = renderInputsOfAudioParam => {\n  return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n    return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n  };\n};","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = createIndexSizeError => {\n  return (outputAudioNodes, destination, output = 0, input = 0) => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n      throw createIndexSizeError();\n    }\n\n    if (isNativeAudioNode(destination)) {\n      return outputAudioNode.connect(destination, 0, input);\n    }\n\n    return outputAudioNode.connect(destination, 0);\n  };\n};","export const createConnectedNativeAudioBufferSourceNodeFactory = createNativeAudioBufferSourceNode => {\n  return (nativeContext, nativeAudioNode) => {\n    const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.loop = true;\n    nativeAudioBufferSourceNode.connect(nativeAudioNode);\n    nativeAudioBufferSourceNode.start();\n    return () => {\n      nativeAudioBufferSourceNode.stop();\n      nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n    };\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  offset: 1\n};\nexport const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class ConstantSourceNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory() : null;\n      super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n      this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n      this._nativeConstantSourceNode = nativeConstantSourceNode;\n      /*\n       * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n       * minValue for GainNodes.\n       */\n\n      this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._onended = null;\n    }\n\n    get offset() {\n      return this._offset;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeConstantSourceNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeConstantSourceNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    start(when = 0) {\n      this._nativeConstantSourceNode.start(when);\n\n      if (this._constantSourceNodeRenderer !== null) {\n        this._constantSourceNodeRenderer.start = when;\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeConstantSourceNode.stop(when);\n\n      if (this._constantSourceNodeRenderer !== null) {\n        this._constantSourceNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeConstantSourceNodes = new WeakMap();\n    let start = null;\n    let stop = null;\n\n    const createConstantSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeConstantSourceNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n      if (!nativeConstantSourceNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeConstantSourceNode.channelCount,\n          channelCountMode: nativeConstantSourceNode.channelCountMode,\n          channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n          offset: nativeConstantSourceNode.offset.value\n        };\n        nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n        if (start !== null) {\n          nativeConstantSourceNode.start(start);\n        }\n\n        if (stop !== null) {\n          nativeConstantSourceNode.stop(stop);\n        }\n      }\n\n      renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n      if (!nativeConstantSourceNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode, trace);\n      return nativeConstantSourceNode;\n    };\n\n    return {\n      set start(value) {\n        start = value;\n      },\n\n      set stop(value) {\n        stop = value;\n      },\n\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeConstantSourceNode !== undefined) {\n          return Promise.resolve(renderedNativeConstantSourceNode);\n        }\n\n        return createConstantSourceNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createConvertNumberToUnsignedLong = unit32Array => {\n  return value => {\n    unit32Array[0] = value;\n    return unit32Array[0];\n  };\n};","const DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'clamped-max',\n  channelInterpretation: 'speakers',\n  disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class ConvolverNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer() : null;\n      super(context, false, nativeConvolverNode, convolverNodeRenderer);\n      this._isBufferNullified = false;\n      this._nativeConvolverNode = nativeConvolverNode;\n    }\n\n    get buffer() {\n      if (this._isBufferNullified) {\n        return null;\n      }\n\n      return this._nativeConvolverNode.buffer;\n    }\n\n    set buffer(value) {\n      this._nativeConvolverNode.buffer = value; // Bug #115: Safari does not allow to set the buffer to null.\n\n      if (value === null && this._nativeConvolverNode.buffer !== null) {\n        const nativeContext = this._nativeConvolverNode.context;\n        this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n        this._isBufferNullified = true;\n      } else {\n        this._isBufferNullified = false;\n      }\n    }\n\n    get normalize() {\n      return this._nativeConvolverNode.normalize;\n    }\n\n    set normalize(value) {\n      this._nativeConvolverNode.normalize = value;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeConvolverNodes = new WeakMap();\n\n    const createConvolverNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeConvolverNode = getNativeAudioNode(proxy); // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n      if (!nativeConvolverNodeIsOwnedByContext) {\n        const options = {\n          buffer: nativeConvolverNode.buffer,\n          channelCount: nativeConvolverNode.channelCount,\n          channelCountMode: nativeConvolverNode.channelCountMode,\n          channelInterpretation: nativeConvolverNode.channelInterpretation,\n          disableNormalization: !nativeConvolverNode.normalize\n        };\n        nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n      if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode, trace);\n      }\n\n      return nativeConvolverNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeConvolverNode !== undefined) {\n          return Promise.resolve(renderedNativeConvolverNode);\n        }\n\n        return createConvolverNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n  return (numberOfChannels, length, sampleRate) => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      throw new Error('Missing the native OfflineAudioContext constructor.');\n    }\n\n    try {\n      return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n    } catch (err) {\n      // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n      // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n      // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n      if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n        throw createNotSupportedError();\n      }\n\n      throw err;\n    }\n  };\n};","export const createDataCloneError = () => {\n  try {\n    return new DOMException('', 'DataCloneError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 25;\n    err.name = 'DataCloneError';\n    return err;\n  }\n};","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n  return (audioNode, count) => {\n    const cycleCounter = cycleCounters.get(audioNode);\n\n    if (cycleCounter === undefined) {\n      throw new Error('Missing the expected cycle count.');\n    }\n\n    const nativeContext = getNativeContext(audioNode.context);\n    const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n    if (cycleCounter === count) {\n      cycleCounters.delete(audioNode);\n\n      if (!isOffline && isActiveAudioNode(audioNode)) {\n        const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n        const {\n          outputs\n        } = getAudioNodeConnections(audioNode);\n\n        for (const output of outputs) {\n          if (isAudioNodeOutputConnection(output)) {\n            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n            connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n          } else {\n            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n            nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n          }\n        }\n      }\n    } else {\n      cycleCounters.set(audioNode, cycleCounter - count);\n    }\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  delayTime: 0,\n  maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class DelayNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const delayNodeRenderer = isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null;\n      super(context, false, nativeDelayNode, delayNodeRenderer); // Bug #161: Edge does not export the correct values for maxValue and minValue.\n\n      this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n    }\n\n    get delayTime() {\n      return this._delayTime;\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return maxDelayTime => {\n    const renderedNativeDelayNodes = new WeakMap();\n\n    const createDelayNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeDelayNode = getNativeAudioNode(proxy); // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n      if (!nativeDelayNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeDelayNode.channelCount,\n          channelCountMode: nativeDelayNode.channelCountMode,\n          channelInterpretation: nativeDelayNode.channelInterpretation,\n          delayTime: nativeDelayNode.delayTime.value,\n          maxDelayTime\n        };\n        nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n      if (!nativeDelayNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode, trace);\n      return nativeDelayNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeDelayNode !== undefined) {\n          return Promise.resolve(renderedNativeDelayNode);\n        }\n\n        return createDelayNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createDeleteUnrenderedAudioWorkletNode = getUnrenderedAudioWorkletNodes => {\n  return (nativeContext, audioWorkletNode) => {\n    getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n  };\n};","import { isNativeAudioNode } from '../guards/native-audio-node';\n\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n  const outputAudioNode = outputAudioNodes[output];\n\n  if (outputAudioNode === undefined) {\n    throw createIndexSizeError();\n  }\n\n  return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs = createIndexSizeError => {\n  return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n    if (destinationOrOutput === undefined) {\n      return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect());\n    }\n\n    if (typeof destinationOrOutput === 'number') {\n      return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n    }\n\n    if (isNativeAudioNode(destinationOrOutput)) {\n      if (output === undefined) {\n        return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect(destinationOrOutput));\n      }\n\n      if (input === undefined) {\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n      }\n\n      return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n    }\n\n    if (output === undefined) {\n      return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect(destinationOrOutput));\n    }\n\n    return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n  };\n};","const DEFAULT_OPTIONS = {\n  attack: 0.003,\n  channelCount: 2,\n  channelCountMode: 'clamped-max',\n  channelInterpretation: 'speakers',\n  knee: 30,\n  ratio: 12,\n  release: 0.25,\n  threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext) => {\n  return class DynamicsCompressorNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer() : null;\n      super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer); // Bug #110: Edge does not export the correct values for maxValue and minValue.\n\n      this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n      this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n      this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n      this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n      this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n      this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n    }\n\n    get attack() {\n      return this._attack;\n    }\n    /*\n     * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n     * to be overwritten here.\n     */\n\n\n    get channelCount() {\n      return this._nativeDynamicsCompressorNode.channelCount;\n    }\n\n    set channelCount(value) {\n      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n      this._nativeDynamicsCompressorNode.channelCount = value;\n\n      if (value > 2) {\n        this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n        throw createNotSupportedError();\n      }\n    }\n    /*\n     * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n     * overwritten here.\n     */\n\n\n    get channelCountMode() {\n      return this._nativeDynamicsCompressorNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n      this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n      if (value === 'max') {\n        this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n        throw createNotSupportedError();\n      }\n    }\n\n    get knee() {\n      return this._knee;\n    }\n\n    get ratio() {\n      return this._ratio;\n    }\n\n    get reduction() {\n      // Bug #111: Safari returns an AudioParam instead of a number.\n      if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n        return this._nativeDynamicsCompressorNode.reduction.value;\n      }\n\n      return this._nativeDynamicsCompressorNode.reduction;\n    }\n\n    get release() {\n      return this._release;\n    }\n\n    get threshold() {\n      return this._threshold;\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeDynamicsCompressorNodes = new WeakMap();\n\n    const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n       * created again.\n       */\n\n      const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n        const options = {\n          attack: nativeDynamicsCompressorNode.attack.value,\n          channelCount: nativeDynamicsCompressorNode.channelCount,\n          channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n          channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n          knee: nativeDynamicsCompressorNode.knee.value,\n          ratio: nativeDynamicsCompressorNode.ratio.value,\n          release: nativeDynamicsCompressorNode.release.value,\n          threshold: nativeDynamicsCompressorNode.threshold.value\n        };\n        nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode, trace);\n      return nativeDynamicsCompressorNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeDynamicsCompressorNode !== undefined) {\n          return Promise.resolve(renderedNativeDynamicsCompressorNode);\n        }\n\n        return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createEncodingError = () => {\n  try {\n    return new DOMException('', 'EncodingError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 0;\n    err.name = 'EncodingError';\n    return err;\n  }\n};","export const createEvaluateSource = window => {\n  return source => new Promise((resolve, reject) => {\n    if (window === null) {\n      reject(new SyntaxError());\n      return;\n    }\n\n    const head = window.document.head;\n\n    if (head === null) {\n      reject(new SyntaxError());\n    } else {\n      const script = window.document.createElement('script'); // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n\n      const blob = new Blob([source], {\n        type: 'application/javascript'\n      });\n      const url = URL.createObjectURL(blob);\n      const originalOnErrorHandler = window.onerror;\n\n      const removeErrorEventListenerAndRevokeUrl = () => {\n        window.onerror = originalOnErrorHandler;\n        URL.revokeObjectURL(url);\n      };\n\n      window.onerror = (message, src, lineno, colno, error) => {\n        // @todo Edge thinks the source is the one of the html document.\n        if (src === url || src === window.location.href && lineno === 1 && colno === 1) {\n          removeErrorEventListenerAndRevokeUrl();\n          reject(error);\n          return false;\n        }\n\n        if (originalOnErrorHandler !== null) {\n          return originalOnErrorHandler(message, src, lineno, colno, error);\n        }\n      };\n\n      script.onerror = () => {\n        removeErrorEventListenerAndRevokeUrl();\n        reject(new SyntaxError());\n      };\n\n      script.onload = () => {\n        removeErrorEventListenerAndRevokeUrl();\n        resolve();\n      };\n\n      script.src = url;\n      script.type = 'module';\n      head.appendChild(script);\n    }\n  });\n};","export const createEventTargetConstructor = wrapEventListener => {\n  return class EventTarget {\n    constructor(_nativeEventTarget) {\n      this._nativeEventTarget = _nativeEventTarget;\n      this._listeners = new WeakMap();\n    }\n\n    addEventListener(type, listener, options) {\n      if (listener !== null) {\n        let wrappedEventListener = this._listeners.get(listener);\n\n        if (wrappedEventListener === undefined) {\n          wrappedEventListener = wrapEventListener(this, listener);\n\n          if (typeof listener === 'function') {\n            this._listeners.set(listener, wrappedEventListener);\n          }\n        }\n\n        this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n      }\n    }\n\n    dispatchEvent(event) {\n      return this._nativeEventTarget.dispatchEvent(event);\n    }\n\n    removeEventListener(type, listener, options) {\n      const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n      this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n    }\n\n  };\n};","export const createExposeCurrentFrameAndCurrentTime = window => {\n  return (currentTime, sampleRate, fn) => {\n    Object.defineProperties(window, {\n      currentFrame: {\n        configurable: true,\n\n        get() {\n          return Math.round(currentTime * sampleRate);\n        }\n\n      },\n      currentTime: {\n        configurable: true,\n\n        get() {\n          return currentTime;\n        }\n\n      }\n    });\n\n    try {\n      return fn();\n    } finally {\n      if (window !== null) {\n        delete window.currentFrame;\n        delete window.currentTime;\n      }\n    }\n  };\n};","export const createFetchSource = createAbortError => {\n  return async url => {\n    try {\n      const response = await fetch(url);\n\n      if (response.ok) {\n        return response.text();\n      }\n    } catch {}\n    /* Ignore errors. */\n    // tslint:disable-line:no-empty\n\n\n    throw createAbortError();\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  gain: 1\n};\nexport const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class GainNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const gainNodeRenderer = isOffline ? createGainNodeRenderer() : null;\n      super(context, false, nativeGainNode, gainNodeRenderer); // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get gain() {\n      return this._gain;\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeGainNodes = new WeakMap();\n\n    const createGainNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeGainNode = getNativeAudioNode(proxy); // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n      if (!nativeGainNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeGainNode.channelCount,\n          channelCountMode: nativeGainNode.channelCountMode,\n          channelInterpretation: nativeGainNode.channelInterpretation,\n          gain: nativeGainNode.gain.value\n        };\n        nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n      if (!nativeGainNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode, trace);\n      return nativeGainNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeGainNode !== undefined) {\n          return Promise.resolve(renderedNativeGainNode);\n        }\n\n        return createGainNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createGetAudioNodeRenderer = getAudioNodeConnections => {\n  return audioNode => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n    if (audioNodeConnections.renderer === null) {\n      throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n    }\n\n    return audioNodeConnections.renderer;\n  };\n};","export const createGetAudioParamRenderer = getAudioParamConnections => {\n  return audioParam => {\n    const audioParamConnections = getAudioParamConnections(audioParam);\n\n    if (audioParamConnections.renderer === null) {\n      throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n    }\n\n    return audioParamConnections.renderer;\n  };\n};","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n  return nativeContext => {\n    /*\n     * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n     * backupNativeContext in that case.\n     */\n    if (nativeContext.state === 'closed' && nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n\n        if (backupNativeContext !== undefined) {\n          return backupNativeContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor !== null) {\n          // @todo Copy the attached AudioWorkletProcessors and other settings.\n          const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n          BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n          return bckpNtveCntxt;\n        }\n      } else {\n        const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n\n        if (backupNativeContext !== undefined) {\n          return backupNativeContext;\n        } // @todo Copy the attached AudioWorkletProcessors and other settings.\n\n\n        const bckpNtveCntxt = new nativeAudioContextConstructor();\n        BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n        return bckpNtveCntxt;\n      }\n    }\n\n    return null;\n  };\n};","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = contextStore => {\n  return context => {\n    const nativeContext = contextStore.get(context);\n\n    if (nativeContext === undefined) {\n      throw createInvalidStateError();\n    }\n\n    return nativeContext;\n  };\n};","export const createGetUnrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore => {\n  return nativeContext => {\n    const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n    if (unrenderedAudioWorkletNodes === undefined) {\n      throw new Error('The context has no set of AudioWorkletNodes.');\n    }\n\n    return unrenderedAudioWorkletNodes;\n  };\n};","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n  const feedbackLength = feedback.length;\n  const feedforwardLength = feedforward.length;\n  const minLength = Math.min(feedbackLength, feedforwardLength);\n\n  if (feedback[0] !== 1) {\n    for (let i = 0; i < feedbackLength; i += 1) {\n      feedforward[i] /= feedback[0];\n    }\n\n    for (let i = 1; i < feedforwardLength; i += 1) {\n      feedback[i] /= feedback[0];\n    }\n  }\n\n  const bufferLength = 32;\n  const xBuffer = new Float32Array(bufferLength);\n  const yBuffer = new Float32Array(bufferLength);\n  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n  const numberOfChannels = renderedBuffer.numberOfChannels;\n\n  for (let i = 0; i < numberOfChannels; i += 1) {\n    const input = renderedBuffer.getChannelData(i);\n    const output = filteredBuffer.getChannelData(i);\n    xBuffer.fill(0);\n    yBuffer.fill(0);\n    filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n  }\n\n  return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (feedback, feedforward) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let filteredBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioBufferSourceNode = null;\n      let nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.\n\n      if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n      } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n        nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, ntvCntxt => {\n          return ntvCntxt.createIIRFilter(feedforward, feedback);\n        });\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n\n      if (nativeAudioBufferSourceNode !== null) {\n        if (filteredBufferPromise === null) {\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n\n          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor( // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n          proxy.context.destination.channelCount, // Bug #17: Safari does not yet expose the length.\n          proxy.context.length, nativeOfflineAudioContext.sampleRate);\n\n          filteredBufferPromise = (async () => {\n            await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n            const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n          })();\n        }\n\n        const filteredBuffer = await filteredBufferPromise;\n        nativeAudioBufferSourceNode.buffer = filteredBuffer;\n        nativeAudioBufferSourceNode.start(0);\n        return nativeAudioBufferSourceNode;\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n      return nativeIIRFilterNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n  return isOffline => {\n    return (audioNode, count) => {\n      const cycleCounter = cycleCounters.get(audioNode);\n\n      if (cycleCounter === undefined) {\n        if (!isOffline && isActiveAudioNode(audioNode)) {\n          const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n          const {\n            outputs\n          } = getAudioNodeConnections(audioNode);\n\n          for (const output of outputs) {\n            if (isAudioNodeOutputConnection(output)) {\n              const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n              disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n            } else {\n              const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n              nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n            }\n          }\n        }\n\n        cycleCounters.set(audioNode, count);\n      } else {\n        cycleCounters.set(audioNode, cycleCounter + count);\n      }\n    };\n  };\n};","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n  return anything => {\n    const nativeContext = contextStore.get(anything);\n    return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n  };\n};","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n  return anything => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n  return anything => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n  return anything => {\n    const nativeContext = contextStore.get(anything);\n    return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n  };\n};","export const createIsNativeAudioContext = nativeAudioContextConstructor => {\n  return anything => {\n    return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n  };\n};","export const createIsNativeAudioNode = window => {\n  return anything => {\n    return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n  };\n};","export const createIsNativeAudioParam = window => {\n  return anything => {\n    return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n  };\n};","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n  return anything => {\n    return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n  };\n};","export const createIsNativeOfflineAudioContext = nativeOfflineAudioContextConstructor => {\n  return anything => {\n    return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n  };\n};","export const createIsSecureContext = window => window !== null && window.isSecureContext;","export const createIsSupportedPromise = async (cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) => {\n  if (cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) && cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) && cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) && cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) && cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) && cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) && cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) && cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) && cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport)) {\n    const results = await Promise.all([cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport), cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport), cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport), cacheTestResult(testTransferablesSupport, testTransferablesSupport)]);\n    return results.every(result => result);\n  }\n\n  return false;\n};","export const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class MediaElementAudioSourceNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options); // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        throw TypeError();\n      }\n\n      super(context, true, nativeMediaElementAudioSourceNode, null); // Bug #63: Edge does not expose the mediaElement yet.\n\n      this._mediaElement = options.mediaElement;\n      this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n    }\n\n    get mediaElement() {\n      return this._nativeMediaElementAudioSourceNode.mediaElement === undefined ? this._mediaElement : this._nativeMediaElementAudioSourceNode.mediaElement;\n    }\n\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers'\n};\nexport const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class MediaStreamAudioDestinationNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context); // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        throw new TypeError();\n      }\n\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n      super(context, false, nativeMediaStreamAudioDestinationNode, null);\n      this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n    }\n\n    get stream() {\n      return this._nativeMediaStreamAudioDestinationNode.stream;\n    }\n\n  };\n};","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options); // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        throw new TypeError();\n      }\n\n      super(context, true, nativeMediaStreamAudioSourceNode, null);\n      this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n    }\n\n    get mediaStream() {\n      return this._nativeMediaStreamAudioSourceNode.mediaStream;\n    }\n\n  };\n};","export const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {\n  return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n      super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n    }\n\n  };\n};","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n  return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(options = {}) {\n      if (nativeAudioContextConstructor === null) {\n        throw new Error('Missing the native AudioContext constructor.');\n      }\n\n      const nativeAudioContext = new nativeAudioContextConstructor(options); // Bug #131 Safari returns null when there are four other AudioContexts running already.\n\n      if (nativeAudioContext === null) {\n        throw createUnknownError();\n      } // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n\n\n      if (!isValidLatencyHint(options.latencyHint)) {\n        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n      } // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n\n\n      if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n        throw createNotSupportedError();\n      }\n\n      super(nativeAudioContext, 2);\n      const {\n        latencyHint\n      } = options;\n      const {\n        sampleRate\n      } = nativeAudioContext; // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n\n      this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n      /*\n       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n       * ScriptProcessorNode.\n       */\n      Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n      this._nativeAudioContext = nativeAudioContext;\n      this._state = null;\n      /*\n       * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n       * changes to 'running'.\n       */\n\n      if (nativeAudioContext.state === 'running') {\n        this._state = 'suspended';\n\n        const revokeState = () => {\n          if (this._state === 'suspended') {\n            this._state = null;\n          }\n\n          nativeAudioContext.removeEventListener('statechange', revokeState);\n        };\n\n        nativeAudioContext.addEventListener('statechange', revokeState);\n      }\n    }\n\n    get baseLatency() {\n      return this._baseLatency;\n    }\n\n    get state() {\n      return this._state !== null ? this._state : this._nativeAudioContext.state;\n    }\n\n    close() {\n      // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n      if (this.state === 'closed') {\n        return this._nativeAudioContext.close().then(() => {\n          throw createInvalidStateError();\n        });\n      } // Bug #34: If the state was set to suspended before it should be revoked now.\n\n\n      if (this._state === 'suspended') {\n        this._state = null;\n      }\n\n      return this._nativeAudioContext.close();\n      /*\n       * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n       * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n       */\n    }\n\n    resume() {\n      if (this._state === 'suspended') {\n        return new Promise((resolve, reject) => {\n          const resolvePromise = () => {\n            this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n            if (this._nativeAudioContext.state === 'running') {\n              resolve();\n            } else {\n              this.resume().then(resolve, reject);\n            }\n          };\n\n          this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n        });\n      }\n\n      return this._nativeAudioContext.resume().catch(err => {\n        // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined || err.code === 15) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n    suspend() {\n      return this._nativeAudioContext.suspend().catch(err => {\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n  };\n};","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n  return class MinimalBaseAudioContext extends eventTargetConstructor {\n    constructor(_nativeContext, numberOfChannels) {\n      super(_nativeContext);\n      this._nativeContext = _nativeContext;\n      CONTEXT_STORE.set(this, _nativeContext); // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n\n      const sampleRate = _nativeContext.sampleRate;\n      Object.defineProperty(_nativeContext, 'sampleRate', {\n        get: () => sampleRate\n      });\n\n      if (isNativeOfflineAudioContext(_nativeContext)) {\n        unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n      }\n\n      this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n      this._listener = createAudioListener(this, _nativeContext);\n      this._onstatechange = null;\n    }\n\n    get currentTime() {\n      return this._nativeContext.currentTime;\n    }\n\n    get destination() {\n      return this._destination;\n    }\n\n    get listener() {\n      return this._listener;\n    }\n\n    get onstatechange() {\n      return this._onstatechange;\n    }\n\n    set onstatechange(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeContext.onstatechange = wrappedListener;\n      const nativeOnStateChange = this._nativeContext.onstatechange;\n      this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n    }\n\n    get sampleRate() {\n      return this._nativeContext.sampleRate;\n    }\n\n    get state() {\n      return this._nativeContext.state;\n    }\n\n  };\n};","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n  return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(options) {\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).then(audioBuffer => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        return audioBuffer;\n      }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n      .catch(err => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        throw err;\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n  return (nativeAudioNode, whenConnected, whenDisconnected) => {\n    const connections = new Set();\n\n    nativeAudioNode.connect = (connect => {\n      return (destination, output = 0, input = 0) => {\n        const wasDisconnected = connections.size === 0;\n\n        if (isNativeAudioNode(destination)) {\n          // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n          connect.call(nativeAudioNode, destination, output, input);\n          insertElementInSet(connections, [destination, output, input], connection => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n\n          if (wasDisconnected) {\n            whenConnected();\n          }\n\n          return destination;\n        }\n\n        connect.call(nativeAudioNode, destination, output);\n        insertElementInSet(connections, [destination, output], connection => connection[0] === destination && connection[1] === output, true);\n\n        if (wasDisconnected) {\n          whenConnected();\n        }\n\n        return;\n      };\n    })(nativeAudioNode.connect);\n\n    nativeAudioNode.disconnect = (disconnect => {\n      return (destinationOrOutput, output, input) => {\n        const wasConnected = connections.size > 0;\n\n        if (destinationOrOutput === undefined) {\n          disconnect.apply(nativeAudioNode);\n          connections.clear();\n        } else if (typeof destinationOrOutput === 'number') {\n          // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n          disconnect.call(nativeAudioNode, destinationOrOutput);\n\n          for (const connection of connections) {\n            if (connection[1] === destinationOrOutput) {\n              connections.delete(connection);\n            }\n          }\n        } else {\n          if (isNativeAudioNode(destinationOrOutput)) {\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n          } else {\n            // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n            disconnect.call(nativeAudioNode, destinationOrOutput, output);\n          }\n\n          for (const connection of connections) {\n            if (connection[0] === destinationOrOutput && (output === undefined || connection[1] === output) && (input === undefined || connection[2] === input)) {\n              connections.delete(connection);\n            }\n          }\n        }\n\n        const isDisconnected = connections.size === 0;\n\n        if (wasConnected && isDisconnected) {\n          whenDisconnected();\n        }\n      };\n    })(nativeAudioNode.disconnect);\n\n    return nativeAudioNode;\n  };\n};","export const createNativeAudioBufferConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  if (window.hasOwnProperty('AudioBuffer')) {\n    return window.AudioBuffer;\n  }\n\n  return null;\n};","export const createNativeAudioContextConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  if (window.hasOwnProperty('AudioContext')) {\n    return window.AudioContext;\n  }\n\n  return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n};","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n  return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeContext.destination; // Bug #132: Edge & Safari do not have the correct channelCount.\n\n    if (nativeAudioDestinationNode.channelCount !== channelCount) {\n      try {\n        nativeAudioDestinationNode.channelCount = channelCount;\n      } catch {// Bug #169: Safari throws an error on each attempt to change the channelCount.\n      }\n    } // Bug #83: Edge & Safari do not have the correct channelCountMode.\n\n\n    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n      nativeAudioDestinationNode.channelCountMode = 'explicit';\n    } // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n\n\n    if (nativeAudioDestinationNode.maxChannelCount === 0) {\n      Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n        value: channelCount\n      });\n    } // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n\n\n    const gainNode = createNativeGainNode(nativeContext, {\n      channelCount,\n      channelCountMode: nativeAudioDestinationNode.channelCountMode,\n      channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n      gain: 1\n    });\n    overwriteAccessors(gainNode, 'channelCount', get => () => get.call(gainNode), set => value => {\n      set.call(gainNode, value);\n\n      try {\n        nativeAudioDestinationNode.channelCount = value;\n      } catch (err) {\n        // Bug #169: Safari throws an error on each attempt to change the channelCount.\n        if (value > nativeAudioDestinationNode.maxChannelCount) {\n          throw err;\n        }\n      }\n    });\n    overwriteAccessors(gainNode, 'channelCountMode', get => () => get.call(gainNode), set => value => {\n      set.call(gainNode, value);\n      nativeAudioDestinationNode.channelCountMode = value;\n    });\n    overwriteAccessors(gainNode, 'channelInterpretation', get => () => get.call(gainNode), set => value => {\n      set.call(gainNode, value);\n      nativeAudioDestinationNode.channelInterpretation = value;\n    });\n    Object.defineProperty(gainNode, 'maxChannelCount', {\n      get: () => nativeAudioDestinationNode.maxChannelCount\n    }); // @todo This should be disconnected when the context is closed.\n\n    gainNode.connect(nativeAudioDestinationNode);\n    return gainNode;\n  };\n};","export const createNativeAudioNodeFactory = getBackupNativeContext => {\n  return (nativeContext, factoryFunction) => {\n    // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n    const backupNativeContext = getBackupNativeContext(nativeContext);\n\n    if (backupNativeContext !== null) {\n      return factoryFunction(backupNativeContext);\n    }\n\n    return factoryFunction(nativeContext);\n  };\n};","export const createNativeAudioWorkletNodeConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBiquadFilter());\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n    return nativeBiquadFilterNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n  return (nativeContext, options) => {\n    const nativeChannelMergerNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createChannelMerger(options.numberOfInputs);\n    }); // Bug #15: Safari does not return the default properties.\n\n    if (nativeChannelMergerNode.channelCount !== 1 && nativeChannelMergerNode.channelCountMode !== 'explicit') {\n      wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n    }\n\n    assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n    return nativeChannelMergerNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n  return (nativeContext, options) => {\n    // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n    if (nativeContext.createConstantSource === undefined) {\n      return createNativeConstantSourceNodeFaker(nativeContext, options);\n    }\n\n    const nativeConstantSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createConstantSource();\n    });\n    assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset'); // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n    } // Bug #44: Only Firefox does not throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n    } // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, nativeConstantSourceNode);\n    return nativeConstantSourceNode;\n  };\n};","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n  return (nativeContext, {\n    offset,\n    ...audioNodeOptions\n  }) => {\n    const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n    const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: offset\n    }); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    const channelData = audioBuffer.getChannelData(0); // Bug #95: Safari does not play or loop one sample buffers.\n\n    channelData[0] = 1;\n    channelData[1] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.loop = true;\n    const nativeConstantSourceNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return gainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return gainNode.context;\n      },\n\n      get inputs() {\n        return [];\n      },\n\n      get numberOfInputs() {\n        return audioBufferSourceNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return gainNode.numberOfOutputs;\n      },\n\n      get offset() {\n        return gainNode.gain;\n      },\n\n      get onended() {\n        return audioBufferSourceNode.onended;\n      },\n\n      set onended(value) {\n        audioBufferSourceNode.onended = value;\n      },\n\n      addEventListener(...args) {\n        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return audioBufferSourceNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n      },\n\n      start(when = 0) {\n        audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n      },\n\n      stop(when = 0) {\n        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n      }\n\n    };\n\n    const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode); // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, audioBufferSourceNode);\n    return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeConvolverNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createConvolver());\n\n    try {\n      // Bug #166: Opera does not allow yet to set the channelCount to 1.\n      nativeConvolverNode.channelCount = 1;\n    } catch (err) {\n      return createNativeConvolverNodeFaker(nativeContext, options);\n    }\n\n    assignNativeAudioNodeOptions(nativeConvolverNode, options); // The normalize property needs to be set before setting the buffer.\n\n    if (options.disableNormalization === nativeConvolverNode.normalize) {\n      nativeConvolverNode.normalize = !options.disableNormalization;\n    }\n\n    assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer'); // Bug #113: Edge & Safari allow to set the channelCount to a value larger than 2.\n\n    if (options.channelCount > 2) {\n      throw createNotSupportedError();\n    }\n\n    overwriteAccessors(nativeConvolverNode, 'channelCount', get => () => get.call(nativeConvolverNode), set => value => {\n      if (value > 2) {\n        throw createNotSupportedError();\n      }\n\n      return set.call(nativeConvolverNode, value);\n    }); // Bug #114: Edge & Safari allow to set the channelCountMode to 'max'.\n\n    if (options.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    overwriteAccessors(nativeConvolverNode, 'channelCountMode', get => () => get.call(nativeConvolverNode), set => value => {\n      if (value === 'max') {\n        throw createNotSupportedError();\n      }\n\n      return set.call(nativeConvolverNode, value);\n    });\n    return nativeConvolverNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConvolverNodeFakerFactory = (createNativeAudioNode, createNativeGainNode, monitorConnections) => {\n  return (nativeContext, {\n    buffer,\n    channelCount,\n    channelCountMode,\n    channelInterpretation,\n    disableNormalization\n  }) => {\n    const convolverNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createConvolver());\n    assignNativeAudioNodeOptions(convolverNode, {\n      // Bug #166: Opera does not allow yet to set the channelCount to 1.\n      channelCount: Math.max(channelCount, 2),\n      // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n      channelCountMode: channelCountMode === 'max' ? channelCountMode : 'clamped-max',\n      channelInterpretation\n    });\n    const gainNode = createNativeGainNode(nativeContext, {\n      channelCount,\n      channelCountMode,\n      channelInterpretation,\n      gain: 1\n    });\n    const nativeConvolverNodeFaker = {\n      get buffer() {\n        return convolverNode.buffer;\n      },\n\n      set buffer(value) {\n        convolverNode.buffer = value;\n      },\n\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        // Bug #166: Opera does not allow yet to set the channelCount to 1.\n        if (value > 2) {\n          convolverNode.channelCount = value;\n        }\n\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n        if (value === 'max') {\n          convolverNode.channelCountMode = value;\n        }\n\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return convolverNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        convolverNode.channelInterpretation = value;\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return convolverNode.context;\n      },\n\n      get inputs() {\n        return [convolverNode];\n      },\n\n      get numberOfInputs() {\n        return convolverNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return convolverNode.numberOfOutputs;\n      },\n\n      get normalize() {\n        return convolverNode.normalize;\n      },\n\n      set normalize(value) {\n        convolverNode.normalize = value;\n      },\n\n      addEventListener(...args) {\n        return convolverNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return convolverNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return convolverNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    }; // The normalize property needs to be set before setting the buffer.\n\n    if (disableNormalization === nativeConvolverNodeFaker.normalize) {\n      nativeConvolverNodeFaker.normalize = !disableNormalization;\n    }\n\n    if (buffer !== nativeConvolverNodeFaker.buffer) {\n      nativeConvolverNodeFaker.buffer = buffer;\n    }\n\n    const whenConnected = () => convolverNode.connect(gainNode);\n\n    const whenDisconnected = () => convolverNode.disconnect(gainNode);\n\n    return monitorConnections(interceptConnections(nativeConvolverNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeDelayNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createDelay(options.maxDelayTime));\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n    return nativeDelayNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n  return (nativeContext, options) => {\n    const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createDynamicsCompressor());\n    assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options); // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n\n    if (options.channelCount > 2) {\n      throw createNotSupportedError();\n    } // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n\n\n    if (options.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n    return nativeDynamicsCompressorNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeGainNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createGain());\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n    return nativeGainNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n  return (nativeContext, baseLatency, options) => {\n    // Bug #9: Safari does not support IIRFilterNodes.\n    if (nativeContext.createIIRFilter === undefined) {\n      return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n    }\n\n    const nativeIIRFilterNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n    });\n    assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n    return nativeIIRFilterNode;\n  };\n};","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\n\nfunction divide(a, b) {\n  const denominator = b[0] * b[0] + b[1] * b[1];\n  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a, b) {\n  return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient, z) {\n  let result = [0, 0];\n\n  for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n    result = multiply(result, z);\n    result[0] += coefficient[i];\n  }\n\n  return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n  return (nativeContext, baseLatency, {\n    channelCount,\n    channelCountMode,\n    channelInterpretation,\n    feedback,\n    feedforward\n  }) => {\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (feedback.length === 0 || feedback.length > 20) {\n      throw createNotSupportedError();\n    }\n\n    if (feedback[0] === 0) {\n      throw createInvalidStateError();\n    }\n\n    if (feedforward.length === 0 || feedforward.length > 20) {\n      throw createNotSupportedError();\n    }\n\n    if (feedforward[0] === 0) {\n      throw createInvalidStateError();\n    }\n\n    if (feedback[0] !== 1) {\n      for (let i = 0; i < feedforwardLength; i += 1) {\n        feedforward[i] /= feedback[0];\n      }\n\n      for (let i = 1; i < feedbackLength; i += 1) {\n        feedback[i] /= feedback[0];\n      }\n    }\n\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n    scriptProcessorNode.channelCount = channelCount;\n    scriptProcessorNode.channelCountMode = channelCountMode;\n    scriptProcessorNode.channelInterpretation = channelInterpretation;\n    const bufferLength = 32;\n    const bufferIndexes = [];\n    const xBuffers = [];\n    const yBuffers = [];\n\n    for (let i = 0; i < channelCount; i += 1) {\n      bufferIndexes.push(0);\n      const xBuffer = new Float32Array(bufferLength);\n      const yBuffer = new Float32Array(bufferLength);\n      xBuffer.fill(0);\n      yBuffer.fill(0);\n      xBuffers.push(xBuffer);\n      yBuffers.push(yBuffer);\n    }\n\n    scriptProcessorNode.onaudioprocess = event => {\n      const inputBuffer = event.inputBuffer;\n      const outputBuffer = event.outputBuffer;\n      const numberOfChannels = inputBuffer.numberOfChannels;\n\n      for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = inputBuffer.getChannelData(i);\n        const output = outputBuffer.getChannelData(i);\n        bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n      }\n    };\n\n    const nyquist = nativeContext.sampleRate / 2;\n    const nativeIIRFilterNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return scriptProcessorNode.channelCount;\n      },\n\n      set channelCount(value) {\n        scriptProcessorNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return scriptProcessorNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        scriptProcessorNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return scriptProcessorNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        scriptProcessorNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return [scriptProcessorNode];\n      },\n\n      get numberOfInputs() {\n        return scriptProcessorNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return scriptProcessorNode.numberOfOutputs;\n      },\n\n      addEventListener(...args) {\n        // @todo Dissallow adding an audioprocess listener.\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n\n      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n          throw createInvalidAccessError();\n        }\n\n        const length = frequencyHz.length;\n\n        for (let i = 0; i < length; i += 1) {\n          const omega = -Math.PI * (frequencyHz[i] / nyquist);\n          const z = [Math.cos(omega), Math.sin(omega)];\n          const numerator = evaluatePolynomial(feedforward, z);\n          const denominator = evaluatePolynomial(feedback, z);\n          const response = divide(numerator, denominator);\n          magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n          phaseResponse[i] = Math.atan2(response[1], response[0]);\n        }\n      },\n\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n  };\n};","export const createNativeMediaElementAudioSourceNodeFactory = createNativeAudioNode => {\n  return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n    return ntvDCntxt.createMediaElementSource(options.mediaElement);\n  });\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeMediaStreamAudioDestinationNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n  return (nativeAudioContext, options) => {\n    // Bug #64: Edge does not support MediaStreamAudioDestinationNodes.\n    if (nativeAudioContext.createMediaStreamDestination === undefined) {\n      throw createNotSupportedError();\n    }\n\n    const nativeMediaStreamAudioDestinationNode = createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n      return ntvDCntxt.createMediaStreamDestination();\n    });\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options); // Bug #174: Safari does expose a wrong numberOfOutputs.\n\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n      Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', {\n        get: () => 0\n      });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n  };\n};","export const createNativeMediaStreamAudioSourceNodeFactory = createNativeAudioNode => {\n  return (nativeAudioContext, {\n    mediaStream\n  }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n      /*\n       * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n       * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n       */\n      const filteredAudioStreamTracks = audioStreamTracks.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0).slice(0, 1);\n      return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n    }); // Bug #63: Edge does not expose the mediaStream yet.\n\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', {\n      value: mediaStream\n    });\n    return nativeMediaStreamAudioSourceNode;\n  };\n};","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext) => {\n  return (nativeAudioContext, {\n    mediaStreamTrack\n  }) => {\n    if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n      return createNativeAudioNode(nativeAudioContext, ntvDCntxt => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n    } // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n\n\n    return createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n      const mediaStream = new MediaStream([mediaStreamTrack]);\n      const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream); // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n\n      if (mediaStreamTrack.kind !== 'audio') {\n        throw createInvalidStateError();\n      } // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n\n\n      if (isNativeOfflineAudioContext(ntvDCntxt)) {\n        throw new TypeError();\n      }\n\n      return nativeMediaStreamAudioSourceNode;\n    });\n  };\n};","export const createNativeOfflineAudioContextConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  if (window.hasOwnProperty('OfflineAudioContext')) {\n    return window.OfflineAudioContext;\n  }\n\n  return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n  return (nativeContext, options) => {\n    const nativeOscillatorNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createOscillator());\n    assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n    if (options.periodicWave !== undefined) {\n      nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n    } else {\n      assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n    } // Bug #44: Only Chrome & Opera throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n    } // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n    } // Bug #44: Only Firefox does not throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n    } // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n\n\n    addSilentConnection(nativeContext, nativeOscillatorNode);\n    return nativeOscillatorNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n  return (nativeContext, options) => {\n    const nativePannerNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createPanner()); // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n\n    if (nativePannerNode.orientationX === undefined) {\n      return createNativePannerNodeFaker(nativeContext, options);\n    }\n\n    assignNativeAudioNodeOptions(nativePannerNode, options);\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n    return nativePannerNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections) => {\n  return (nativeContext, {\n    coneInnerAngle,\n    coneOuterAngle,\n    coneOuterGain,\n    distanceModel,\n    maxDistance,\n    orientationX,\n    orientationY,\n    orientationZ,\n    panningModel,\n    positionX,\n    positionY,\n    positionZ,\n    refDistance,\n    rolloffFactor,\n    ...audioNodeOptions\n  }) => {\n    const pannerNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createPanner()); // Bug #125: Safari does not throw an error yet.\n\n    if (audioNodeOptions.channelCount > 2) {\n      throw createNotSupportedError();\n    } // Bug #126: Safari does not throw an error yet.\n\n\n    if (audioNodeOptions.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n    const SINGLE_CHANNEL_OPTIONS = {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete'\n    };\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      channelInterpretation: 'speakers',\n      numberOfInputs: 6\n    });\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 1\n    });\n    const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n    const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      curve: new Float32Array([1, 1]),\n      oversample: 'none'\n    });\n    let lastOrientation = [orientationX, orientationY, orientationZ];\n    let lastPosition = [positionX, positionY, positionZ];\n\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer\n    }) => {\n      const orientation = [inputBuffer.getChannelData(0)[0], inputBuffer.getChannelData(1)[0], inputBuffer.getChannelData(2)[0]];\n\n      if (orientation.some((value, index) => value !== lastOrientation[index])) {\n        pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n        lastOrientation = orientation;\n      }\n\n      const positon = [inputBuffer.getChannelData(3)[0], inputBuffer.getChannelData(4)[0], inputBuffer.getChannelData(5)[0]];\n\n      if (positon.some((value, index) => value !== lastPosition[index])) {\n        pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n        lastPosition = positon;\n      }\n    };\n\n    Object.defineProperty(orientationYGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(orientationZGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionXGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionYGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionZGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    const nativePannerNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return pannerNode.channelCount;\n      },\n\n      set channelCount(value) {\n        // Bug #125: Safari does not throw an error yet.\n        if (value > 2) {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCount = value;\n        pannerNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return pannerNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        // Bug #126: Safari does not throw an error yet.\n        if (value === 'max') {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCountMode = value;\n        pannerNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return pannerNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        pannerNode.channelInterpretation = value;\n      },\n\n      get coneInnerAngle() {\n        return pannerNode.coneInnerAngle;\n      },\n\n      set coneInnerAngle(value) {\n        pannerNode.coneInnerAngle = value;\n      },\n\n      get coneOuterAngle() {\n        return pannerNode.coneOuterAngle;\n      },\n\n      set coneOuterAngle(value) {\n        pannerNode.coneOuterAngle = value;\n      },\n\n      get coneOuterGain() {\n        return pannerNode.coneOuterGain;\n      },\n\n      set coneOuterGain(value) {\n        // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n        if (value < 0 || value > 1) {\n          throw createInvalidStateError();\n        }\n\n        pannerNode.coneOuterGain = value;\n      },\n\n      get context() {\n        return pannerNode.context;\n      },\n\n      get distanceModel() {\n        return pannerNode.distanceModel;\n      },\n\n      set distanceModel(value) {\n        pannerNode.distanceModel = value;\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get maxDistance() {\n        return pannerNode.maxDistance;\n      },\n\n      set maxDistance(value) {\n        // Bug #128: Edge & Safari do not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.maxDistance = value;\n      },\n\n      get numberOfInputs() {\n        return pannerNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return pannerNode.numberOfOutputs;\n      },\n\n      get orientationX() {\n        return orientationXGainNode.gain;\n      },\n\n      get orientationY() {\n        return orientationYGainNode.gain;\n      },\n\n      get orientationZ() {\n        return orientationZGainNode.gain;\n      },\n\n      get panningModel() {\n        return pannerNode.panningModel;\n      },\n\n      set panningModel(value) {\n        pannerNode.panningModel = value; // Bug #123: Edge does not support HRTF as panningModel.\n\n        if (pannerNode.panningModel !== value && value === 'HRTF') {\n          throw createNotSupportedError();\n        }\n      },\n\n      get positionX() {\n        return positionXGainNode.gain;\n      },\n\n      get positionY() {\n        return positionYGainNode.gain;\n      },\n\n      get positionZ() {\n        return positionZGainNode.gain;\n      },\n\n      get refDistance() {\n        return pannerNode.refDistance;\n      },\n\n      set refDistance(value) {\n        // Bug #129: Edge & Safari do not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.refDistance = value;\n      },\n\n      get rolloffFactor() {\n        return pannerNode.rolloffFactor;\n      },\n\n      set rolloffFactor(value) {\n        // Bug #130: Edge & Safari do not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.rolloffFactor = value;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n\n    if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n      nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n    }\n\n    if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n      nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n    }\n\n    if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n      nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n    }\n\n    if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n      nativePannerNodeFaker.distanceModel = distanceModel;\n    }\n\n    if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n      nativePannerNodeFaker.maxDistance = maxDistance;\n    }\n\n    if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n      nativePannerNodeFaker.orientationX.value = orientationX;\n    }\n\n    if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n      nativePannerNodeFaker.orientationY.value = orientationY;\n    }\n\n    if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n      nativePannerNodeFaker.orientationZ.value = orientationZ;\n    }\n\n    if (panningModel !== nativePannerNodeFaker.panningModel) {\n      nativePannerNodeFaker.panningModel = panningModel;\n    }\n\n    if (positionX !== nativePannerNodeFaker.positionX.value) {\n      nativePannerNodeFaker.positionX.value = positionX;\n    }\n\n    if (positionY !== nativePannerNodeFaker.positionY.value) {\n      nativePannerNodeFaker.positionY.value = positionY;\n    }\n\n    if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n      nativePannerNodeFaker.positionZ.value = positionZ;\n    }\n\n    if (refDistance !== nativePannerNodeFaker.refDistance) {\n      nativePannerNodeFaker.refDistance = refDistance;\n    }\n\n    if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n      nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n    }\n\n    if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n      pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n    }\n\n    if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n      pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n    }\n\n    const whenConnected = () => {\n      inputGainNode.connect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n      connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n      waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n      waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n      waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n      waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n      waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n      waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n      channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n    };\n\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n      disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n      waveShaperNode.disconnect(orientationXGainNode);\n      orientationXGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(orientationYGainNode);\n      orientationYGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(orientationZGainNode);\n      orientationZGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionXGainNode);\n      positionXGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionYGainNode);\n      positionYGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionZGainNode);\n      positionZGainNode.disconnect(channelMergerNode);\n      channelMergerNode.disconnect(scriptProcessorNode);\n      scriptProcessorNode.disconnect(nativeContext.destination);\n    };\n\n    return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n  };\n};","export const createNativePeriodicWaveFactory = getBackupNativeContext => {\n  return (nativeContext, {\n    disableNormalization,\n    imag,\n    real\n  }) => {\n    // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n    const backupNativeContext = getBackupNativeContext(nativeContext); // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n\n    const wrappedImag = new Float32Array(imag);\n    const wrappedReal = new Float32Array(real);\n\n    if (backupNativeContext !== null) {\n      return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, {\n        disableNormalization\n      });\n    }\n\n    return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, {\n      disableNormalization\n    });\n  };\n};","export const createNativeScriptProcessorNodeFactory = createNativeAudioNode => {\n  return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n    return createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n    });\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n  return (nativeContext, options) => createNativeAudioNode(nativeContext, ntvCntxt => {\n    const channelCountMode = options.channelCountMode;\n    /*\n     * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n     * which supports it and therefore it can't be supported at all.\n     */\n\n    if (channelCountMode === 'clamped-max') {\n      throw createNotSupportedError();\n    } // Bug #105: Safari does not support the StereoPannerNode.\n\n\n    if (nativeContext.createStereoPanner === undefined) {\n      return createNativeStereoPannerNodeFaker(nativeContext, options);\n    }\n\n    const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n    assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n    /*\n     * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n     * which supports it and therefore it can't be supported at all.\n     */\n\n    Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n      get: () => channelCountMode,\n      set: value => {\n        if (value !== channelCountMode) {\n          throw createNotSupportedError();\n        }\n      }\n    });\n    return nativeStereoPannerNode;\n  });\n};","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n  // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n  const CURVE_SIZE = 16385;\n  const DC_CURVE = new Float32Array([1, 1]);\n  const HALF_PI = Math.PI / 2;\n  const SINGLE_CHANNEL_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete'\n  };\n  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS,\n    oversample: 'none'\n  };\n\n  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      const x = i / (CURVE_SIZE - 1) * HALF_PI;\n      leftWaveShaperCurve[i] = Math.cos(x);\n      rightWaveShaperCurve[i] = Math.sin(x);\n    }\n\n    const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftWaveShaperCurve\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n      },\n\n      disconnectGraph() {\n        inputGainNode.disconnect(leftGainNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n        inputGainNode.disconnect(rightGainNode);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.disconnect(leftGainNode.gain);\n        rightWaveShaperNode.disconnect(rightGainNode.gain);\n        leftGainNode.disconnect(channelMergerNode, 0, 0);\n        rightGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n\n    };\n  };\n\n  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      if (i > centerIndex) {\n        const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n        rightInputForLeftOutputWaveShaperCurve[i] = 0;\n        rightInputForRightOutputWaveShaperCurve[i] = 1;\n      } else {\n        const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = 1;\n        leftInputForRightOutputWaveShaperCurve[i] = 0;\n        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n      }\n    }\n\n    const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 2\n    });\n    const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForLeftOutputWaveShaperCurve\n    });\n    const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForRightOutputWaveShaperCurve\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForLeftOutputWaveShaperCurve\n    });\n    const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForRightOutputWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n      },\n\n      disconnectGraph() {\n        inputGainNode.disconnect(channelSplitterNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n\n    };\n  };\n\n  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n    if (channelCount === 1) {\n      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n\n    if (channelCount === 2) {\n      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n\n    throw createNotSupportedError();\n  };\n\n  return (nativeContext, {\n    channelCount,\n    channelCountMode,\n    pan,\n    ...audioNodeOptions\n  }) => {\n    if (channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...audioNodeOptions,\n      channelCount: 1,\n      channelCountMode,\n      numberOfInputs: 2\n    });\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      channelCount,\n      channelCountMode,\n      gain: 1\n    });\n    const panGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: pan\n    });\n    let {\n      connectGraph,\n      disconnectGraph\n    } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n    Object.defineProperty(panGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    const nativeStereoPannerNodeFakerFactory = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return inputGainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        if (inputGainNode.channelCount !== value) {\n          if (isConnected) {\n            disconnectGraph();\n          }\n\n          ({\n            connectGraph,\n            disconnectGraph\n          } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n\n          if (isConnected) {\n            connectGraph();\n          }\n        }\n\n        inputGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return inputGainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        if (value === 'clamped-max' || value === 'max') {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return inputGainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return inputGainNode.context;\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return inputGainNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return inputGainNode.numberOfOutputs;\n      },\n\n      get pan() {\n        return panGainNode.gain;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    let isConnected = false;\n\n    const whenConnected = () => {\n      connectGraph();\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      disconnectGraph();\n      isConnected = false;\n    };\n\n    return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n\n    try {\n      // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n      // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n      nativeWaveShaperNode.curve = new Float32Array([1]);\n      return createNativeWaveShaperNodeFaker(nativeContext, options);\n    } catch {\n      /* Ignore errors. */\n    }\n\n    assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n    const curve = options.curve; // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n\n    if (curve !== null && curve.length < 2) {\n      throw createInvalidStateError();\n    }\n\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {\n      set.call(nativeWaveShaperNode, value);\n\n      if (isConnected) {\n        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n          disconnectNativeAudioBufferSourceNode();\n          disconnectNativeAudioBufferSourceNode = null;\n        }\n      }\n\n      return value;\n    });\n\n    const whenConnected = () => {\n      isConnected = true;\n\n      if (isDCCurve(nativeWaveShaperNode.curve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections) => {\n  return (nativeContext, {\n    curve,\n    oversample,\n    ...audioNodeOptions\n  }) => {\n    const negativeWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n    const positiveWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: -1\n    });\n    const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: -1\n    });\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    let unmodifiedCurve = null;\n    const nativeWaveShaperNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return negativeWaveShaperNode.channelCount;\n      },\n\n      set channelCount(value) {\n        inputGainNode.channelCount = value;\n        invertGainNode.channelCount = value;\n        negativeWaveShaperNode.channelCount = value;\n        outputGainNode.channelCount = value;\n        positiveWaveShaperNode.channelCount = value;\n        revertGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return negativeWaveShaperNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        inputGainNode.channelCountMode = value;\n        invertGainNode.channelCountMode = value;\n        negativeWaveShaperNode.channelCountMode = value;\n        outputGainNode.channelCountMode = value;\n        positiveWaveShaperNode.channelCountMode = value;\n        revertGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return negativeWaveShaperNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        invertGainNode.channelInterpretation = value;\n        negativeWaveShaperNode.channelInterpretation = value;\n        outputGainNode.channelInterpretation = value;\n        positiveWaveShaperNode.channelInterpretation = value;\n        revertGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return negativeWaveShaperNode.context;\n      },\n\n      get curve() {\n        return unmodifiedCurve;\n      },\n\n      set curve(value) {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        if (value === null) {\n          negativeWaveShaperNode.curve = value;\n          positiveWaveShaperNode.curve = value;\n        } else {\n          const curveLength = value.length;\n          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          negativeCurve[0] = value[0];\n          positiveCurve[0] = -value[curveLength - 1];\n          const length = Math.ceil((curveLength + 1) / 2);\n          const centerIndex = (curveLength + 1) / 2 - 1;\n\n          for (let i = 1; i < length; i += 1) {\n            const theoreticIndex = i / length * centerIndex;\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n          }\n\n          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n          negativeWaveShaperNode.curve = negativeCurve;\n          positiveWaveShaperNode.curve = positiveCurve;\n        }\n\n        unmodifiedCurve = value;\n\n        if (isConnected) {\n          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          } else if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        }\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return negativeWaveShaperNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return negativeWaveShaperNode.numberOfOutputs;\n      },\n\n      get oversample() {\n        return negativeWaveShaperNode.oversample;\n      },\n\n      set oversample(value) {\n        negativeWaveShaperNode.oversample = value;\n        positiveWaveShaperNode.oversample = value;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n\n    if (curve !== nativeWaveShaperNodeFaker.curve) {\n      nativeWaveShaperNodeFaker.curve = curve;\n    }\n\n    if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n      nativeWaveShaperNodeFaker.oversample = oversample;\n    }\n\n    const whenConnected = () => {\n      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n      isConnected = true;\n\n      if (isDCCurve(unmodifiedCurve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(negativeWaveShaperNode);\n      negativeWaveShaperNode.disconnect(outputGainNode);\n      inputGainNode.disconnect(invertGainNode);\n      invertGainNode.disconnect(positiveWaveShaperNode);\n      positiveWaveShaperNode.disconnect(revertGainNode);\n      revertGainNode.disconnect(outputGainNode);\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n  };\n};","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n  return class OfflineAudioContext extends baseAudioContextConstructor {\n    constructor(a, b, c) {\n      let options;\n\n      if (typeof a === 'number' && b !== undefined && c !== undefined) {\n        options = {\n          length: b,\n          numberOfChannels: a,\n          sampleRate: c\n        };\n      } else if (typeof a === 'object') {\n        options = a;\n      } else {\n        throw new Error('The given parameters are not valid.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).then(audioBuffer => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        return audioBuffer;\n      }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n      .catch(err => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        throw err;\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","import { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  detune: 0,\n  frequency: 440,\n  type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class OscillatorNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer() : null;\n      const nyquist = context.sampleRate / 2;\n      super(context, false, nativeOscillatorNode, oscillatorNodeRenderer); // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n\n      this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600); // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n      this._nativeOscillatorNode = nativeOscillatorNode;\n      this._onended = null;\n      this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n      if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n        this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;\n      }\n    }\n\n    get detune() {\n      return this._detune;\n    }\n\n    get frequency() {\n      return this._frequency;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeOscillatorNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeOscillatorNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    get type() {\n      return this._nativeOscillatorNode.type;\n    }\n\n    set type(value) {\n      this._nativeOscillatorNode.type = value; // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n\n      if (value === 'custom') {\n        throw createInvalidStateError();\n      }\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.periodicWave = null;\n      }\n    }\n\n    setPeriodicWave(periodicWave) {\n      this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.periodicWave = periodicWave;\n      }\n    }\n\n    start(when = 0) {\n      this._nativeOscillatorNode.start(when);\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.start = when;\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeOscillatorNode.stop(when);\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeOscillatorNodes = new WeakMap();\n    let periodicWave = null;\n    let start = null;\n    let stop = null;\n\n    const createOscillatorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeOscillatorNode = getNativeAudioNode(proxy); // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n      if (!nativeOscillatorNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeOscillatorNode.channelCount,\n          channelCountMode: nativeOscillatorNode.channelCountMode,\n          channelInterpretation: nativeOscillatorNode.channelInterpretation,\n          detune: nativeOscillatorNode.detune.value,\n          frequency: nativeOscillatorNode.frequency.value,\n          periodicWave: periodicWave === null ? undefined : periodicWave,\n          type: nativeOscillatorNode.type\n        };\n        nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n        if (start !== null) {\n          nativeOscillatorNode.start(start);\n        }\n\n        if (stop !== null) {\n          nativeOscillatorNode.stop(stop);\n        }\n      }\n\n      renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n      if (!nativeOscillatorNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode, trace);\n      return nativeOscillatorNode;\n    };\n\n    return {\n      set periodicWave(value) {\n        periodicWave = value;\n      },\n\n      set start(value) {\n        start = value;\n      },\n\n      set stop(value) {\n        stop = value;\n      },\n\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeOscillatorNode !== undefined) {\n          return Promise.resolve(renderedNativeOscillatorNode);\n        }\n\n        return createOscillatorNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'clamped-max',\n  channelInterpretation: 'speakers',\n  coneInnerAngle: 360,\n  coneOuterAngle: 360,\n  coneOuterGain: 0,\n  distanceModel: 'inverse',\n  maxDistance: 10000,\n  orientationX: 1,\n  orientationY: 0,\n  orientationZ: 0,\n  panningModel: 'equalpower',\n  positionX: 0,\n  positionY: 0,\n  positionZ: 0,\n  refDistance: 1,\n  rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class PannerNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const pannerNodeRenderer = isOffline ? createPannerNodeRenderer() : null;\n      super(context, false, nativePannerNode, pannerNodeRenderer);\n      this._nativePannerNode = nativePannerNode; // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n\n      this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get coneInnerAngle() {\n      return this._nativePannerNode.coneInnerAngle;\n    }\n\n    set coneInnerAngle(value) {\n      this._nativePannerNode.coneInnerAngle = value;\n    }\n\n    get coneOuterAngle() {\n      return this._nativePannerNode.coneOuterAngle;\n    }\n\n    set coneOuterAngle(value) {\n      this._nativePannerNode.coneOuterAngle = value;\n    }\n\n    get coneOuterGain() {\n      return this._nativePannerNode.coneOuterGain;\n    }\n\n    set coneOuterGain(value) {\n      this._nativePannerNode.coneOuterGain = value;\n    }\n\n    get distanceModel() {\n      return this._nativePannerNode.distanceModel;\n    }\n\n    set distanceModel(value) {\n      this._nativePannerNode.distanceModel = value;\n    }\n\n    get maxDistance() {\n      return this._nativePannerNode.maxDistance;\n    }\n\n    set maxDistance(value) {\n      this._nativePannerNode.maxDistance = value;\n    }\n\n    get orientationX() {\n      return this._orientationX;\n    }\n\n    get orientationY() {\n      return this._orientationY;\n    }\n\n    get orientationZ() {\n      return this._orientationZ;\n    }\n\n    get panningModel() {\n      return this._nativePannerNode.panningModel;\n    }\n\n    set panningModel(value) {\n      this._nativePannerNode.panningModel = value;\n    }\n\n    get positionX() {\n      return this._positionX;\n    }\n\n    get positionY() {\n      return this._positionY;\n    }\n\n    get positionZ() {\n      return this._positionZ;\n    }\n\n    get refDistance() {\n      return this._nativePannerNode.refDistance;\n    }\n\n    set refDistance(value) {\n      this._nativePannerNode.refDistance = value;\n    }\n\n    get rolloffFactor() {\n      return this._nativePannerNode.rolloffFactor;\n    }\n\n    set rolloffFactor(value) {\n      this._nativePannerNode.rolloffFactor = value;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let renderedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeGainNode = null;\n      let nativePannerNode = getNativeAudioNode(proxy);\n      const commonAudioNodeOptions = {\n        channelCount: nativePannerNode.channelCount,\n        channelCountMode: nativePannerNode.channelCountMode,\n        channelInterpretation: nativePannerNode.channelInterpretation\n      };\n      const commonNativePannerNodeOptions = { ...commonAudioNodeOptions,\n        coneInnerAngle: nativePannerNode.coneInnerAngle,\n        coneOuterAngle: nativePannerNode.coneOuterAngle,\n        coneOuterGain: nativePannerNode.coneOuterGain,\n        distanceModel: nativePannerNode.distanceModel,\n        maxDistance: nativePannerNode.maxDistance,\n        panningModel: nativePannerNode.panningModel,\n        refDistance: nativePannerNode.refDistance,\n        rolloffFactor: nativePannerNode.rolloffFactor\n      }; // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext); // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n\n      if ('bufferSize' in nativePannerNode) {\n        nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n          gain: 1\n        });\n      } else if (!nativePannerNodeIsOwnedByContext) {\n        const options = { ...commonNativePannerNodeOptions,\n          orientationX: nativePannerNode.orientationX.value,\n          orientationY: nativePannerNode.orientationY.value,\n          orientationZ: nativePannerNode.orientationZ.value,\n          positionX: nativePannerNode.positionX.value,\n          positionY: nativePannerNode.positionY.value,\n          positionZ: nativePannerNode.positionZ.value\n        };\n        nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n      if (nativeGainNode !== null) {\n        if (renderedBufferPromise === null) {\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n\n          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, // Bug #17: Safari does not yet expose the length.\n          proxy.context.length, nativeOfflineAudioContext.sampleRate);\n          const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n          });\n          nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n          renderedBufferPromise = (async () => {\n            const nativeConstantSourceNodes = await Promise.all([proxy.orientationX, proxy.orientationY, proxy.orientationZ, proxy.positionX, proxy.positionY, proxy.positionZ].map(async (audioParam, index) => {\n              const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: index === 0 ? 1 : 0\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset, trace);\n              return nativeConstantSourceNode;\n            }));\n\n            for (let i = 0; i < 6; i += 1) {\n              nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n              nativeConstantSourceNodes[i].start(0);\n            }\n\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          })();\n        }\n\n        const renderedBuffer = await renderedBufferPromise;\n        const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n          gain: 1\n        });\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode, trace);\n        const channelDatas = [];\n\n        for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n          channelDatas.push(renderedBuffer.getChannelData(i));\n        }\n\n        let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n        let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n        let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n          gain: 1\n        });\n        let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,\n          orientationX: lastOrientation[0],\n          orientationY: lastOrientation[1],\n          orientationZ: lastOrientation[2],\n          positionX: lastPosition[0],\n          positionY: lastPosition[1],\n          positionZ: lastPosition[2]\n        });\n        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n        partialPannerNode.connect(nativeGainNode);\n\n        for (let i = 128; i < renderedBuffer.length; i += 128) {\n          const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n          const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n          if (orientation.some((value, index) => value !== lastOrientation[index]) || positon.some((value, index) => value !== lastPosition[index])) {\n            lastOrientation = orientation;\n            lastPosition = positon;\n            const currentTime = i / nativeOfflineAudioContext.sampleRate;\n            gateGainNode.gain.setValueAtTime(0, currentTime);\n            gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n              gain: 0\n            });\n            partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,\n              orientationX: lastOrientation[0],\n              orientationY: lastOrientation[1],\n              orientationZ: lastOrientation[2],\n              positionX: lastPosition[0],\n              positionY: lastPosition[1],\n              positionZ: lastPosition[2]\n            });\n            gateGainNode.gain.setValueAtTime(1, currentTime);\n            inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n            partialPannerNode.connect(nativeGainNode);\n          }\n        }\n\n        return nativeGainNode;\n      }\n\n      if (!nativePannerNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n      }\n\n      if (isNativeAudioNodeFaker(nativePannerNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n      }\n\n      return nativePannerNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n          return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","const DEFAULT_OPTIONS = {\n  disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore) => {\n  return class PeriodicWave {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n      periodicWaveStore.add(periodicWave); // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n\n      return periodicWave;\n    }\n\n    static [Symbol.hasInstance](instance) {\n      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);\n    }\n\n  };\n};","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n  return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n    const audioParamRenderer = getAudioParamRenderer(audioParam);\n    audioParamRenderer.replay(nativeAudioParam);\n    return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n  };\n};","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    const nextTrace = [...trace, audioNode];\n    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).filter(([source]) => !nextTrace.includes(source)).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n      const destination = audioNode.context.destination;\n\n      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n  return async (audioParam, nativeOfflineAudioContext, nativeAudioParam, trace) => {\n    const audioParamConnections = getAudioParamConnections(audioParam);\n    await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, trace);\n\n      if (!isPartOfACycle(source)) {\n        renderedNativeAudioNode.connect(nativeAudioParam, output);\n      }\n    }));\n  };\n};","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n  return nativeOfflineAudioContext => {\n    // Bug #21: Safari does not support promises yet.\n    if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n      // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n      return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then(isOfflineAudioContextCurrentTimeSupported => {\n        if (!isOfflineAudioContextCurrentTimeSupported) {\n          const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n          nativeOfflineAudioContext.oncomplete = () => {\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            scriptProcessorNode.disconnect();\n          };\n\n          scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n\n          scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n        }\n\n        return nativeOfflineAudioContext.startRendering();\n      });\n    }\n\n    return new Promise(resolve => {\n      // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n      const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        gain: 0\n      });\n\n      nativeOfflineAudioContext.oncomplete = event => {\n        gainNode.disconnect();\n        resolve(event.renderedBuffer);\n      };\n\n      gainNode.connect(nativeOfflineAudioContext.destination);\n      nativeOfflineAudioContext.startRendering();\n    });\n  };\n};","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  const trace = [];\n  return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext, trace)\n  /*\n   * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n   * destination.\n   */\n  .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(audioWorkletNode => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace)))).then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext)).then(audioBuffer => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n    if (typeof audioBuffer.copyFromChannel !== 'function') {\n      wrapAudioBufferCopyChannelMethods(audioBuffer);\n      wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n    } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n      wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n    }\n\n    audioBufferStore.add(audioBuffer);\n    return audioBuffer;\n  });\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n\n  /*\n   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n   * behavior.\n   */\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  pan: 0\n};\nexport const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class StereoPannerNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer() : null;\n      super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer); // Bug #106: Edge does not export a maxValue and minValue property.\n\n      this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n    }\n\n    get pan() {\n      return this._pan;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeStereoPannerNodes = new WeakMap();\n\n    const createStereoPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeStereoPannerNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n      if (!nativeStereoPannerNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeStereoPannerNode.channelCount,\n          channelCountMode: nativeStereoPannerNode.channelCountMode,\n          channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n          pan: nativeStereoPannerNode.pan.value\n        };\n        nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n      if (!nativeStereoPannerNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n      }\n\n      if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode, trace);\n      }\n\n      return nativeStereoPannerNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeStereoPannerNode !== undefined) {\n          return Promise.resolve(renderedNativeStereoPannerNode);\n        }\n\n        return createStereoPannerNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = nativeAudioBufferConstructor => {\n  return () => {\n    if (nativeAudioBufferConstructor === null) {\n      return false;\n    }\n\n    try {\n      new nativeAudioBufferConstructor({\n        length: 1,\n        sampleRate: 44100\n      }); // tslint:disable-line:no-unused-expression\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","/*\n * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n * is enough to know if the other one is supported as well.\n */\nexport const createTestAudioBufferCopyChannelMethodsSubarraySupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    if (nativeAudioBuffer.copyToChannel === undefined) {\n      return true;\n    }\n\n    const source = new Float32Array(2);\n\n    try {\n      nativeAudioBuffer.copyFromChannel(source, 0, 0);\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    nativeAudioBufferSourceNode.start();\n\n    try {\n      nativeAudioBufferSourceNode.start();\n    } catch {\n      return true;\n    }\n\n    return false;\n  };\n};","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n    const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n    audioBuffer.getChannelData(0)[0] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.start(0, 0, 0);\n    audioBufferSourceNode.connect(offlineAudioContext.destination); // Bug #21: Safari does not support promises yet.\n\n    return new Promise(resolve => {\n      offlineAudioContext.oncomplete = ({\n        renderedBuffer\n      }) => {\n        // Bug #5: Safari does not support copyFromChannel().\n        resolve(renderedBuffer.getChannelData(0)[0] === 0);\n      };\n\n      offlineAudioContext.startRendering();\n    });\n  };\n};","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n      nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    nativeAudioBufferSourceNode.start();\n\n    try {\n      nativeAudioBufferSourceNode.stop();\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestAudioContextCloseMethodSupport = nativeAudioContextConstructor => {\n  return () => {\n    if (nativeAudioContextConstructor === null) {\n      return false;\n    } // Try to check the prototype before constructing the AudioContext.\n\n\n    if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n      return true;\n    }\n\n    const audioContext = new nativeAudioContextConstructor();\n    const isAudioContextClosable = audioContext.close !== undefined;\n\n    try {\n      audioContext.close();\n    } catch {// Ignore errors.\n    }\n\n    return isAudioContextClosable;\n  };\n};","/**\n * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n * did not refuse to decode invalid parameters with a TypeError.\n */\nexport const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #21: Safari does not support promises yet.\n\n    return new Promise(resolve => {\n      let isPending = true;\n\n      const resolvePromise = err => {\n        if (isPending) {\n          isPending = false;\n          offlineAudioContext.startRendering();\n          resolve(err instanceof TypeError);\n        }\n      };\n\n      let promise; // Bug #26: Safari throws a synchronous error.\n\n      try {\n        promise = offlineAudioContext // Bug #1: Safari requires a successCallback.\n        .decodeAudioData(null, () => {// Ignore the success callback.\n        }, resolvePromise);\n      } catch (err) {\n        resolvePromise(err);\n      } // Bug #21: Safari does not support promises yet.\n\n\n      if (promise !== undefined) {\n        // Bug #6 Chrome does not call the errorCallback\n        promise.catch(resolvePromise);\n      }\n    });\n  };\n};","export const createTestAudioContextOptionsSupport = nativeAudioContextConstructor => {\n  return () => {\n    if (nativeAudioContextConstructor === null) {\n      return false;\n    }\n\n    let audioContext;\n\n    try {\n      audioContext = new nativeAudioContextConstructor({\n        latencyHint: 'balanced'\n      });\n    } catch {\n      return false;\n    }\n\n    audioContext.close();\n    return true;\n  };\n};","// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\nexport const createTestAudioNodeConnectMethodSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeGainNode = nativeOfflineAudioContext.createGain();\n    const isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n    nativeGainNode.disconnect(nativeGainNode);\n    return isSupported;\n  };\n};","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createOscillator());\n\n    try {\n      nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n      return err instanceof RangeError;\n    }\n\n    return false;\n  };\n};","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n      nativeAudioBufferSourceNode.stop();\n      return true;\n    } catch {\n      return false;\n    }\n  };\n};","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createOscillator());\n\n    try {\n      nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n      return err instanceof RangeError;\n    }\n\n    return false;\n  };\n};","/**\n * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n * enabled by default in version 66.\n */\nexport const createTestAudioWorkletProcessorNoOutputsSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n  return async () => {\n    // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n    if (nativeAudioWorkletNodeConstructor === null) {\n      return true;\n    }\n\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const blob = new Blob(['class A extends AudioWorkletProcessor{process(){this.port.postMessage(0)}}registerProcessor(\"a\",A)'], {\n      type: 'application/javascript; charset=utf-8'\n    });\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 3200);\n    const url = URL.createObjectURL(blob);\n    let isCallingProcess = false;\n\n    try {\n      await offlineAudioContext.audioWorklet.addModule(url);\n      const gainNode = offlineAudioContext.createGain();\n      const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {\n        numberOfOutputs: 0\n      });\n\n      audioWorkletNode.port.onmessage = () => isCallingProcess = true;\n\n      gainNode.connect(audioWorkletNode);\n      await offlineAudioContext.startRendering();\n    } catch {// Ignore errors.\n    } finally {\n      URL.revokeObjectURL(url);\n    }\n\n    return isCallingProcess;\n  };\n};","/**\n * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n */\nexport const createTestChannelMergerNodeChannelCountSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeChannelMergerNode = createNativeAudioNode(offlineAudioContext, ntvCntxt => ntvCntxt.createChannelMerger());\n\n    try {\n      nativeChannelMergerNode.channelCount = 2;\n    } catch {\n      return true;\n    }\n\n    return false;\n  };\n};","export const createTestConstantSourceNodeAccurateSchedulingSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n\n    if (nativeOfflineAudioContext.createConstantSource === undefined) {\n      return true;\n    }\n\n    const nativeConstantSourceNode = createNativeAudioNode(nativeOfflineAudioContext, ntvCntxt => ntvCntxt.createConstantSource());\n    /*\n     * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n     * the implementation of Firefox right now, but it could probably be done in a better way.\n     */\n\n    return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n  };\n};","// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\nexport const createTestConvolverNodeBufferReassignabilitySupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeConvolverNode = offlineAudioContext.createConvolver();\n    nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n\n    try {\n      nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestIsSecureContextSupport = window => {\n  return () => window !== null && window.hasOwnProperty('isSecureContext');\n};","// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\nexport const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = nativeAudioContextConstructor => {\n  return () => {\n    if (nativeAudioContextConstructor === null) {\n      return false;\n    }\n\n    const audioContext = new nativeAudioContextConstructor();\n\n    try {\n      audioContext.createMediaStreamSource(new MediaStream());\n      return false;\n    } catch (err) {\n      return true;\n    }\n  };\n};","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n\n    const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    }); // Bug #21: Safari does not support promises yet.\n\n    return new Promise(resolve => {\n      nativeOfflineAudioContext.oncomplete = () => {\n        gainNode.disconnect();\n        resolve(nativeOfflineAudioContext.currentTime !== 0);\n      };\n\n      nativeOfflineAudioContext.startRendering();\n    });\n  };\n};","/**\n * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n */\nexport const createTestStereoPannerNodeDefaultValueSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    /*\n     * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n     * support the tested behaviour.\n     */\n\n    if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n      return Promise.resolve(true);\n    } // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n\n\n    if (nativeOfflineAudioContext.createConstantSource === undefined) {\n      return Promise.resolve(true);\n    }\n\n    const constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n    const stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n    constantSourceNode.channelCount = 1;\n    constantSourceNode.offset.value = 1;\n    stereoPanner.channelCount = 1;\n    constantSourceNode.start();\n    constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n    return nativeOfflineAudioContext.startRendering().then(buffer => buffer.getChannelData(0)[0] !== 1);\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  curve: null,\n  oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class WaveShaperNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer() : null; // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n\n      super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n      this._isCurveNullified = false;\n      this._nativeWaveShaperNode = nativeWaveShaperNode;\n    }\n\n    get curve() {\n      if (this._isCurveNullified) {\n        return null;\n      }\n\n      return this._nativeWaveShaperNode.curve;\n    }\n\n    set curve(value) {\n      // Bug #103: Safari does not allow to set the curve to null.\n      if (value === null) {\n        this._isCurveNullified = true;\n        this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n      } else {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (value.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        this._isCurveNullified = false;\n        this._nativeWaveShaperNode.curve = value;\n      }\n    }\n\n    get oversample() {\n      return this._nativeWaveShaperNode.oversample;\n    }\n\n    set oversample(value) {\n      this._nativeWaveShaperNode.oversample = value;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeWaveShaperNodes = new WeakMap();\n\n    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeWaveShaperNode = getNativeAudioNode(proxy); // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n      if (!nativeWaveShaperNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeWaveShaperNode.channelCount,\n          channelCountMode: nativeWaveShaperNode.channelCountMode,\n          channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n          curve: nativeWaveShaperNode.curve,\n          oversample: nativeWaveShaperNode.oversample\n        };\n        nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n      if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode, trace);\n      }\n\n      return nativeWaveShaperNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeWaveShaperNode !== undefined) {\n          return Promise.resolve(renderedNativeWaveShaperNode);\n        }\n\n        return createWaveShaperNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createWindow = () => typeof window === 'undefined' ? null : window;","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const destinationLength = destination.length;\n\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n        destination[i] = channelData[i + bufferOffset];\n      }\n    };\n\n    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const sourceLength = source.length;\n\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n        channelData[i + bufferOffset] = source[i];\n      }\n    };\n  };\n};","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = convertNumberToUnsignedLong => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = (copyFromChannel => {\n      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyFromChannel);\n\n    audioBuffer.copyToChannel = (copyToChannel => {\n      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyToChannel);\n  };\n};","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = overwriteAccessors => {\n  return (nativeAudioBufferSourceNode, nativeContext) => {\n    const nullifiedBuffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n\n    if (nativeAudioBufferSourceNode.buffer === null) {\n      nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n    }\n\n    overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', get => () => {\n      const value = get.call(nativeAudioBufferSourceNode);\n      return value === nullifiedBuffer ? null : value;\n    }, set => value => {\n      return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n    });\n  };\n};","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createNativeAudioNode => {\n  return (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createGain());\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = (disconnect => {\n      return () => {\n        // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n        disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n      };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = (stop => {\n      let isStopped = false;\n      return (when = 0) => {\n        if (isStopped) {\n          try {\n            stop.call(nativeAudioScheduledSourceNode, when);\n          } catch {\n            nativeGainNode.gain.setValueAtTime(0, when);\n          }\n        } else {\n          stop.call(nativeAudioScheduledSourceNode, when);\n          isStopped = true;\n        }\n      };\n    })(nativeAudioScheduledSourceNode.stop);\n  };\n};","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode, monitorConnectionsFunction) => {\n  return (nativeContext, channelMergerNode) => {\n    channelMergerNode.channelCount = 1;\n    channelMergerNode.channelCountMode = 'explicit';\n    Object.defineProperty(channelMergerNode, 'channelCount', {\n      get: () => 1,\n      set: () => {\n        throw createInvalidStateError();\n      }\n    });\n    Object.defineProperty(channelMergerNode, 'channelCountMode', {\n      get: () => 'explicit',\n      set: () => {\n        throw createInvalidStateError();\n      }\n    }); // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n\n    const audioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n\n    const whenConnected = () => {\n      const length = channelMergerNode.numberOfInputs;\n\n      for (let i = 0; i < length; i += 1) {\n        audioBufferSourceNode.connect(channelMergerNode, 0, i);\n      }\n    };\n\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n    monitorConnectionsFunction(channelMergerNode, whenConnected, whenDisconnected);\n  };\n};","// Safari at version 11 did not support transferables.\nexport const testTransferablesSupport = () => new Promise(resolve => {\n  const arrayBuffer = new ArrayBuffer(0);\n  const {\n    port1,\n    port2\n  } = new MessageChannel();\n\n  port1.onmessage = ({\n    data\n  }) => resolve(data !== null);\n\n  port2.postMessage(arrayBuffer, [arrayBuffer]);\n});","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = nativeAudioBufferSourceNode => {\n  nativeAudioBufferSourceNode.start = (start => {\n    return (when = 0, offset = 0, duration) => {\n      const buffer = nativeAudioBufferSourceNode.buffer; // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n\n      const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset); // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n\n      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n        start.call(nativeAudioBufferSourceNode, when, 0, 0);\n      } else {\n        start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n      }\n    };\n  })(nativeAudioBufferSourceNode.start);\n};","export const isAudioWorkletNode = audioNode => {\n  return 'port' in audioNode;\n};","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n  const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n  if (!eventListeners.delete(eventListener)) {\n    throw new Error('Missing the expected event listener.');\n  }\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = audioNode => {\n  return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};","export const pickElementFromSet = (set, predicate) => {\n  const matchingElements = Array.from(set).filter(predicate);\n\n  if (matchingElements.length > 1) {\n    throw Error('More than one element was found.');\n  }\n\n  if (matchingElements.length === 0) {\n    throw Error('No element was found.');\n  }\n\n  const [matchingElement] = matchingElements;\n  set.delete(matchingElement);\n  return matchingElement;\n};","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive'; // Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\n\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n  if (!isAudioWorkletNode(audioNode) && activeInputs.every(connections => connections.size === 0)) {\n    setInternalStateToPassive(audioNode);\n  }\n};","export const testAudioNodeDisconnectMethodSupport = nativeAudioContext => {\n  return new Promise(resolve => {\n    const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n    const dummy = nativeAudioContext.createGain(); // Bug #95: Safari does not play one sample buffers.\n\n    const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n    const channelData = ones.getChannelData(0);\n    channelData[0] = 1;\n    channelData[1] = 1;\n    const source = nativeAudioContext.createBufferSource();\n    source.buffer = ones;\n    source.loop = true;\n    source.connect(analyzer).connect(nativeAudioContext.destination);\n    source.connect(dummy);\n    source.disconnect(dummy);\n\n    analyzer.onaudioprocess = event => {\n      const chnnlDt = event.inputBuffer.getChannelData(0);\n\n      if (Array.prototype.some.call(chnnlDt, sample => sample === 1)) {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n\n      source.stop();\n      analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n      source.disconnect(analyzer);\n      analyzer.disconnect(nativeAudioContext.destination);\n    };\n\n    source.start();\n  });\n};","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n  const counts = new Map();\n\n  for (const cycle of cycles) {\n    for (const audioNode of cycle) {\n      const count = counts.get(audioNode);\n      counts.set(audioNode, count === undefined ? 1 : count + 1);\n    }\n  }\n\n  counts.forEach((count, audioNode) => visitor(audioNode, count));\n};","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n\n  nativeAudioNode.connect = (connect => {\n    return (destination, output = 0, input = 0) => {\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output); // Save the new connection only if the calls to connect above didn't throw an error.\n\n      const connectionsToDestination = connections.get(destination);\n\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const [destination, connectionsToDestination] of connections) {\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n\n      for (const [destination, connectionsToDestination] of connections) {\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\n\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n  insertElementInSet(activeInputs[input], [source, output, eventListener], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n  insertElementInSet(activeInputs, [source, output, eventListener], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n  return pickElementFromSet(activeInputs[input], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n  return pickElementFromSet(activeInputs, activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n  const passiveInputConnections = passiveInputs.get(source);\n\n  if (passiveInputConnections === undefined) {\n    passiveInputs.set(source, new Set([[output, input, eventListener]]));\n  } else {\n    insertElementInSet(passiveInputConnections, [output, input, eventListener], passiveInputConnection => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n  }\n};\n\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n  const passiveInputConnections = passiveInputs.get(source);\n\n  if (passiveInputConnections === undefined) {\n    passiveInputs.set(source, new Set([[output, eventListener]]));\n  } else {\n    insertElementInSet(passiveInputConnections, [output, eventListener], passiveInputConnection => passiveInputConnection[0] === output, ignoreDuplicates);\n  }\n};\n\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n  const passiveInputConnections = getValueForKey(passiveInputs, source);\n  const matchingConnection = pickElementFromSet(passiveInputConnections, passiveInputConnection => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n\n  if (passiveInputConnections.size === 0) {\n    passiveInputs.delete(source);\n  }\n\n  return matchingConnection;\n};\n\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n  const passiveInputConnections = getValueForKey(passiveInputs, source);\n  const matchingConnection = pickElementFromSet(passiveInputConnections, passiveInputConnection => passiveInputConnection[0] === output);\n\n  if (passiveInputConnections.size === 0) {\n    passiveInputs.delete(source);\n  }\n\n  return matchingConnection;\n};\n\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n\n  const eventListener = isActive => {\n    const nativeDestinationAudioNode = getNativeAudioNode(destination);\n    const nativeSourceAudioNode = getNativeAudioNode(source);\n\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n      addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n      }\n\n      if (isPassiveAudioNode(destination)) {\n        setInternalStateToActive(destination);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n      addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n      }\n\n      if (isActiveAudioNode(destination)) {\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output, input], outputConnection => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n\n  if (insertElementInSet(outputs, [destination, output, input], outputConnection => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n    return true;\n  }\n\n  return false;\n};\n\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n\n  const eventListener = isActive => {\n    const nativeAudioNode = getNativeAudioNode(source);\n    const nativeAudioParam = getNativeAudioParam(destination);\n\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    const {\n      activeInputs\n    } = getAudioParamConnections(destination);\n    addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n    return true;\n  }\n\n  return false;\n};\n\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n  for (const activeInputConnection of activeInputConnections) {\n    if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n      activeInputConnections.delete(activeInputConnection);\n      return activeInputConnection;\n    }\n  }\n\n  return null;\n};\n\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n\n  if (isActiveAudioNode(destination)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\n\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\n\nconst deleteAnyConnection = source => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, ...outputConnection);\n    }\n\n    destinations.push(outputConnection[0]);\n  }\n\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\n\nconst deleteConnectionAtOutput = (source, output) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (outputConnection[1] === output) {\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode(source, ...outputConnection);\n      } else {\n        deleteInputsOfAudioParam(source, ...outputConnection);\n      }\n\n      destinations.push(outputConnection[0]);\n      audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    }\n  }\n\n  return destinations;\n};\n\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection => outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input)).map(outputConnection => {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, ...outputConnection);\n    }\n\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\n\nexport const createAudioNodeConstructor = (addAudioNodeConnections, auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n  return class AudioNode extends eventTargetConstructor {\n    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      super(nativeAudioNode);\n      this._context = context;\n      this._nativeAudioNode = nativeAudioNode;\n      const nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.\n\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n        return testAudioNodeDisconnectMethodSupport(nativeContext);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n\n      AUDIO_NODE_STORE.set(this, nativeAudioNode);\n      EVENT_LISTENERS.set(this, new Set());\n\n      if (isActive) {\n        setInternalStateToActive(this);\n      }\n\n      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n    }\n\n    get channelCount() {\n      return this._nativeAudioNode.channelCount;\n    }\n\n    set channelCount(value) {\n      this._nativeAudioNode.channelCount = value;\n    }\n\n    get channelCountMode() {\n      return this._nativeAudioNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      this._nativeAudioNode.channelCountMode = value;\n    }\n\n    get channelInterpretation() {\n      return this._nativeAudioNode.channelInterpretation;\n    }\n\n    set channelInterpretation(value) {\n      this._nativeAudioNode.channelInterpretation = value;\n    }\n\n    get context() {\n      return this._context;\n    }\n\n    get numberOfInputs() {\n      return this._nativeAudioNode.numberOfInputs;\n    }\n\n    get numberOfOutputs() {\n      return this._nativeAudioNode.numberOfOutputs;\n    }\n\n    connect(destination, output = 0, input = 0) {\n      // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n      if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n        throw createInvalidAccessError();\n      }\n\n      if (isAudioNode(destination)) {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n        try {\n          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n\n          if (isOffline || isPassiveAudioNode(this)) {\n            this._nativeAudioNode.disconnect(...connection);\n          } else if (isPassiveAudioNode(destination)) {\n            setInternalStateToActive(destination);\n          } // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n          // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n\n\n          if (isAudioWorkletNode(destination)) {\n            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeDestinationAudioNode);\n\n            if (auxiliaryGainNodes === undefined) {\n              const nativeGainNode = nativeContext.createGain();\n              nativeGainNode.connect(connection[0], 0, connection[2]);\n              auxiliaryGainNodeStore.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n            } else if (auxiliaryGainNodes.get(input) === undefined) {\n              const nativeGainNode = nativeContext.createGain();\n              nativeGainNode.connect(connection[0], 0, connection[2]);\n              auxiliaryGainNodes.set(input, nativeGainNode);\n            }\n          }\n        } catch (err) {\n          // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n\n          throw err;\n        }\n\n        const isNewConnectionToAudioNode = isOffline ? addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input) : addConnectionToAudioNodeOfAudioContext(this, destination, output, input); // Bug #164: Only Firefox detects cycles so far.\n\n        if (isNewConnectionToAudioNode) {\n          const cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n        }\n\n        return destination;\n      }\n\n      const nativeAudioParam = getNativeAudioParam(destination);\n      /*\n       * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n       * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n       * Safari.\n       */\n\n      if (nativeAudioParam.name === 'playbackRate') {\n        throw createNotSupportedError();\n      }\n\n      try {\n        this._nativeAudioNode.connect(nativeAudioParam, output);\n\n        if (isOffline || isPassiveAudioNode(this)) {\n          this._nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n      } catch (err) {\n        // Bug #58: Only Firefox does throw an InvalidStateError yet.\n        if (err.code === 12) {\n          throw createInvalidAccessError();\n        }\n\n        throw err;\n      }\n\n      const isNewConnectionToAudioParam = isOffline ? addConnectionToAudioParamOfOfflineAudioContext(this, destination, output) : addConnectionToAudioParamOfAudioContext(this, destination, output); // Bug #164: Only Firefox detects cycles so far.\n\n      if (isNewConnectionToAudioParam) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n      }\n    }\n\n    disconnect(destinationOrOutput, output, input) {\n      let destinations;\n\n      if (destinationOrOutput === undefined) {\n        destinations = deleteAnyConnection(this);\n      } else if (typeof destinationOrOutput === 'number') {\n        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionAtOutput(this, destinationOrOutput);\n      } else {\n        if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n          throw createIndexSizeError();\n        }\n\n        if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionToDestination(this, destinationOrOutput, output, input);\n\n        if (destinations.length === 0) {\n          throw createInvalidAccessError();\n        }\n      } // Bug #164: Only Firefox detects cycles so far.\n\n\n      for (const destination of destinations) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n      }\n    }\n\n  };\n};","export const cloneAudioWorkletNodeOptions = audioWorkletNodeOptions => {\n  return new Promise((resolve, reject) => {\n    const {\n      port1,\n      port2\n    } = new MessageChannel();\n\n    port1.onmessage = ({\n      data\n    }) => {\n      port1.close();\n      port2.close();\n      resolve(data);\n    };\n\n    port1.onmessageerror = ({\n      data\n    }) => {\n      port1.close();\n      port2.close();\n      reject(data);\n    }; // This will throw an error if the audioWorkletNodeOptions are not clonable.\n\n\n    port2.postMessage(audioWorkletNodeOptions);\n  });\n};","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n  const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n  return new processorConstructor(clonedAudioWorkletNodeOptions);\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    if (options.outputChannelCount !== undefined) {\n      // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n      if (options.outputChannelCount.some(channelCount => channelCount < 1)) {\n        throw createNotSupportedError();\n      }\n\n      if (options.outputChannelCount.length !== options.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    const constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      for (const {\n        defaultValue,\n        maxValue,\n        minValue,\n        name\n      } of processorConstructor.parameterDescriptors) {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === undefined ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n\n    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: options.outputChannelCount[i]\n      }));\n    }\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(({\n      name\n    }, index) => {\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener(...args) {\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n\n    messageChannel.port1.addEventListener = (addEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = event => {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = (removeEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: () => onmessage,\n      set: value => {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, {\n      name\n    }) => ({ ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n    let isActive = true;\n\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n        for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n\n        outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n      }\n    };\n\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer,\n      outputBuffer\n    }) => {\n      if (audioWorkletProcessor !== null) {\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({\n              name\n            }, index) => {\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n\n              if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                return [];\n              }\n\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n\n              outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              error\n            }));\n          }\n\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              const length = processorConstructor.parameterDescriptors.length;\n\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n\n            break;\n          }\n        }\n      }\n    };\n\n    let isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n\n    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode)\n    /*\n     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is used here\n     * to make sure to connect the right destination.\n     */\n    .connect(nativeGainNode.context.destination);\n\n    const disconnectFakeGraph = () => {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    const whenConnected = () => {\n      if (isActive) {\n        disconnectFakeGraph();\n\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n  let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n  if (nodeToProcessorMap === undefined) {\n    nodeToProcessorMap = new WeakMap();\n    NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n  }\n\n  const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n  nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n  return audioWorkletProcessorPromise;\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n  return (nativeContext, options = {}) => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate'); // Bug #71: Edge does not allow to set the buffer to null.\n\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer'); // Bug #149: Safari does not yet support the detune AudioParam.\n\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart'); // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n    } // Bug #92: Chrome & Edge do not respect the duration parameter yet.\n\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n      wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n    } // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n    } // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n    } // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n    } // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n    } // Bug #44: Only Firefox does not throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n    } // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n    return nativeAudioBufferSourceNode;\n  };\n};","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = nativeAudioBufferSourceNode => {\n  nativeAudioBufferSourceNode.start = (start => {\n    let isScheduled = false;\n    return (when = 0, offset = 0, duration) => {\n      if (isScheduled) {\n        throw createInvalidStateError();\n      }\n\n      start.call(nativeAudioBufferSourceNode, when, offset, duration);\n      isScheduled = true;\n    };\n  })(nativeAudioBufferSourceNode.start);\n};","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n  let endTime = Number.POSITIVE_INFINITY;\n  let stopTime = Number.POSITIVE_INFINITY;\n\n  nativeAudioScheduledSourceNode.start = ((start, stop) => {\n    return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n      start.call(nativeAudioScheduledSourceNode, when, offset);\n\n      if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n        const actualStartTime = Math.max(when, nativeContext.currentTime); // @todo The playbackRate could of course also have been automated and is not always fixed.\n\n        const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n        endTime = actualStartTime + durationInBufferTime;\n        stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n      }\n    };\n  })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    return (when = 0) => {\n      stopTime = Math.max(when, nativeContext.currentTime);\n      stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","const handler = {\n  construct() {\n    return handler;\n  }\n\n};\nexport const isConstructible = constructible => {\n  try {\n    const proxy = new Proxy(constructible, handler);\n    new proxy(); // tslint:disable-line:no-unused-expression\n  } catch {\n    return false;\n  }\n\n  return true;\n};","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source, url) => {\n  const importStatements = [];\n  let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n  let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n  while (result !== null) {\n    const unresolvedUrl = result[1].slice(1, -1);\n    const importStatementWithResolvedUrl = result[0].replace(/([\\s]+)?;?$/, '').replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n    importStatements.push(importStatementWithResolvedUrl);\n    sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n    result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n  }\n\n  return [importStatements.join(';'), sourceWithoutImportStatements];\n};","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\n\nconst verifyParameterDescriptors = parameterDescriptors => {\n  if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n    throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n  }\n};\n\nconst verifyProcessorCtor = processorCtor => {\n  if (!isConstructible(processorCtor)) {\n    throw new TypeError('The given value for processorCtor should be a constructor.');\n  }\n\n  if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n    throw new TypeError('The given value for processorCtor should have a prototype.');\n  }\n};\n\nexport const createAddAudioWorkletModule = (createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests, window) => {\n  return (context, moduleURL, options = {\n    credentials: 'omit'\n  }) => {\n    const nativeContext = getNativeContext(context);\n    const absoluteUrl = new URL(moduleURL, window.location.href).toString(); // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n\n    if (nativeContext.audioWorklet !== undefined) {\n      return fetchSource(moduleURL).then(source => {\n        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n        /*\n         * Bug #170: Chrome and Opera do call process() with an array with empty channelData for each input if no input is\n         * connected.\n         *\n         * This is the unminified version of the code used below:\n         *\n         * ```js\n         * `${ importStatements };\n         * ((registerProcessor) => {${ sourceWithoutImportStatements }\n         * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n         *\n         *     process (inputs, outputs, parameters) {\n         *         return super.process(\n         *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n         *             outputs,\n         *             parameters\n         *         );\n         *     }\n         *\n         * }))`\n         * ```\n         */\n\n        const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`; // tslint:disable-line:max-line-length\n\n        const blob = new Blob([wrappedSource], {\n          type: 'application/javascript; charset=utf-8'\n        });\n        const url = URL.createObjectURL(blob);\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        const nativeContextOrBackupNativeContext = backupNativeContext !== null ? backupNativeContext : nativeContext;\n        return nativeContextOrBackupNativeContext.audioWorklet.addModule(url, options).then(() => URL.revokeObjectURL(url)) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n        .catch(err => {\n          URL.revokeObjectURL(url);\n\n          if (err.code === undefined || err.name === 'SyntaxError') {\n            err.code = 12;\n          }\n\n          throw err;\n        });\n      });\n    }\n\n    const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n    if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n      return Promise.resolve();\n    }\n\n    const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n    if (ongoingRequestsOfContext !== undefined) {\n      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n      if (promiseOfOngoingRequest !== undefined) {\n        return promiseOfOngoingRequest;\n      }\n    }\n\n    const promise = fetchSource(moduleURL).then(source => {\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * ${ importStatements };\n       * ((a, b) => {\n       *     (a[b] = a[b] || [ ]).push(\n       *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n       *             ${ sourceWithoutImportStatements }\n       *         }\n       *     );\n       * })(window, '_AWGS');\n       * ```\n       */\n      // tslint:disable-next-line:max-line-length\n\n      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`; // @todo Evaluating the given source code is a possible security problem.\n\n      return evaluateSource(wrappedSource);\n    }).then(() => {\n      const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n\n      if (evaluateAudioWorkletGlobalScope === undefined) {\n        throw new SyntaxError();\n      }\n\n      exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {}, undefined, (name, processorCtor) => {\n        if (name.trim() === '') {\n          throw createNotSupportedError();\n        }\n\n        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n        if (nodeNameToProcessorConstructorMap !== undefined) {\n          if (nodeNameToProcessorConstructorMap.has(name)) {\n            throw createNotSupportedError();\n          }\n\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n        } else {\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n        }\n      }, nativeContext.sampleRate, undefined, undefined));\n    }).catch(err => {\n      if (err.code === undefined || err.name === 'SyntaxError') {\n        err.code = 12;\n      }\n\n      throw err;\n    });\n\n    if (ongoingRequestsOfContext === undefined) {\n      ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n    } else {\n      ongoingRequestsOfContext.set(moduleURL, promise);\n    }\n\n    promise.then(() => {\n      const rslvdRqstsFCntxt = resolvedRequests.get(context);\n\n      if (rslvdRqstsFCntxt === undefined) {\n        resolvedRequests.set(context, new Set([moduleURL]));\n      } else {\n        rslvdRqstsFCntxt.add(moduleURL);\n      }\n    }).catch(() => {}) // tslint:disable-line:no-empty\n    // @todo Use finally when it becomes available in all supported browsers.\n    .then(() => {\n      const ngngRqstsFCntxt = ongoingRequests.get(context);\n\n      if (ngngRqstsFCntxt !== undefined) {\n        ngngRqstsFCntxt.delete(moduleURL);\n      }\n    });\n    return promise;\n  };\n};","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = nativeAnalyserNode => {\n  return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n  return (nativeContext, options) => {\n    const nativeAnalyserNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createAnalyser()); // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n\n    assignNativeAudioNodeOptions(nativeAnalyserNode, options); // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n\n    if (!(options.maxDecibels > options.minDecibels)) {\n      throw createIndexSizeError();\n    }\n\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant'); // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n\n    if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n      wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n    }\n\n    return nativeAnalyserNode;\n  };\n};","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = nativeAnalyserNode => {\n  nativeAnalyserNode.getFloatTimeDomainData = array => {\n    const byteTimeDomainData = new Uint8Array(array.length);\n    nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n    const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n    for (let i = 0; i < length; i += 1) {\n      array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n    }\n\n    return array;\n  };\n};","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = nativeIIRFilterNode => {\n  nativeIIRFilterNode.getFrequencyResponse = (getFrequencyResponse => {\n    return (frequencyHz, magResponse, phaseResponse) => {\n      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n        throw createInvalidAccessError();\n      }\n\n      return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n    };\n  })(nativeIIRFilterNode.getFrequencyResponse);\n};","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class IIRFilterNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n      const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null;\n      super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer); // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n      // @todo Write a test which allows other browsers to remain unpatched.\n\n      wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n      this._nativeIIRFilterNode = nativeIIRFilterNode;\n    }\n\n    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n      return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n    }\n\n  };\n};","export const isDelayNode = audioNode => {\n  return 'delayTime' in audioNode;\n};","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n  return function detectCycles(chain, nextLink) {\n    const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n\n    if (isDelayNode(audioNode)) {\n      return [];\n    }\n\n    if (chain[0] === audioNode) {\n      return [chain];\n    }\n\n    if (chain.includes(audioNode)) {\n      return [];\n    }\n\n    const {\n      outputs\n    } = getAudioNodeConnections(audioNode);\n    return Array.from(outputs).map(outputConnection => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n  };\n};","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  return (anyContext, audioData) => {\n    const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext); // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n\n    if (detachedArrayBuffers.has(audioData)) {\n      const err = createDataCloneError();\n      return Promise.reject(err);\n    } // The audioData parameter maybe of a type which can't be added to a WeakSet.\n\n\n    try {\n      detachedArrayBuffers.add(audioData);\n    } catch {} // Ignore errors.\n    // Bug #21: Safari does not support promises yet.\n\n\n    if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n      // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n      const nativeContextOrBackupNativeContext = nativeContext.state === 'closed' && nativeOfflineAudioContextConstructor !== null && isNativeOfflineAudioContext(nativeContext) ? new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) : nativeContext;\n      const promise = nativeContextOrBackupNativeContext.decodeAudioData(audioData).catch(err => {\n        // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n        if (err instanceof DOMException && err.name === 'NotSupportedError') {\n          throw new TypeError();\n        }\n\n        throw err;\n      });\n      return promise.then(audioBuffer => {\n        // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n          wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n      });\n    } // Bug #21: Safari does not return a Promise yet.\n\n\n    return new Promise((resolve, reject) => {\n      const complete = () => {\n        // Bug #133: Safari does neuter the ArrayBuffer.\n        try {\n          detachArrayBuffer(audioData);\n        } catch {\n          /* Ignore errors. */\n        }\n      };\n\n      const fail = err => {\n        reject(err);\n        complete();\n      }; // Bug #26: Safari throws a synchronous error.\n\n\n      try {\n        // Bug #1: Safari requires a successCallback.\n        nativeContext.decodeAudioData(audioData, audioBuffer => {\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n          }\n\n          audioBufferStore.add(audioBuffer);\n          complete();\n          resolve(audioBuffer);\n        }, err => {\n          // Bug #4: Safari returns null instead of an error.\n          if (err === null) {\n            fail(createEncodingError());\n          } else {\n            fail(err);\n          }\n        });\n      } catch (err) {\n        fail(err);\n      }\n    });\n  };\n};","export const detachArrayBuffer = arrayBuffer => {\n  const {\n    port1\n  } = new MessageChannel();\n  port1.postMessage(arrayBuffer, [arrayBuffer]);\n};","export const testClonabilityOfAudioWorkletNodeOptions = audioWorkletNodeOptions => {\n  const {\n    port1\n  } = new MessageChannel();\n\n  try {\n    // This will throw an error if the audioWorkletNodeOptions are not clonable.\n    port1.postMessage(audioWorkletNodeOptions);\n  } finally {\n    port1.close();\n  }\n};","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n  return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n    if (nativeAudioWorkletNodeConstructor !== null) {\n      try {\n        const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n          return new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n        });\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n\n        let onprocessorerror = null;\n        Object.defineProperties(nativeAudioWorkletNode, {\n          /*\n           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n           * browsers have no native implementation to achieve a consistent behavior.\n           */\n          channelCount: {\n            get: () => options.channelCount,\n            set: () => {\n              throw createInvalidStateError();\n            }\n          },\n          channelCountMode: {\n            get: () => 'explicit',\n            set: () => {\n              throw createInvalidStateError();\n            }\n          },\n          // Bug #156: Chrome & Opera do not yet fire an ErrorEvent.\n          onprocessorerror: {\n            get: () => onprocessorerror,\n            set: value => {\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n              }\n\n              onprocessorerror = typeof value === 'function' ? value : null;\n\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n              }\n            }\n          }\n        });\n\n        nativeAudioWorkletNode.addEventListener = (addEventListener => {\n          return (...args) => {\n            if (args[0] === 'processorerror') {\n              const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n              if (unpatchedEventListener !== null) {\n                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                if (patchedEventListener !== undefined) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = event => {\n                    unpatchedEventListener(new ErrorEvent(args[0], { ...event,\n                      error: new Error()\n                    }));\n                  };\n\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            }\n\n            return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        })(nativeAudioWorkletNode.addEventListener);\n\n        nativeAudioWorkletNode.removeEventListener = (removeEventListener => {\n          return (...args) => {\n            if (args[0] === 'processorerror') {\n              const patchedEventListener = patchedEventListeners.get(args[1]);\n\n              if (patchedEventListener !== undefined) {\n                patchedEventListeners.delete(args[1]);\n                args[1] = patchedEventListener;\n              }\n            }\n\n            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        })(nativeAudioWorkletNode.removeEventListener);\n        /*\n         * Bug #86: Chrome & Opera do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but has\n         * an output.\n         */\n\n\n        if (options.numberOfOutputs !== 0) {\n          const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n          });\n          nativeAudioWorkletNode.connect(nativeGainNode)\n          /*\n           * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n           * used here to make sure to connect the right destination.\n           */\n          .connect(nativeGainNode.context.destination);\n\n          const whenConnected = () => nativeGainNode.disconnect();\n          /*\n           * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n           * used here to make sure to connect the right destination.\n           */\n\n\n          const whenDisconnected = () => nativeGainNode.connect(nativeGainNode.context.destination); // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n\n\n          return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n        }\n\n        return nativeAudioWorkletNode;\n      } catch (err) {\n        // Bug #60: Chrome & Opera throw an InvalidStateError instead of a NotSupportedError.\n        if (err.code === 11) {\n          throw createNotSupportedError();\n        }\n\n        throw err;\n      }\n    } // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n\n    if (processorConstructor === undefined) {\n      throw createNotSupportedError();\n    }\n\n    testClonabilityOfAudioWorkletNodeOptions(options);\n    return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n  };\n};","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({\n        name\n      }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n        }\n      }\n\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        error\n      }));\n      break;\n    }\n  }\n\n  return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: options.outputChannelCount[i]\n          }));\n        }\n\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          } // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n\n\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n\n        return outputGainNode;\n      }\n\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n      return nativeAudioWorkletNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n  const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n  const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n  return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = channelSplitterNode => {\n  const channelCount = channelSplitterNode.numberOfOutputs; // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n\n  Object.defineProperty(channelSplitterNode, 'channelCount', {\n    get: () => channelCount,\n    set: value => {\n      if (value !== channelCount) {\n        throw createInvalidStateError();\n      }\n    }\n  });\n  /*\n   * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n   * explicit.\n   */\n\n  Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n    get: () => 'explicit',\n    set: value => {\n      if (value !== 'explicit') {\n        throw createInvalidStateError();\n      }\n    }\n  });\n  /*\n   * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n   * discrete.\n   */\n\n  Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n    get: () => 'discrete',\n    set: value => {\n      if (value !== 'discrete') {\n        throw createInvalidStateError();\n      }\n    }\n  });\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n    }); // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Edge & Safari do not have the correct channelCountMode.\n    // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options); // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n    return nativeChannelSplitterNode;\n  };\n};","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement, error) {\n  if (!statement) {\n    throw new Error(error);\n  }\n}\n/**\n * Make sure that the given value is within the range\n */\n\nexport function assertRange(value, gte, lte = Infinity) {\n  if (!(gte <= value && value <= lte)) {\n    throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n  }\n}\n/**\n * Make sure that the given value is within the range\n */\n\nexport function assertContextRunning(context) {\n  // add a warning if the context is not started\n  if (!context.isOffline && context.state !== \"running\") {\n    warn(\"The AudioContext is \\\"suspended\\\". Invoke Tone.start() from a user action to start the audio.\");\n  }\n}\n/**\n * The default logger is the console\n */\n\nlet defaultLogger = console;\n/**\n * Set the logging interface\n */\n\nexport function setLogger(logger) {\n  defaultLogger = logger;\n}\n/**\n * Log anything\n */\n\nexport function log(...args) {\n  defaultLogger.log(...args);\n}\n/**\n * Warn anything\n */\n\nexport function warn(...args) {\n  defaultLogger.warn(...args);\n}","/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg) {\n  return typeof arg === \"undefined\";\n}\n/**\n * Test if the arg is not undefined\n */\n\nexport function isDefined(arg) {\n  return !isUndef(arg);\n}\n/**\n * Test if the arg is a function\n */\n\nexport function isFunction(arg) {\n  return typeof arg === \"function\";\n}\n/**\n * Test if the argument is a number.\n */\n\nexport function isNumber(arg) {\n  return typeof arg === \"number\";\n}\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\n\nexport function isObject(arg) {\n  return Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object;\n}\n/**\n * Test if the argument is a boolean.\n */\n\nexport function isBoolean(arg) {\n  return typeof arg === \"boolean\";\n}\n/**\n * Test if the argument is an Array\n */\n\nexport function isArray(arg) {\n  return Array.isArray(arg);\n}\n/**\n * Test if the argument is a string.\n */\n\nexport function isString(arg) {\n  return typeof arg === \"string\";\n}\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\n\nexport function isNote(arg) {\n  return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}","import { AudioContext as stdAudioContext, AudioWorkletNode as stdAudioWorkletNode, OfflineAudioContext as stdOfflineAudioContext } from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n/**\n * Create a new AudioContext\n */\n\nexport function createAudioContext() {\n  return new stdAudioContext();\n}\n/**\n * Create a new OfflineAudioContext\n */\n\nexport function createOfflineAudioContext(channels, length, sampleRate) {\n  return new stdOfflineAudioContext(channels, length, sampleRate);\n}\n/**\n * A reference to the window object\n * @hidden\n */\n\nexport const theWindow = typeof self === \"object\" ? self : null;\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\n\nexport const hasAudioContext = theWindow && (theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\nexport function createAudioWorkletNode(context, name, options) {\n  assert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\"); // @ts-ignore\n\n  return new stdAudioWorkletNode(context, name, options);\n}\n/**\n * This promise resolves to a boolean which indicates if the\n * functionality is supported within the currently used browse.\n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\n\nexport { isSupported as supported } from \"standardized-audio-context\";","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nexport var __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\nexport function __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nexport function __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nexport function __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nexport function __exportStar(m, exports) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n;\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n}\n;\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result.default = mod;\n  return result;\n}\nexport function __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    default: mod\n  };\n}\nexport function __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n}","/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval) {\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval; // create the clock source for the first time\n\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n\n\n  _createWorker() {\n    const blob = new Blob([\n    /* javascript */\n    `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n\n\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n\n\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n\n\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = 0;\n    }\n\n    if (this._worker) {\n      this._worker.terminate();\n\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n\n\n  get updateInterval() {\n    return this._updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._updateInterval = Math.max(interval, 128 / 44100);\n\n    if (this._type === \"worker\") {\n      this._worker.postMessage(Math.max(interval * 1000, 1));\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._disposeClock();\n\n    this._type = type;\n\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    this._disposeClock();\n  }\n\n}","import { isAnyAudioContext, isAnyAudioNode, isAnyAudioParam, isAnyOfflineAudioContext } from \"standardized-audio-context\";\n/**\n * Test if the given value is an instanceof AudioParam\n */\n\nexport function isAudioParam(arg) {\n  return isAnyAudioParam(arg);\n}\n/**\n * Test if the given value is an instanceof AudioNode\n */\n\nexport function isAudioNode(arg) {\n  return isAnyAudioNode(arg);\n}\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\n\nexport function isOfflineAudioContext(arg) {\n  return isAnyOfflineAudioContext(arg);\n}\n/**\n * Test if the arg is an instanceof AudioContext\n */\n\nexport function isAudioContext(arg) {\n  return isAnyAudioContext(arg);\n}\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\n\nexport function isAudioBuffer(arg) {\n  return arg instanceof AudioBuffer;\n}","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\n\nfunction noCopy(key, arg) {\n  return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\nexport function deepMerge(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (noCopy(key, source[key])) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  } // @ts-ignore\n\n\n  return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\n\nexport function deepEquals(arrayA, arrayB) {\n  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\n\nexport function optionsFromArguments(defaults, argsArray, keys = [], objKey) {\n  const opts = {};\n  const args = Array.from(argsArray); // if the first argument is an object and has an object key\n\n  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n    // if it's not part of the defaults\n    const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\n    if (!partOfDefaults) {\n      // merge that key\n      deepMerge(opts, {\n        [objKey]: args[0]\n      }); // remove the obj key from the keys\n\n      keys.splice(keys.indexOf(objKey), 1); // shift the first argument off\n\n      args.shift();\n    }\n  }\n\n  if (args.length === 1 && isObject(args[0])) {\n    deepMerge(opts, args[0]);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      if (isDefined(args[i])) {\n        opts[keys[i]] = args[i];\n      }\n    }\n  }\n\n  return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\n\nexport function getDefaultsFromInstance(instance) {\n  return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\n\nexport function defaultArg(given, fallback) {\n  if (isUndef(given)) {\n    return fallback;\n  } else {\n    return given;\n  }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\n\nexport function omitFromObject(obj, omit) {\n  omit.forEach(prop => {\n    if (Reflect.has(obj, prop)) {\n      delete obj[prop];\n    }\n  });\n  return obj;\n}","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { log } from \"./util/Debug\";\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\n\nexport class Tone {\n  constructor() {\n    //-------------------------------------\n    // \tDEBUGGING\n    //-------------------------------------\n\n    /**\n     * Set this debug flag to log all events that happen in this class.\n     */\n    this.debug = false; //-------------------------------------\n    // \tDISPOSING\n    //-------------------------------------\n\n    /**\n     * Indicates if the instance was disposed\n     */\n\n    this._wasDisposed = false;\n  }\n  /**\n   * Returns all of the default options belonging to the class.\n   */\n\n\n  static getDefaults() {\n    return {};\n  }\n  /**\n   * Prints the outputs to the console log for debugging purposes.\n   * Prints the contents only if either the object has a property\n   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n   * is set to the name of the class.\n   * @example\n   * const osc = new Tone.Oscillator();\n   * // prints all logs originating from this oscillator\n   * osc.debug = true;\n   * // calls to start/stop will print in the console\n   * osc.start();\n   */\n\n\n  log(...args) {\n    // if the object is either set to debug = true\n    // or if there is a string on the Tone.global.with the class name\n    if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {\n      log(this, ...args);\n    }\n  }\n  /**\n   * disconnect and dispose.\n   */\n\n\n  dispose() {\n    this._wasDisposed = true;\n    return this;\n  }\n  /**\n   * Indicates if the instance was disposed. 'Disposing' an\n   * instance means that all of the Web Audio nodes that were\n   * created for the instance are disconnected and freed for garbage collection.\n   */\n\n\n  get disposed() {\n    return this._wasDisposed;\n  }\n  /**\n   * Convert the class to a string\n   * @example\n   * const osc = new Tone.Oscillator();\n   * console.log(osc.toString());\n   */\n\n\n  toString() {\n    return this.name;\n  }\n\n}\n/**\n * The version number semver\n */\n\nTone.version = version;","export const version = \"14.6.8\";","/**\n * The threshold for correctness for operators. Less than one sample even\n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n/**\n * Test if A is greater than B\n */\n\nexport function GT(a, b) {\n  return a > b + EPSILON;\n}\n/**\n * Test if A is greater than or equal to B\n */\n\nexport function GTE(a, b) {\n  return GT(a, b) || EQ(a, b);\n}\n/**\n * Test if A is less than B\n */\n\nexport function LT(a, b) {\n  return a + EPSILON < b;\n}\n/**\n * Test if A is less than B\n */\n\nexport function EQ(a, b) {\n  return Math.abs(a - b) < EPSILON;\n}\n/**\n * Clamp the value within the given range\n */\n\nexport function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n}","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\n\nexport class Timeline extends Tone {\n  constructor() {\n    super();\n    this.name = \"Timeline\";\n    /**\n     * The array of scheduled timeline events\n     */\n\n    this._timeline = [];\n    const options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n    this.memory = options.memory;\n    this.increasing = options.increasing;\n  }\n\n  static getDefaults() {\n    return {\n      memory: Infinity,\n      increasing: false\n    };\n  }\n  /**\n   * The number of items in the timeline.\n   */\n\n\n  get length() {\n    return this._timeline.length;\n  }\n  /**\n   * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n   * @param event  The event object to insert into the timeline.\n   */\n\n\n  add(event) {\n    // the event needs to have a time attribute\n    assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n    event.time = event.time.valueOf();\n\n    if (this.increasing && this.length) {\n      const lastValue = this._timeline[this.length - 1];\n      assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\n      this._timeline.push(event);\n    } else {\n      const index = this._search(event.time);\n\n      this._timeline.splice(index + 1, 0, event);\n    } // if the length is more than the memory, remove the previous ones\n\n\n    if (this.length > this.memory) {\n      const diff = this.length - this.memory;\n\n      this._timeline.splice(0, diff);\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  {Object}  event  The event object to remove from the list.\n   * @returns {Timeline} this\n   */\n\n\n  remove(event) {\n    const index = this._timeline.indexOf(event);\n\n    if (index !== -1) {\n      this._timeline.splice(index, 1);\n    }\n\n    return this;\n  }\n  /**\n   * Get the nearest event whose time is less than or equal to the given time.\n   * @param  time  The time to query.\n   */\n\n\n  get(time, param = \"time\") {\n    const index = this._search(time, param);\n\n    if (index !== -1) {\n      return this._timeline[index];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Return the first event in the timeline without removing it\n   * @returns {Object} The first event object\n   */\n\n\n  peek() {\n    return this._timeline[0];\n  }\n  /**\n   * Return the first event in the timeline and remove it\n   */\n\n\n  shift() {\n    return this._timeline.shift();\n  }\n  /**\n   * Get the event which is scheduled after the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getAfter(time, param = \"time\") {\n    const index = this._search(time, param);\n\n    if (index + 1 < this._timeline.length) {\n      return this._timeline[index + 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the event before the event at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getBefore(time) {\n    const len = this._timeline.length; // if it's after the last item, return the last item\n\n    if (len > 0 && this._timeline[len - 1].time < time) {\n      return this._timeline[len - 1];\n    }\n\n    const index = this._search(time);\n\n    if (index - 1 >= 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Cancel events at and after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    if (this._timeline.length > 1) {\n      let index = this._search(after);\n\n      if (index >= 0) {\n        if (EQ(this._timeline[index].time, after)) {\n          // get the first item with that time\n          for (let i = index; i >= 0; i--) {\n            if (EQ(this._timeline[i].time, after)) {\n              index = i;\n            } else {\n              break;\n            }\n          }\n\n          this._timeline = this._timeline.slice(0, index);\n        } else {\n          this._timeline = this._timeline.slice(0, index + 1);\n        }\n      } else {\n        this._timeline = [];\n      }\n    } else if (this._timeline.length === 1) {\n      // the first item's time\n      if (GTE(this._timeline[0].time, after)) {\n        this._timeline = [];\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Cancel events before or equal to the given time.\n   * @param  time  The time to cancel before.\n   */\n\n\n  cancelBefore(time) {\n    const index = this._search(time);\n\n    if (index >= 0) {\n      this._timeline = this._timeline.slice(index + 1);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the previous event if there is one. null otherwise\n   * @param  event The event to find the previous one of\n   * @return The event right before the given event\n   */\n\n\n  previousEvent(event) {\n    const index = this._timeline.indexOf(event);\n\n    if (index > 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Does a binary search on the timeline array and returns the\n   * nearest event index whose time is after or equal to the given time.\n   * If a time is searched before the first index in the timeline, -1 is returned.\n   * If the time is after the end, the index of the last item is returned.\n   */\n\n\n  _search(time, param = \"time\") {\n    if (this._timeline.length === 0) {\n      return -1;\n    }\n\n    let beginning = 0;\n    const len = this._timeline.length;\n    let end = len;\n\n    if (len > 0 && this._timeline[len - 1][param] <= time) {\n      return len - 1;\n    }\n\n    while (beginning < end) {\n      // calculate the midpoint for roughly equal partition\n      let midPoint = Math.floor(beginning + (end - beginning) / 2);\n      const event = this._timeline[midPoint];\n      const nextEvent = this._timeline[midPoint + 1];\n\n      if (EQ(event[param], time)) {\n        // choose the last one that has the same time\n        for (let i = midPoint; i < this._timeline.length; i++) {\n          const testEvent = this._timeline[i];\n\n          if (EQ(testEvent[param], time)) {\n            midPoint = i;\n          } else {\n            break;\n          }\n        }\n\n        return midPoint;\n      } else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n        return midPoint;\n      } else if (GT(event[param], time)) {\n        // search lower\n        end = midPoint;\n      } else {\n        // search upper\n        beginning = midPoint + 1;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Internal iterator. Applies extra safety checks for\n   * removing items from the array.\n   */\n\n\n  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {\n    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n  }\n  /**\n   * Iterate over everything in the array\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    this._iterate(callback);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or before the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachBefore(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array after the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAfter(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const lowerBound = this._search(time);\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array between the startTime and endTime.\n   * The timerange is inclusive of the startTime, but exclusive of the endTime.\n   * range = [startTime, endTime).\n   * @param  startTime The time to check if items are before\n   * @param  endTime The end of the test interval.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachBetween(startTime, endTime, callback) {\n    let lowerBound = this._search(startTime);\n\n    let upperBound = this._search(endTime);\n\n    if (lowerBound !== -1 && upperBound !== -1) {\n      if (this._timeline[lowerBound].time !== startTime) {\n        lowerBound += 1;\n      } // exclusive of the end time\n\n\n      if (this._timeline[upperBound].time === endTime) {\n        upperBound -= 1;\n      }\n\n      this._iterate(callback, lowerBound, upperBound);\n    } else if (lowerBound === -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or after the given time. Similar to\n   * forEachAfter, but includes the item(s) at the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    let lowerBound = this._search(time); // work backwards until the event time is less than time\n\n\n    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n      lowerBound--;\n    }\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at the given time\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n\n    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n      let lowerBound = upperBound;\n\n      for (let i = upperBound; i >= 0; i--) {\n        if (EQ(this._timeline[i].time, time)) {\n          lowerBound = i;\n        } else {\n          break;\n        }\n      }\n\n      this._iterate(event => {\n        callback(event);\n      }, lowerBound, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._timeline = [];\n    return this;\n  }\n\n}","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext = [];\n/**\n * Used internally to setup a new Context\n */\n\nexport function onContextInit(cb) {\n  notifyNewContext.push(cb);\n}\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\n\nexport function initializeContext(ctx) {\n  // add any additional modules\n  notifyNewContext.forEach(cb => cb(ctx));\n}\n/**\n * Array of callbacks to invoke when a new context is created\n */\n\nconst notifyCloseContext = [];\n/**\n * Used internally to tear down a Context\n */\n\nexport function onContextClose(cb) {\n  notifyCloseContext.push(cb);\n}\nexport function closeContext(ctx) {\n  // add any additional modules\n  notifyCloseContext.forEach(cb => cb(ctx));\n}","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\n\nexport class Emitter extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"Emitter\";\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  on(event, callback) {\n    // split the event\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n\n      if (!this._events.hasOwnProperty(eventName)) {\n        this._events[eventName] = [];\n      }\n\n      this._events[eventName].push(callback);\n    });\n    return this;\n  }\n  /**\n   * Bind a callback which is only invoked once\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  once(event, callback) {\n    const boundCallback = (...args) => {\n      // invoke the callback\n      callback(...args); // remove the event\n\n      this.off(event, boundCallback);\n    };\n\n    this.on(event, boundCallback);\n    return this;\n  }\n  /**\n   * Remove the event listener.\n   * @param  event     The event to stop listening to.\n   * @param  callback  The callback which was bound to the event with Emitter.on.\n   *                   If no callback is given, all callbacks events are removed.\n   */\n\n\n  off(event, callback) {\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n\n      if (this._events.hasOwnProperty(event)) {\n        if (isUndef(callback)) {\n          this._events[event] = [];\n        } else {\n          const eventList = this._events[event];\n\n          for (let i = 0; i < eventList.length; i++) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Invoke all of the callbacks bound to the event\n   * with any arguments passed in.\n   * @param  event  The name of the event.\n   * @param args The arguments to pass to the functions listening.\n   */\n\n\n  emit(event, ...args) {\n    if (this._events) {\n      if (this._events.hasOwnProperty(event)) {\n        const eventList = this._events[event].slice(0);\n\n        for (let i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Add Emitter functions (on/off/emit) to the object\n   */\n\n\n  static mixin(constr) {\n    // instance._events = {};\n    [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n      Object.defineProperty(constr.prototype, name, property);\n    });\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._events = undefined;\n    return this;\n  }\n\n}","import { Emitter } from \"../util/Emitter\";\nexport class BaseContext extends Emitter {\n  constructor() {\n    super(...arguments);\n    this.isOffline = false;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\n\nexport class Context extends BaseContext {\n  constructor() {\n    super();\n    this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n\n    this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n\n    this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n\n    this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n\n    this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n\n    this.isOffline = false; //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n\n    this._workletModules = new Map();\n    const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n    if (options.context) {\n      this._context = options.context;\n    } else {\n      this._context = createAudioContext();\n    }\n\n    this._latencyHint = options.latencyHint;\n    this.lookAhead = options.lookAhead;\n    this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n    this.on(\"tick\", this._timeoutLoop.bind(this)); // fwd events from the context\n\n    this._context.onstatechange = () => {\n      this.emit(\"statechange\", this.state);\n    };\n  }\n\n  static getDefaults() {\n    return {\n      clockSource: \"worker\",\n      latencyHint: \"interactive\",\n      lookAhead: 0.1,\n      updateInterval: 0.05\n    };\n  }\n  /**\n   * Finish setting up the context. **You usually do not need to do this manually.**\n   */\n\n\n  initialize() {\n    if (!this._initialized) {\n      // add any additional modules\n      initializeContext(this);\n      this._initialized = true;\n    }\n\n    return this;\n  } //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAnalyser() {\n    return this._context.createAnalyser();\n  }\n\n  createOscillator() {\n    return this._context.createOscillator();\n  }\n\n  createBufferSource() {\n    return this._context.createBufferSource();\n  }\n\n  createBiquadFilter() {\n    return this._context.createBiquadFilter();\n  }\n\n  createBuffer(numberOfChannels, length, sampleRate) {\n    return this._context.createBuffer(numberOfChannels, length, sampleRate);\n  }\n\n  createChannelMerger(numberOfInputs) {\n    return this._context.createChannelMerger(numberOfInputs);\n  }\n\n  createChannelSplitter(numberOfOutputs) {\n    return this._context.createChannelSplitter(numberOfOutputs);\n  }\n\n  createConstantSource() {\n    return this._context.createConstantSource();\n  }\n\n  createConvolver() {\n    return this._context.createConvolver();\n  }\n\n  createDelay(maxDelayTime) {\n    return this._context.createDelay(maxDelayTime);\n  }\n\n  createDynamicsCompressor() {\n    return this._context.createDynamicsCompressor();\n  }\n\n  createGain() {\n    return this._context.createGain();\n  }\n\n  createIIRFilter(feedForward, feedback) {\n    // @ts-ignore\n    return this._context.createIIRFilter(feedForward, feedback);\n  }\n\n  createPanner() {\n    return this._context.createPanner();\n  }\n\n  createPeriodicWave(real, imag, constraints) {\n    return this._context.createPeriodicWave(real, imag, constraints);\n  }\n\n  createStereoPanner() {\n    return this._context.createStereoPanner();\n  }\n\n  createWaveShaper() {\n    return this._context.createWaveShaper();\n  }\n\n  createMediaStreamSource(stream) {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamSource(stream);\n  }\n\n  createMediaStreamDestination() {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamDestination();\n  }\n\n  decodeAudioData(audioData) {\n    return this._context.decodeAudioData(audioData);\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get currentTime() {\n    return this._context.currentTime;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get state() {\n    return this._context.state;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get sampleRate() {\n    return this._context.sampleRate;\n  }\n  /**\n   * The listener\n   */\n\n\n  get listener() {\n    this.initialize();\n    return this._listener;\n  }\n\n  set listener(l) {\n    assert(!this._initialized, \"The listener cannot be set after initialization.\");\n    this._listener = l;\n  }\n  /**\n   * There is only one Transport per Context. It is created on initialization.\n   */\n\n\n  get transport() {\n    this.initialize();\n    return this._transport;\n  }\n\n  set transport(t) {\n    assert(!this._initialized, \"The transport cannot be set after initialization.\");\n    this._transport = t;\n  }\n  /**\n   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n   */\n\n\n  get draw() {\n    this.initialize();\n    return this._draw;\n  }\n\n  set draw(d) {\n    assert(!this._initialized, \"Draw cannot be set after initialization.\");\n    this._draw = d;\n  }\n  /**\n   * A reference to the Context's destination node.\n   */\n\n\n  get destination() {\n    this.initialize();\n    return this._destination;\n  }\n\n  set destination(d) {\n    assert(!this._initialized, \"The destination cannot be set after initialization.\");\n    this._destination = d;\n  }\n  /**\n   * Create an audio worklet node from a name and options. The module\n   * must first be loaded using [[addAudioWorkletModule]].\n   */\n\n\n  createAudioWorkletNode(name, options) {\n    return createAudioWorkletNode(this.rawContext, name, options);\n  }\n  /**\n   * Add an AudioWorkletProcessor module\n   * @param url The url of the module\n   * @param name The name of the module\n   */\n\n\n  addAudioWorkletModule(url, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\n      if (!this._workletModules.has(name)) {\n        this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n      }\n\n      yield this._workletModules.get(name);\n    });\n  }\n  /**\n   * Returns a promise which resolves when all of the worklets have been loaded on this context\n   */\n\n\n  workletsAreReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [];\n\n      this._workletModules.forEach(promise => promises.push(promise));\n\n      yield Promise.all(promises);\n    });\n  } //---------------------------\n  // TICKER\n  //---------------------------\n\n  /**\n   * How often the interval callback is invoked.\n   * This number corresponds to how responsive the scheduling\n   * can be. context.updateInterval + context.lookAhead gives you the\n   * total latency between scheduling an event and hearing it.\n   */\n\n\n  get updateInterval() {\n    return this._ticker.updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._ticker.updateInterval = interval;\n  }\n  /**\n   * What the source of the clock is, either \"worker\" (default),\n   * \"timeout\", or \"offline\" (none).\n   */\n\n\n  get clockSource() {\n    return this._ticker.type;\n  }\n\n  set clockSource(type) {\n    this._ticker.type = type;\n  }\n  /**\n   * The type of playback, which affects tradeoffs between audio\n   * output latency and responsiveness.\n   * In addition to setting the value in seconds, the latencyHint also\n   * accepts the strings \"interactive\" (prioritizes low latency),\n   * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n   * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n   * @example\n   * // set the latencyHint to prioritize smooth playback at the expensive of latency\n   * Tone.context.latencyHint = \"playback\";\n   */\n\n\n  get latencyHint() {\n    return this._latencyHint;\n  }\n\n  set latencyHint(hint) {\n    let lookAheadValue = 0;\n    this._latencyHint = hint;\n\n    if (isString(hint)) {\n      switch (hint) {\n        case \"interactive\":\n          lookAheadValue = 0.1;\n          break;\n\n        case \"playback\":\n          lookAheadValue = 0.8;\n          break;\n\n        case \"balanced\":\n          lookAheadValue = 0.25;\n          break;\n\n        case \"fastest\":\n          lookAheadValue = 0.01;\n          break;\n      }\n    }\n\n    this.lookAhead = lookAheadValue;\n    this.updateInterval = lookAheadValue / 2;\n  }\n  /**\n   * The unwrapped AudioContext.\n   */\n\n\n  get rawContext() {\n    return this._context;\n  }\n  /**\n   * The current audio context time plus a short [[lookAhead]].\n   */\n\n\n  now() {\n    return this._context.currentTime + this.lookAhead;\n  }\n  /**\n   * The current audio context time without the [[lookAhead]].\n   * In most cases it is better to use [[now]] instead of [[immediate]] since\n   * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n   * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n   * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n   */\n\n\n  immediate() {\n    return this._context.currentTime;\n  }\n  /**\n   * Starts the audio context from a suspended state. This is required\n   * to initially start the AudioContext.\n   */\n\n\n  resume() {\n    if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n      return this._context.resume();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Promise which is invoked when the context is running.\n   * Tries to resume the context if it's not started.\n   */\n\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isAudioContext(this._context)) {\n        yield this._context.close();\n      }\n\n      if (this._initialized) {\n        closeContext(this);\n      }\n    });\n  }\n  /**\n   * Generate a looped buffer at some constant value.\n   */\n\n\n  getConstant(val) {\n    if (this._constants.has(val)) {\n      return this._constants.get(val);\n    } else {\n      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n      const arr = buffer.getChannelData(0);\n\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = val;\n      }\n\n      const constant = this._context.createBufferSource();\n\n      constant.channelCount = 1;\n      constant.channelCountMode = \"explicit\";\n      constant.buffer = buffer;\n      constant.loop = true;\n      constant.start(0);\n\n      this._constants.set(val, constant);\n\n      return constant;\n    }\n  }\n  /**\n   * Clean up. Also closes the audio context.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._ticker.dispose();\n\n    this._timeouts.dispose();\n\n    Object.keys(this._constants).map(val => this._constants[val].disconnect());\n    return this;\n  } //---------------------------\n  // TIMEOUTS\n  //---------------------------\n\n  /**\n   * The private loop which keeps track of the context scheduled timeouts\n   * Is invoked from the clock source\n   */\n\n\n  _timeoutLoop() {\n    const now = this.now();\n\n    let firstEvent = this._timeouts.peek();\n\n    while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n      // invoke the callback\n      firstEvent.callback(); // shift the first event off\n\n      this._timeouts.shift(); // get the next one\n\n\n      firstEvent = this._timeouts.peek();\n    }\n  }\n  /**\n   * A setTimeout which is guaranteed by the clock source.\n   * Also runs in the offline context.\n   * @param  fn       The callback to invoke\n   * @param  timeout  The timeout in seconds\n   * @returns ID to use when invoking Context.clearTimeout\n   */\n\n\n  setTimeout(fn, timeout) {\n    this._timeoutIds++;\n    const now = this.now();\n\n    this._timeouts.add({\n      callback: fn,\n      id: this._timeoutIds,\n      time: now + timeout\n    });\n\n    return this._timeoutIds;\n  }\n  /**\n   * Clears a previously scheduled timeout with Tone.context.setTimeout\n   * @param  id  The ID returned from setTimeout\n   */\n\n\n  clearTimeout(id) {\n    this._timeouts.forEach(event => {\n      if (event.id === id) {\n        this._timeouts.remove(event);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Clear the function scheduled by [[setInterval]]\n   */\n\n\n  clearInterval(id) {\n    return this.clearTimeout(id);\n  }\n  /**\n   * Adds a repeating event to the context's callback clock\n   */\n\n\n  setInterval(fn, interval) {\n    const id = ++this._timeoutIds;\n\n    const intervalFn = () => {\n      const now = this.now();\n\n      this._timeouts.add({\n        callback: () => {\n          // invoke the callback\n          fn(); // invoke the event to repeat it\n\n          intervalFn();\n        },\n        id,\n        time: now + interval\n      });\n    }; // kick it off\n\n\n    intervalFn();\n    return id;\n  }\n\n}","import { isArray } from \"./TypeCheck\";\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\n\nexport function readOnly(target, property) {\n  if (isArray(property)) {\n    property.forEach(str => readOnly(target, str));\n  } else {\n    Object.defineProperty(target, property, {\n      enumerable: true,\n      writable: false\n    });\n  }\n}\n/**\n * Make an attribute writeable. Internal use only.\n */\n\nexport function writable(target, property) {\n  if (isArray(property)) {\n    property.forEach(str => writable(target, str));\n  } else {\n    Object.defineProperty(target, property, {\n      writable: true\n    });\n  }\n}\nexport const noOp = () => {// no operation here!\n};","import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nexport class ToneAudioBuffer extends Tone {\n  constructor() {\n    super();\n    this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    this.onload = noOp;\n    const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    this.reverse = options.reverse;\n    this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      this.load(options.url).catch(options.onerror);\n    }\n  }\n\n  static getDefaults() {\n    return {\n      onerror: noOp,\n      onload: noOp,\n      reverse: false\n    };\n  }\n  /**\n   * The sample rate of the AudioBuffer\n   */\n\n\n  get sampleRate() {\n    if (this._buffer) {\n      return this._buffer.sampleRate;\n    } else {\n      return getContext().sampleRate;\n    }\n  }\n  /**\n   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n   */\n\n\n  set(buffer) {\n    if (buffer instanceof ToneAudioBuffer) {\n      // if it's loaded, set it\n      if (buffer.loaded) {\n        this._buffer = buffer.get();\n      } else {\n        // otherwise when it's loaded, invoke it's callback\n        buffer.onload = () => {\n          this.set(buffer);\n          this.onload(this);\n        };\n      }\n    } else {\n      this._buffer = buffer;\n    } // reverse it initially\n\n\n    if (this._reversed) {\n      this._reverse();\n    }\n\n    return this;\n  }\n  /**\n   * The audio buffer stored in the object.\n   */\n\n\n  get() {\n    return this._buffer;\n  }\n  /**\n   * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n   * Invokes the callback once the audio buffer loads.\n   * @param url The url of the buffer to load. filetype support depends on the browser.\n   * @returns A Promise which resolves with this ToneAudioBuffer\n   */\n\n\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {\n        this.set(audioBuffer); // invoke the onload method\n\n        this.onload(this);\n      });\n      ToneAudioBuffer.downloads.push(doneLoading);\n\n      try {\n        yield doneLoading;\n      } finally {\n        // remove the downloaded file\n        const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n        ToneAudioBuffer.downloads.splice(index, 1);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._buffer = undefined;\n    return this;\n  }\n  /**\n   * Set the audio buffer from the array.\n   * To create a multichannel AudioBuffer, pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   */\n\n\n  fromArray(array) {\n    const isMultidimensional = isArray(array) && array[0].length > 0;\n    const channels = isMultidimensional ? array.length : 1;\n    const len = isMultidimensional ? array[0].length : array.length;\n    const context = getContext();\n    const buffer = context.createBuffer(channels, len, context.sampleRate);\n    const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n    for (let c = 0; c < channels; c++) {\n      buffer.copyToChannel(multiChannelArray[c], c);\n    }\n\n    this._buffer = buffer;\n    return this;\n  }\n  /**\n   * Sums multiple channels into 1 channel\n   * @param chanNum Optionally only copy a single channel from the array.\n   */\n\n\n  toMono(chanNum) {\n    if (isNumber(chanNum)) {\n      this.fromArray(this.toArray(chanNum));\n    } else {\n      let outputArray = new Float32Array(this.length);\n      const numChannels = this.numberOfChannels;\n\n      for (let channel = 0; channel < numChannels; channel++) {\n        const channelArray = this.toArray(channel);\n\n        for (let i = 0; i < channelArray.length; i++) {\n          outputArray[i] += channelArray[i];\n        }\n      } // divide by the number of channels\n\n\n      outputArray = outputArray.map(sample => sample / numChannels);\n      this.fromArray(outputArray);\n    }\n\n    return this;\n  }\n  /**\n   * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n   * Float32Array, and multichannel buffers will return multidimensional arrays.\n   * @param channel Optionally only copy a single channel from the array.\n   */\n\n\n  toArray(channel) {\n    if (isNumber(channel)) {\n      return this.getChannelData(channel);\n    } else if (this.numberOfChannels === 1) {\n      return this.toArray(0);\n    } else {\n      const ret = [];\n\n      for (let c = 0; c < this.numberOfChannels; c++) {\n        ret[c] = this.getChannelData(c);\n      }\n\n      return ret;\n    }\n  }\n  /**\n   * Returns the Float32Array representing the PCM audio data for the specific channel.\n   * @param  channel  The channel number to return\n   * @return The audio as a TypedArray\n   */\n\n\n  getChannelData(channel) {\n    if (this._buffer) {\n      return this._buffer.getChannelData(channel);\n    } else {\n      return new Float32Array(0);\n    }\n  }\n  /**\n   * Cut a subsection of the array and return a buffer of the\n   * subsection. Does not modify the original buffer\n   * @param start The time to start the slice\n   * @param end The end time to slice. If none is given will default to the end of the buffer\n   */\n\n\n  slice(start, end = this.duration) {\n    const startSamples = Math.floor(start * this.sampleRate);\n    const endSamples = Math.floor(end * this.sampleRate);\n    assert(startSamples < endSamples, \"The start time must be less than the end time\");\n    const length = endSamples - startSamples;\n    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n    for (let channel = 0; channel < this.numberOfChannels; channel++) {\n      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n    }\n\n    return new ToneAudioBuffer(retBuffer);\n  }\n  /**\n   * Reverse the buffer.\n   */\n\n\n  _reverse() {\n    if (this.loaded) {\n      for (let i = 0; i < this.numberOfChannels; i++) {\n        this.getChannelData(i).reverse();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * If the buffer is loaded or not\n   */\n\n\n  get loaded() {\n    return this.length > 0;\n  }\n  /**\n   * The duration of the buffer in seconds.\n   */\n\n\n  get duration() {\n    if (this._buffer) {\n      return this._buffer.duration;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The length of the buffer in samples\n   */\n\n\n  get length() {\n    if (this._buffer) {\n      return this._buffer.length;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n   */\n\n\n  get numberOfChannels() {\n    if (this._buffer) {\n      return this._buffer.numberOfChannels;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Reverse the buffer.\n   */\n\n\n  get reverse() {\n    return this._reversed;\n  }\n\n  set reverse(rev) {\n    if (this._reversed !== rev) {\n      this._reversed = rev;\n\n      this._reverse();\n    }\n  }\n  /**\n   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n   * pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   * @return A ToneAudioBuffer created from the array\n   */\n\n\n  static fromArray(array) {\n    return new ToneAudioBuffer().fromArray(array);\n  }\n  /**\n   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n   * @param  url The url to load.\n   * @return A promise which resolves to a ToneAudioBuffer\n   */\n\n\n  static fromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buffer = new ToneAudioBuffer();\n      return yield buffer.load(url);\n    });\n  }\n  /**\n   * Loads a url using fetch and returns the AudioBuffer.\n   */\n\n\n  static load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // test if the url contains multiple extensions\n      const matches = url.match(/\\[(.+\\|?)+\\]$/);\n\n      if (matches) {\n        const extensions = matches[1].split(\"|\");\n        let extension = extensions[0];\n\n        for (const ext of extensions) {\n          if (ToneAudioBuffer.supportsType(ext)) {\n            extension = ext;\n            break;\n          }\n        }\n\n        url = url.replace(matches[0], extension);\n      } // make sure there is a slash between the baseUrl and the url\n\n\n      const baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n      const response = yield fetch(baseUrl + url);\n\n      if (!response.ok) {\n        throw new Error(`could not load url: ${url}`);\n      }\n\n      const arrayBuffer = yield response.arrayBuffer();\n      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n      return audioBuffer;\n    });\n  }\n  /**\n   * Checks a url's extension to see if the current browser can play that file type.\n   * @param url The url/extension to test\n   * @return If the file extension can be played\n   * @static\n   * @example\n   * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n   * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n   */\n\n\n  static supportsType(url) {\n    const extensions = url.split(\".\");\n    const extension = extensions[extensions.length - 1];\n    const response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n    return response !== \"\";\n  }\n  /**\n   * Returns a Promise which resolves when all of the buffers have loaded\n   */\n\n\n  static loaded() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // this makes sure that the function is always async\n      yield Promise.resolve();\n\n      while (ToneAudioBuffer.downloads.length) {\n        yield ToneAudioBuffer.downloads[0];\n      }\n    });\n  }\n\n} //-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n\n/**\n * A path which is prefixed before every url.\n */\n\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\n\nToneAudioBuffer.downloads = [];","import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport class OfflineContext extends Context {\n  constructor() {\n    super({\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    this._currentTime = 0;\n    this.isOffline = true;\n    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  now() {\n    return this._currentTime;\n  }\n  /**\n   * Same as this.now()\n   */\n\n\n  get currentTime() {\n    return this._currentTime;\n  }\n  /**\n   * Render just the clock portion of the audio context.\n   */\n\n\n  _renderClock(asynchronous) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let index = 0;\n\n      while (this._duration - this._currentTime >= 0) {\n        // invoke all the callbacks on that time\n        this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n        this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n        index++;\n        const yieldEvery = Math.floor(this.sampleRate / 128);\n\n        if (asynchronous && index % yieldEvery === 0) {\n          yield new Promise(done => setTimeout(done, 1));\n        }\n      }\n    });\n  }\n  /**\n   * Render the output of the OfflineContext\n   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n   */\n\n\n  render(asynchronous = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.workletsAreReady();\n      yield this._renderClock(asynchronous);\n      const buffer = yield this._context.startRendering();\n      return new ToneAudioBuffer(buffer);\n    });\n  }\n  /**\n   * Close the context\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n\n}","import { version } from \"../version\";\nimport { hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { DummyContext } from \"./context/DummyContext\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\n\nconst dummyContext = new DummyContext();\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\n\nlet globalContext = dummyContext;\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\n\nexport function getContext() {\n  if (globalContext === dummyContext && hasAudioContext) {\n    setContext(new Context());\n  }\n\n  return globalContext;\n}\n/**\n * Set the default audio context\n * @category Core\n */\n\nexport function setContext(context) {\n  if (isAudioContext(context)) {\n    globalContext = new Context(context);\n  } else if (isOfflineAudioContext(context)) {\n    globalContext = new OfflineContext(context);\n  } else {\n    globalContext = context;\n  }\n}\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\n\nexport function start() {\n  return globalContext.resume();\n}\n/**\n * Log Tone.js + version in the console.\n */\n\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n  let prefix = \"v\";\n\n  if (version === \"dev\") {\n    prefix = \"\";\n  }\n\n  const printString = ` * Tone.js ${prefix}${version} * `; // eslint-disable-next-line no-console\n\n  console.log(`%c${printString}`, \"background: #000; color: #fff\");\n}","import { __awaiter } from \"tslib\";\nimport { BaseContext } from \"./BaseContext\";\nexport class DummyContext extends BaseContext {\n  constructor() {\n    super(...arguments);\n    this.lookAhead = 0;\n    this.latencyHint = 0;\n    this.isOffline = false;\n  } //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAnalyser() {\n    return {};\n  }\n\n  createOscillator() {\n    return {};\n  }\n\n  createBufferSource() {\n    return {};\n  }\n\n  createBiquadFilter() {\n    return {};\n  }\n\n  createBuffer(_numberOfChannels, _length, _sampleRate) {\n    return {};\n  }\n\n  createChannelMerger(_numberOfInputs) {\n    return {};\n  }\n\n  createChannelSplitter(_numberOfOutputs) {\n    return {};\n  }\n\n  createConstantSource() {\n    return {};\n  }\n\n  createConvolver() {\n    return {};\n  }\n\n  createDelay(_maxDelayTime) {\n    return {};\n  }\n\n  createDynamicsCompressor() {\n    return {};\n  }\n\n  createGain() {\n    return {};\n  }\n\n  createIIRFilter(_feedForward, _feedback) {\n    return {};\n  }\n\n  createPanner() {\n    return {};\n  }\n\n  createPeriodicWave(_real, _imag, _constraints) {\n    return {};\n  }\n\n  createStereoPanner() {\n    return {};\n  }\n\n  createWaveShaper() {\n    return {};\n  }\n\n  createMediaStreamSource(_stream) {\n    return {};\n  }\n\n  createMediaStreamDestination() {\n    return {};\n  }\n\n  decodeAudioData(_audioData) {\n    return Promise.resolve({});\n  } //---------------------------\n  // TONE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAudioWorkletNode(_name, _options) {\n    return {};\n  }\n\n  get rawContext() {\n    return {};\n  }\n\n  addAudioWorkletModule(_url, _name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve();\n    });\n  }\n\n  resume() {\n    return Promise.resolve();\n  }\n\n  setTimeout(_fn, _timeout) {\n    return 0;\n  }\n\n  clearTimeout(_id) {\n    return this;\n  }\n\n  setInterval(_fn, _interval) {\n    return 0;\n  }\n\n  clearInterval(_id) {\n    return this;\n  }\n\n  getConstant(_val) {\n    return {};\n  }\n\n  get currentTime() {\n    return 0;\n  }\n\n  get state() {\n    return {};\n  }\n\n  get sampleRate() {\n    return 0;\n  }\n\n  get listener() {\n    return {};\n  }\n\n  get transport() {\n    return {};\n  }\n\n  get draw() {\n    return {};\n  }\n\n  set draw(_d) {}\n\n  get destination() {\n    return {};\n  }\n\n  set destination(_d) {}\n\n  now() {\n    return 0;\n  }\n\n  immediate() {\n    return 0;\n  }\n\n}","/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent) {\n  const piFactor = 0.5 * Math.PI;\n  return Math.sin(percent * piFactor);\n}\n/**\n * Convert decibels into gain.\n */\n\nexport function dbToGain(db) {\n  return Math.pow(10, db / 20);\n}\n/**\n * Convert gain to decibels.\n */\n\nexport function gainToDb(gain) {\n  return 20 * (Math.log(gain) / Math.LN10);\n}\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\n\nexport function intervalToFrequencyRatio(interval) {\n  return Math.pow(2, interval / 12);\n}\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\n\nlet A4 = 440;\nexport function getA4() {\n  return A4;\n}\nexport function setA4(freq) {\n  A4 = freq;\n}\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\n\nexport function ftom(frequency) {\n  return Math.round(ftomf(frequency));\n}\n/**\n * Convert a frequency to a floating point midi value\n */\n\nexport function ftomf(frequency) {\n  return 69 + 12 * Math.log2(frequency / A4);\n}\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\n\nexport function mtof(midi) {\n  return A4 * Math.pow(2, (midi - 69) / 12);\n}","import { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\n\nexport class TimeBaseClass extends Tone {\n  /**\n   * @param context The context associated with the time value. Used to compute\n   * Transport and context-relative timing.\n   * @param  value  The time value as a number, string or object\n   * @param  units  Unit values\n   */\n  constructor(context, value, units) {\n    super();\n    /**\n     * The default units\n     */\n\n    this.defaultUnits = \"s\";\n    this._val = value;\n    this._units = units;\n    this.context = context;\n    this._expressions = this._getExpressions();\n  }\n  /**\n   * All of the time encoding expressions\n   */\n\n\n  _getExpressions() {\n    return {\n      hz: {\n        method: value => {\n          return this._frequencyToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)hz$/i\n      },\n      i: {\n        method: value => {\n          return this._ticksToUnits(parseInt(value, 10));\n        },\n        regexp: /^(\\d+)i$/i\n      },\n      m: {\n        method: value => {\n          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n        },\n        regexp: /^(\\d+)m$/i\n      },\n      n: {\n        method: (value, dot) => {\n          const numericValue = parseInt(value, 10);\n          const scalar = dot === \".\" ? 1.5 : 1;\n\n          if (numericValue === 1) {\n            return this._beatsToUnits(this._getTimeSignature()) * scalar;\n          } else {\n            return this._beatsToUnits(4 / numericValue) * scalar;\n          }\n        },\n        regexp: /^(\\d+)n(\\.?)$/i\n      },\n      number: {\n        method: value => {\n          return this._expressions[this.defaultUnits].method.call(this, value);\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)$/\n      },\n      s: {\n        method: value => {\n          return this._secondsToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)s$/\n      },\n      samples: {\n        method: value => {\n          return parseInt(value, 10) / this.context.sampleRate;\n        },\n        regexp: /^(\\d+)samples$/\n      },\n      t: {\n        method: value => {\n          const numericValue = parseInt(value, 10);\n          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n        },\n        regexp: /^(\\d+)t$/i\n      },\n      tr: {\n        method: (m, q, s) => {\n          let total = 0;\n\n          if (m && m !== \"0\") {\n            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total += this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total += this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/\n      }\n    };\n  } //-------------------------------------\n  // \tVALUE OF\n  //-------------------------------------\n\n  /**\n   * Evaluate the time value. Returns the time in seconds.\n   */\n\n\n  valueOf() {\n    if (this._val instanceof TimeBaseClass) {\n      this.fromType(this._val);\n    }\n\n    if (isUndef(this._val)) {\n      return this._noArg();\n    } else if (isString(this._val) && isUndef(this._units)) {\n      for (const units in this._expressions) {\n        if (this._expressions[units].regexp.test(this._val.trim())) {\n          this._units = units;\n          break;\n        }\n      }\n    } else if (isObject(this._val)) {\n      let total = 0;\n\n      for (const typeName in this._val) {\n        if (isDefined(this._val[typeName])) {\n          const quantity = this._val[typeName]; // @ts-ignore\n\n          const time = new this.constructor(this.context, typeName).valueOf() * quantity;\n          total += time;\n        }\n      }\n\n      return total;\n    }\n\n    if (isDefined(this._units)) {\n      const expr = this._expressions[this._units];\n\n      const matching = this._val.toString().trim().match(expr.regexp);\n\n      if (matching) {\n        return expr.method.apply(this, matching.slice(1));\n      } else {\n        return expr.method.call(this, this._val);\n      }\n    } else if (isString(this._val)) {\n      return parseFloat(this._val);\n    } else {\n      return this._val;\n    }\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return 1 / freq;\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return 60 / this._getBpm() * beats;\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return seconds;\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ticks * this._beatsToUnits(1) / this._getPPQ();\n  }\n  /**\n   * With no arguments, return 'now'\n   */\n\n\n  _noArg() {\n    return this._now();\n  } //-------------------------------------\n  // \tTEMPO CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Return the bpm\n   */\n\n\n  _getBpm() {\n    return this.context.transport.bpm.value;\n  }\n  /**\n   * Return the timeSignature\n   */\n\n\n  _getTimeSignature() {\n    return this.context.transport.timeSignature;\n  }\n  /**\n   * Return the PPQ or 192 if Transport is not available\n   */\n\n\n  _getPPQ() {\n    return this.context.transport.PPQ;\n  } //-------------------------------------\n  // \tCONVERSION INTERFACE\n  //-------------------------------------\n\n  /**\n   * Coerce a time type into this units type.\n   * @param type Any time type units\n   */\n\n\n  fromType(type) {\n    this._units = undefined;\n\n    switch (this.defaultUnits) {\n      case \"s\":\n        this._val = type.toSeconds();\n        break;\n\n      case \"i\":\n        this._val = type.toTicks();\n        break;\n\n      case \"hz\":\n        this._val = type.toFrequency();\n        break;\n\n      case \"midi\":\n        this._val = type.toMidi();\n        break;\n    }\n\n    return this;\n  }\n  /**\n   * Return the value in hertz\n   */\n\n\n  toFrequency() {\n    return 1 / this.toSeconds();\n  }\n  /**\n   * Return the time in samples\n   */\n\n\n  toSamples() {\n    return this.toSeconds() * this.context.sampleRate;\n  }\n  /**\n   * Return the time in milliseconds.\n   */\n\n\n  toMilliseconds() {\n    return this.toSeconds() * 1000;\n  }\n\n}","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\n\nexport class TimeClass extends TimeBaseClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"TimeClass\";\n  }\n\n  _getExpressions() {\n    return Object.assign(super._getExpressions(), {\n      now: {\n        method: capture => {\n          return this._now() + new this.constructor(this.context, capture).valueOf();\n        },\n        regexp: /^\\+(.+)/\n      },\n      quantize: {\n        method: capture => {\n          const quantTo = new TimeClass(this.context, capture).valueOf();\n          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n        },\n        regexp: /^@(.+)/\n      }\n    });\n  }\n  /**\n   * Quantize the time by the given subdivision. Optionally add a\n   * percentage which will move the time value towards the ideal\n   * quantized value by that percentage.\n   * @param  subdiv    The subdivision to quantize to\n   * @param  percent  Move the time value towards the quantized value by a percentage.\n   * @example\n   * Tone.Time(21).quantize(2); // returns 22\n   * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n   */\n\n\n  quantize(subdiv, percent = 1) {\n    const subdivision = new this.constructor(this.context, subdiv).valueOf();\n    const value = this.valueOf();\n    const multiple = Math.round(value / subdivision);\n    const ideal = multiple * subdivision;\n    const diff = ideal - value;\n    return value + diff * percent;\n  } //-------------------------------------\n  // CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Convert a Time to Notation. The notation values are will be the\n   * closest representation between 1m to 128th note.\n   * @return {Notation}\n   * @example\n   * // if the Transport is at 120bpm:\n   * Tone.Time(2).toNotation(); // returns \"1m\"\n   */\n\n\n  toNotation() {\n    const time = this.toSeconds();\n    const testNotations = [\"1m\"];\n\n    for (let power = 1; power < 9; power++) {\n      const subdiv = Math.pow(2, power);\n      testNotations.push(subdiv + \"n.\");\n      testNotations.push(subdiv + \"n\");\n      testNotations.push(subdiv + \"t\");\n    }\n\n    testNotations.push(\"0\"); // find the closets notation representation\n\n    let closest = testNotations[0];\n    let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n    testNotations.forEach(notation => {\n      const notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\n      if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n        closest = notation;\n        closestSeconds = notationSeconds;\n      }\n    });\n    return closest;\n  }\n  /**\n   * Return the time encoded as Bars:Beats:Sixteenths.\n   */\n\n\n  toBarsBeatsSixteenths() {\n    const quarterTime = this._beatsToUnits(1);\n\n    let quarters = this.valueOf() / quarterTime;\n    quarters = parseFloat(quarters.toFixed(4));\n    const measures = Math.floor(quarters / this._getTimeSignature());\n    let sixteenths = quarters % 1 * 4;\n    quarters = Math.floor(quarters) % this._getTimeSignature();\n    const sixteenthString = sixteenths.toString();\n\n    if (sixteenthString.length > 3) {\n      // the additional parseFloat removes insignificant trailing zeroes\n      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n    }\n\n    const progress = [measures, quarters, sixteenths];\n    return progress.join(\":\");\n  }\n  /**\n   * Return the time in ticks.\n   */\n\n\n  toTicks() {\n    const quarterTime = this._beatsToUnits(1);\n\n    const quarters = this.valueOf() / quarterTime;\n    return Math.round(quarters * this._getPPQ());\n  }\n  /**\n   * Return the time in seconds.\n   */\n\n\n  toSeconds() {\n    return this.valueOf();\n  }\n  /**\n   * Return the value as a midi note.\n   */\n\n\n  toMidi() {\n    return ftom(this.toFrequency());\n  }\n\n  _now() {\n    return this.context.now();\n  }\n\n}\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n */\n\nexport function Time(value, units) {\n  return new TimeClass(getContext(), value, units);\n}","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\n\nexport class FrequencyClass extends TimeClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"Frequency\";\n    this.defaultUnits = \"hz\";\n  }\n  /**\n   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n   * to generate all the other pitch values from notes. A4's values in Hertz.\n   */\n\n\n  static get A4() {\n    return getA4();\n  }\n\n  static set A4(freq) {\n    setA4(freq);\n  } //-------------------------------------\n  // \tAUGMENT BASE EXPRESSIONS\n  //-------------------------------------\n\n\n  _getExpressions() {\n    return Object.assign({}, super._getExpressions(), {\n      midi: {\n        regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\n        method(value) {\n          if (this.defaultUnits === \"midi\") {\n            return value;\n          } else {\n            return FrequencyClass.mtof(value);\n          }\n        }\n\n      },\n      note: {\n        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\n        method(pitch, octave) {\n          const index = noteToScaleIndex[pitch.toLowerCase()];\n          const noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\n          if (this.defaultUnits === \"midi\") {\n            return noteNumber;\n          } else {\n            return FrequencyClass.mtof(noteNumber);\n          }\n        }\n\n      },\n      tr: {\n        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\n        method(m, q, s) {\n          let total = 1;\n\n          if (m && m !== \"0\") {\n            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total *= this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total *= this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        }\n\n      }\n    });\n  } //-------------------------------------\n  // \tEXPRESSIONS\n  //-------------------------------------\n\n  /**\n   * Transposes the frequency by the given number of semitones.\n   * @return  A new transposed frequency\n   * @example\n   * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n   */\n\n\n  transpose(interval) {\n    return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n  }\n  /**\n   * Takes an array of semitone intervals and returns\n   * an array of frequencies transposed by those intervals.\n   * @return  Returns an array of Frequencies\n   * @example\n   * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n   */\n\n\n  harmonize(intervals) {\n    return intervals.map(interval => {\n      return this.transpose(interval);\n    });\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Return the value of the frequency as a MIDI note\n   * @example\n   * Tone.Frequency(\"C4\").toMidi(); // 60\n   */\n\n\n  toMidi() {\n    return ftom(this.valueOf());\n  }\n  /**\n   * Return the value of the frequency in Scientific Pitch Notation\n   * @example\n   * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n   */\n\n\n  toNote() {\n    const freq = this.toFrequency();\n    const log = Math.log2(freq / FrequencyClass.A4);\n    let noteNumber = Math.round(12 * log) + 57;\n    const octave = Math.floor(noteNumber / 12);\n\n    if (octave < 0) {\n      noteNumber += -12 * octave;\n    }\n\n    const noteName = scaleIndexToNote[noteNumber % 12];\n    return noteName + octave.toString();\n  }\n  /**\n   * Return the duration of one cycle in seconds.\n   */\n\n\n  toSeconds() {\n    return 1 / super.toSeconds();\n  }\n  /**\n   * Return the duration of one cycle in ticks\n   */\n\n\n  toTicks() {\n    const quarterTime = this._beatsToUnits(1);\n\n    const quarters = this.valueOf() / quarterTime;\n    return Math.floor(quarters * this._getPPQ());\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS HELPERS\n  //-------------------------------------\n\n  /**\n   * With no arguments, return 0\n   */\n\n\n  _noArg() {\n    return 0;\n  }\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return freq;\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return 1 / super._beatsToUnits(beats);\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return 1 / seconds;\n  }\n  /**\n   * Convert a MIDI note to frequency value.\n   * @param  midi The midi number to convert.\n   * @return The corresponding frequency value\n   */\n\n\n  static mtof(midi) {\n    return mtof(midi);\n  }\n  /**\n   * Convert a frequency value to a MIDI note.\n   * @param frequency The value to frequency value to convert.\n   */\n\n\n  static ftom(frequency) {\n    return ftom(frequency);\n  }\n\n} //-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index.\n * @hidden\n */\n\nconst noteToScaleIndex = {\n  cbb: -2,\n  cb: -1,\n  c: 0,\n  \"c#\": 1,\n  cx: 2,\n  dbb: 0,\n  db: 1,\n  d: 2,\n  \"d#\": 3,\n  dx: 4,\n  ebb: 2,\n  eb: 3,\n  e: 4,\n  \"e#\": 5,\n  ex: 6,\n  fbb: 3,\n  fb: 4,\n  f: 5,\n  \"f#\": 6,\n  fx: 7,\n  gbb: 5,\n  gb: 6,\n  g: 7,\n  \"g#\": 8,\n  gx: 9,\n  abb: 7,\n  ab: 8,\n  a: 9,\n  \"a#\": 10,\n  ax: 11,\n  bbb: 9,\n  bb: 10,\n  b: 11,\n  \"b#\": 12,\n  bx: 13\n};\n/**\n * scale index to note (sharps)\n * @hidden\n */\n\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\n\nexport function Frequency(value, units) {\n  return new FrequencyClass(getContext(), value, units);\n}","import { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\n\nexport class TransportTimeClass extends TimeClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"TransportTime\";\n  }\n  /**\n   * Return the current time in whichever context is relevant\n   */\n\n\n  _now() {\n    return this.context.transport.seconds;\n  }\n\n}\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\n\nexport function TransportTime(value, units) {\n  return new TransportTimeClass(getContext(), value, units);\n}","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * The Base class for all nodes that have an AudioContext.\n */\n\nexport class ToneWithContext extends Tone {\n  constructor() {\n    super();\n    const options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\n    if (this.defaultContext) {\n      this.context = this.defaultContext;\n    } else {\n      this.context = options.context;\n    }\n  }\n\n  static getDefaults() {\n    return {\n      context: getContext()\n    };\n  }\n  /**\n   * Return the current time of the Context clock plus the lookAhead.\n   * @example\n   * setInterval(() => {\n   * \tconsole.log(Tone.now());\n   * }, 100)\n   */\n\n\n  now() {\n    return this.context.currentTime + this.context.lookAhead;\n  }\n  /**\n   * Return the current time of the Context clock without any lookAhead.\n   * @example\n   * setInterval(() => {\n   * \tconsole.log(Tone.immediate());\n   * }, 100)\n   */\n\n\n  immediate() {\n    return this.context.currentTime;\n  }\n  /**\n   * The duration in seconds of one sample.\n   * @example\n   * console.log(Tone.Transport.sampleTime);\n   */\n\n\n  get sampleTime() {\n    return 1 / this.context.sampleRate;\n  }\n  /**\n   * The number of seconds of 1 processing block (128 samples)\n   * @example\n   * console.log(Tone.Destination.blockTime);\n   */\n\n\n  get blockTime() {\n    return 128 / this.context.sampleRate;\n  }\n  /**\n   * Convert the incoming time to seconds\n   * @example\n   * const gain = new Tone.Gain();\n   * console.log(gain.toSeconds(\"4n\"));\n   */\n\n\n  toSeconds(time) {\n    return new TimeClass(this.context, time).toSeconds();\n  }\n  /**\n   * Convert the input to a frequency number\n   * @example\n   * const gain = new Tone.Gain();\n   * console.log(gain.toFrequency(\"4n\"));\n   */\n\n\n  toFrequency(freq) {\n    return new FrequencyClass(this.context, freq).toFrequency();\n  }\n  /**\n   * Convert the input time into ticks\n   * @example\n   * const gain = new Tone.Gain();\n   * console.log(gain.toTicks(\"4n\"));\n   */\n\n\n  toTicks(time) {\n    return new TransportTimeClass(this.context, time).toTicks();\n  } //-------------------------------------\n  // \tGET/SET\n  //-------------------------------------\n\n  /**\n   * Get a subset of the properties which are in the partial props\n   */\n\n\n  _getPartialProperties(props) {\n    const options = this.get(); // remove attributes from the prop that are not in the partial\n\n    Object.keys(options).forEach(name => {\n      if (isUndef(props[name])) {\n        delete options[name];\n      }\n    });\n    return options;\n  }\n  /**\n   * Get the object's attributes.\n   * @example\n   * const osc = new Tone.Oscillator();\n   * console.log(osc.get());\n   */\n\n\n  get() {\n    const defaults = getDefaultsFromInstance(this);\n    Object.keys(defaults).forEach(attribute => {\n      if (Reflect.has(this, attribute)) {\n        const member = this[attribute];\n\n        if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n          defaults[attribute] = member.value;\n        } else if (member instanceof ToneWithContext) {\n          defaults[attribute] = member._getPartialProperties(defaults[attribute]); // otherwise make sure it's a serializable type\n        } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n          defaults[attribute] = member;\n        } else {\n          // remove all undefined and unserializable attributes\n          delete defaults[attribute];\n        }\n      }\n    });\n    return defaults;\n  }\n  /**\n   * Set multiple properties at once with an object.\n   * @example\n   * const filter = new Tone.Filter();\n   * // set values using an object\n   * filter.set({\n   * \tfrequency: 300,\n   * \ttype: \"highpass\"\n   * });\n   */\n\n\n  set(props) {\n    Object.keys(props).forEach(attribute => {\n      if (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n        if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n          // small optimization\n          if (this[attribute].value !== props[attribute]) {\n            this[attribute].value = props[attribute];\n          }\n        } else if (this[attribute] instanceof ToneWithContext) {\n          this[attribute].set(props[attribute]);\n        } else {\n          this[attribute] = props[attribute];\n        }\n      }\n    });\n    return this;\n  }\n\n}","import { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\n\nexport class StateTimeline extends Timeline {\n  constructor(initial = \"stopped\") {\n    super();\n    this.name = \"StateTimeline\";\n    this._initial = initial;\n    this.setStateAtTime(this._initial, 0);\n  }\n  /**\n   * Returns the scheduled state scheduled before or at\n   * the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   */\n\n\n  getValueAtTime(time) {\n    const event = this.get(time);\n\n    if (event !== null) {\n      return event.state;\n    } else {\n      return this._initial;\n    }\n  }\n  /**\n   * Add a state to the timeline.\n   * @param  state The name of the state to set.\n   * @param  time  The time to query.\n   * @param options Any additional options that are needed in the timeline.\n   */\n\n\n  setStateAtTime(state, time, options) {\n    assertRange(time, 0);\n    this.add(Object.assign({}, options, {\n      state,\n      time\n    }));\n    return this;\n  }\n  /**\n   * Return the event before the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check before\n   * @return  The event with the given state before the time\n   */\n\n\n  getLastState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n\n    for (let i = index; i >= 0; i--) {\n      const event = this._timeline[i];\n\n      if (event.state === state) {\n        return event;\n      }\n    }\n  }\n  /**\n   * Return the event after the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check from\n   * @return  The event with the given state after the time\n   */\n\n\n  getNextState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n\n    if (index !== -1) {\n      for (let i = index; i < this._timeline.length; i++) {\n        const event = this._timeline[i];\n\n        if (event.state === state) {\n          return event;\n        }\n      }\n    }\n  }\n\n}","import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\n\nexport class Param extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n\n    this._minOutput = 1e-7;\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n\n    if (this._swappable) {\n      this.input = this.context.createGain(); // initialize\n\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue; // if the value is defined, set it immediately\n\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n\n\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n\n\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n\n\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n\n\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  } //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n\n    const numericValue = this._fromType(value);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n    this._assertRange(numericValue);\n\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n\n    this._param.setValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n\n    const after = this._events.getAfter(computedTime);\n\n    const before = this._events.get(computedTime);\n\n    let value = this._initialValue; // if it was set by\n\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n\n      let previousVal;\n\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n\n    return this._toType(value);\n  }\n\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\n    this._assertRange(numericValue);\n\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value);\n\n    numericValue = Math.max(this._minOutput, numericValue);\n\n    this._assertRange(numericValue);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`); // store the event\n\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value\n\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.\n\n\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n\n    this._assertRange(numericValue);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n\n    return this;\n  }\n\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\n    this._events.cancel(computedTime);\n\n    this._param.cancelScheduledValues(computedTime);\n\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events\n\n\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime); // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n\n    const before = this._events.get(computedTime);\n\n    const after = this._events.getAfter(computedTime);\n\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time); // cancel the next event(s)\n\n\n      this._events.cancel(after.time);\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    } // set the value at the given time\n\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n\n    this._param.setValueAtTime(valueAtTime, computedTime);\n\n    return this;\n  }\n\n  rampTo(value, rampTime = 0.1, startTime) {\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n\n\n  apply(param) {\n    const now = this.context.currentTime; // set the param's value at the current time and schedule everything else\n\n    param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it\n\n    const previousEvent = this._events.get(now);\n\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event\n\n\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n\n\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._events.dispose();\n\n    return this;\n  }\n\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  } //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n\n\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  } // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  } // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n\n}","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport class ToneAudioNode extends ToneWithContext {\n  constructor() {\n    super(...arguments);\n    /**\n     * The name of the class\n     */\n\n    this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    this._internalChannels = [];\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  get numberOfInputs() {\n    if (isDefined(this.input)) {\n      if (isAudioParam(this.input) || this.input instanceof Param) {\n        return 1;\n      } else {\n        return this.input.numberOfInputs;\n      }\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of outputs of the AudioNode.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfOutputs);\n   */\n\n\n  get numberOfOutputs() {\n    if (isDefined(this.output)) {\n      return this.output.numberOfOutputs;\n    } else {\n      return 0;\n    }\n  } //-------------------------------------\n  // AUDIO PROPERTIES\n  //-------------------------------------\n\n  /**\n   * Used to decide which nodes to get/set properties on\n   */\n\n\n  _isAudioNode(node) {\n    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n  }\n  /**\n   * Get all of the audio nodes (either internal or input/output) which together\n   * make up how the class node responds to channel input/output\n   */\n\n\n  _getInternalNodes() {\n    const nodeList = this._internalChannels.slice(0);\n\n    if (this._isAudioNode(this.input)) {\n      nodeList.push(this.input);\n    }\n\n    if (this._isAudioNode(this.output)) {\n      if (this.input !== this.output) {\n        nodeList.push(this.output);\n      }\n    }\n\n    return nodeList;\n  }\n  /**\n   * Set the audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   * @param options\n   */\n\n\n  _setChannelProperties(options) {\n    const nodeList = this._getInternalNodes();\n\n    nodeList.forEach(node => {\n      node.channelCount = options.channelCount;\n      node.channelCountMode = options.channelCountMode;\n      node.channelInterpretation = options.channelInterpretation;\n    });\n  }\n  /**\n   * Get the current audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   */\n\n\n  _getChannelProperties() {\n    const nodeList = this._getInternalNodes();\n\n    assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n    // they should all be the same\n\n    const node = nodeList[0];\n    return {\n      channelCount: node.channelCount,\n      channelCountMode: node.channelCountMode,\n      channelInterpretation: node.channelInterpretation\n    };\n  }\n  /**\n   * channelCount is the number of channels used when up-mixing and down-mixing\n   * connections to any inputs to the node. The default value is 2 except for\n   * specific nodes where its value is specially determined.\n   */\n\n\n  get channelCount() {\n    return this._getChannelProperties().channelCount;\n  }\n\n  set channelCount(channelCount) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCount\n    }));\n  }\n  /**\n   * channelCountMode determines how channels will be counted when up-mixing and\n   * down-mixing connections to any inputs to the node.\n   * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n   * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n   * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n   * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n   */\n\n\n  get channelCountMode() {\n    return this._getChannelProperties().channelCountMode;\n  }\n\n  set channelCountMode(channelCountMode) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCountMode\n    }));\n  }\n  /**\n   * channelInterpretation determines how individual channels will be treated\n   * when up-mixing and down-mixing connections to any inputs to the node.\n   * The default value is \"speakers\".\n   */\n\n\n  get channelInterpretation() {\n    return this._getChannelProperties().channelInterpretation;\n  }\n\n  set channelInterpretation(channelInterpretation) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelInterpretation\n    }));\n  } //-------------------------------------\n  // CONNECTIONS\n  //-------------------------------------\n\n  /**\n   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n   * @param destination The output to connect to\n   * @param outputNum The output to connect from\n   * @param inputNum The input to connect to\n   */\n\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    connect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * @example\n   * const osc = new Tone.Oscillator().start();\n   * osc.toDestination();\n   */\n\n\n  toDestination() {\n    this.connect(this.context.destination);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * See [[toDestination]]\n   * @deprecated\n   */\n\n\n  toMaster() {\n    warn(\"toMaster() has been renamed toDestination()\");\n    return this.toDestination();\n  }\n  /**\n   * disconnect the output\n   */\n\n\n  disconnect(destination, outputNum = 0, inputNum = 0) {\n    disconnect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output of this node to the rest of the nodes in series.\n   * @example\n   * const osc = new Tone.Oscillator().start();\n   * const filter = new Tone.Filter();\n   * const volume = new Tone.Volume(-8);\n   * // connect a node to the filter, volume and then to the master output\n   * osc.chain(filter, volume, Tone.Destination);\n   */\n\n\n  chain(...nodes) {\n    connectSeries(this, ...nodes);\n    return this;\n  }\n  /**\n   * connect the output of this node to the rest of the nodes in parallel.\n   */\n\n\n  fan(...nodes) {\n    nodes.forEach(node => this.connect(node));\n    return this;\n  }\n  /**\n   * Dispose and disconnect\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (isDefined(this.input)) {\n      if (this.input instanceof ToneAudioNode) {\n        this.input.dispose();\n      } else if (isAudioNode(this.input)) {\n        this.input.disconnect();\n      }\n    }\n\n    if (isDefined(this.output)) {\n      if (this.output instanceof ToneAudioNode) {\n        this.output.dispose();\n      } else if (isAudioNode(this.output)) {\n        this.output.disconnect();\n      }\n    }\n\n    this._internalChannels = [];\n    return this;\n  }\n\n} //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries(...nodes) {\n  const first = nodes.shift();\n  nodes.reduce((prev, current) => {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @offline 0.7 1\n * @example\n * const gainNode = new Tone.Gain(0).toDestination();\n * const osc = new Tone.Oscillator().connect(gainNode);\n * gainNode.gain.rampTo(1, 0.1);\n * gainNode.gain.rampTo(0, 0.4, 0.2);\n */\n\nexport class Gain extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n    this.name = \"Gain\";\n    /**\n     * The wrapped GainNode.\n     */\n\n    this._gainNode = this.context.createGain(); // input = output\n\n    this.input = this._gainNode;\n    this.output = this._gainNode;\n    const options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n    this.gain = new Param({\n      context: this.context,\n      convert: options.convert,\n      param: this._gainNode.gain,\n      units: options.units,\n      value: options.gain,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n    readOnly(this, \"gain\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      convert: true,\n      gain: 1,\n      units: \"gain\"\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._gainNode.disconnect();\n\n    this.gain.dispose();\n    return this;\n  }\n\n}","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Base class for fire-and-forget nodes\n */\n\nexport class OneShotSource extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * The callback to invoke after the\n     * source is done playing.\n     */\n\n    this.onended = noOp;\n    /**\n     * The start time\n     */\n\n    this._startTime = -1;\n    /**\n     * The stop time\n     */\n\n    this._stopTime = -1;\n    /**\n     * The id of the timeout\n     */\n\n    this._timeout = -1;\n    /**\n     * The public output node\n     */\n\n    this.output = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The output gain node.\n     */\n\n    this._gainNode = this.output;\n    /**\n     * Get the playback state at the given time\n     */\n\n    this.getStateAtTime = function (time) {\n      const computedTime = this.toSeconds(time);\n\n      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {\n        return \"started\";\n      } else {\n        return \"stopped\";\n      }\n    };\n\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n    this._curve = options.curve;\n    this.onended = options.onended;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      curve: \"linear\",\n      fadeIn: 0,\n      fadeOut: 0,\n      onended: noOp\n    });\n  }\n  /**\n   * Start the source at the given time\n   * @param  time When to start the source\n   */\n\n\n  _startGain(time, gain = 1) {\n    assert(this._startTime === -1, \"Source cannot be started more than once\"); // apply a fade in envelope\n\n    const fadeInTime = this.toSeconds(this._fadeIn); // record the start time\n\n    this._startTime = time + fadeInTime;\n    this._startTime = Math.max(this._startTime, this.context.currentTime); // schedule the envelope\n\n    if (fadeInTime > 0) {\n      this._gainNode.gain.setValueAtTime(0, time);\n\n      if (this._curve === \"linear\") {\n        this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n      } else {\n        this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n      }\n    } else {\n      this._gainNode.gain.setValueAtTime(gain, time);\n    }\n\n    return this;\n  }\n  /**\n   * Stop the source node at the given time.\n   * @param time When to stop the source\n   */\n\n\n  stop(time) {\n    this.log(\"stop\", time);\n\n    this._stopGain(this.toSeconds(time));\n\n    return this;\n  }\n  /**\n   * Stop the source at the given time\n   * @param  time When to stop the source\n   */\n\n\n  _stopGain(time) {\n    assert(this._startTime !== -1, \"'start' must be called before 'stop'\"); // cancel the previous stop\n\n    this.cancelStop(); // the fadeOut time\n\n    const fadeOutTime = this.toSeconds(this._fadeOut); // schedule the stop callback\n\n    this._stopTime = this.toSeconds(time) + fadeOutTime;\n    this._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\n    if (fadeOutTime > 0) {\n      // start the fade out curve at the given time\n      if (this._curve === \"linear\") {\n        this._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n      } else {\n        this._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n      }\n    } else {\n      // stop any ongoing ramps, and set the value to 0\n      this._gainNode.gain.cancelAndHoldAtTime(time);\n\n      this._gainNode.gain.setValueAtTime(0, time);\n    }\n\n    this.context.clearTimeout(this._timeout);\n    this._timeout = this.context.setTimeout(() => {\n      // allow additional time for the exponential curve to fully decay\n      const additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\n      this._stopSource(this.now() + additionalTail);\n\n      this._onended();\n    }, this._stopTime - this.context.currentTime);\n    return this;\n  }\n  /**\n   * Invoke the onended callback\n   */\n\n\n  _onended() {\n    if (this.onended !== noOp) {\n      this.onended(this); // overwrite onended to make sure it only is called once\n\n      this.onended = noOp; // dispose when it's ended to free up for garbage collection only in the online context\n\n      if (!this.context.isOffline) {\n        setTimeout(() => this.dispose(), 1000);\n      }\n    }\n  }\n  /**\n   * Get the playback state at the current time\n   */\n\n\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Cancel a scheduled stop event\n   */\n\n\n  cancelStop() {\n    this.log(\"cancelStop\");\n    assert(this._startTime !== -1, \"Source is not started\"); // cancel the stop envelope\n\n    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\n    this.context.clearTimeout(this._timeout);\n    this._stopTime = -1;\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._gainNode.disconnect();\n\n    return this;\n  }\n\n}","import { connect } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource } from \"../source/OneShotSource\";\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\n\nexport class ToneConstantSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n    this.name = \"ToneConstantSource\";\n    /**\n     * The signal generator\n     */\n\n    this._source = this.context.createConstantSource();\n    const options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n    connect(this._source, this._gainNode);\n    this.offset = new Param({\n      context: this.context,\n      convert: options.convert,\n      param: this._source.offset,\n      units: options.units,\n      value: options.offset,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      convert: true,\n      offset: 1,\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the source node at the given time\n   * @param  time When to start the source\n   */\n\n\n  start(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    this._startGain(computedTime);\n\n    this._source.start(computedTime);\n\n    return this;\n  }\n\n  _stopSource(time) {\n    this._source.stop(time);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this.state === \"started\") {\n      this.stop();\n    }\n\n    this._source.disconnect();\n\n    this.offset.dispose();\n    return this;\n  }\n\n}","import { Param } from \"../core/context/Param\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\n\nexport class Signal extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    this.name = \"Signal\";\n    /**\n     * Indicates if the value should be overridden on connection.\n     */\n\n    this.override = true;\n    const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    this.output = this._constantSource = new ToneConstantSource({\n      context: this.context,\n      convert: options.convert,\n      offset: options.value,\n      units: options.units,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n\n    this._constantSource.start(0);\n\n    this.input = this._param = this._constantSource.offset;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      convert: true,\n      units: \"number\",\n      value: 0\n    });\n  }\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    // start it only when connected to something\n    connectSignal(this, destination, outputNum, inputNum);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._param.dispose();\n\n    this._constantSource.dispose();\n\n    return this;\n  } //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // just a proxy for the ConstantSourceNode's offset AudioParam\n  // all docs are generated from AbstractParam.ts\n  //-------------------------------------\n\n\n  setValueAtTime(value, time) {\n    this._param.setValueAtTime(value, time);\n\n    return this;\n  }\n\n  getValueAtTime(time) {\n    return this._param.getValueAtTime(time);\n  }\n\n  setRampPoint(time) {\n    this._param.setRampPoint(time);\n\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    this._param.linearRampToValueAtTime(value, time);\n\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    this._param.exponentialRampToValueAtTime(value, time);\n\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    this._param.exponentialRampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    this._param.linearRampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    this._param.targetRampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    this._param.exponentialApproachValueAtTime(value, time, rampTime);\n\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    this._param.setTargetAtTime(value, startTime, timeConstant);\n\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling) {\n    this._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\n    return this;\n  }\n\n  cancelScheduledValues(time) {\n    this._param.cancelScheduledValues(time);\n\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    this._param.cancelAndHoldAtTime(time);\n\n    return this;\n  }\n\n  rampTo(value, rampTime, startTime) {\n    this._param.rampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  get value() {\n    return this._param.value;\n  }\n\n  set value(value) {\n    this._param.value = value;\n  }\n\n  get convert() {\n    return this._param.convert;\n  }\n\n  set convert(convert) {\n    this._param.convert = convert;\n  }\n\n  get units() {\n    return this._param.units;\n  }\n\n  get overridden() {\n    return this._param.overridden;\n  }\n\n  set overridden(overridden) {\n    this._param.overridden = overridden;\n  }\n\n  get maxValue() {\n    return this._param.maxValue;\n  }\n\n  get minValue() {\n    return this._param.minValue;\n  }\n  /**\n   * See [[Param.apply]].\n   */\n\n\n  apply(param) {\n    this._param.apply(param);\n\n    return this;\n  }\n\n}\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\n\nexport function connectSignal(signal, destination, outputNum, inputNum) {\n  if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {\n    // cancel changes\n    destination.cancelScheduledValues(0); // reset the value\n\n    destination.setValueAtTime(0, 0); // mark the value as overridden\n\n    if (destination instanceof Signal) {\n      destination.overridden = true;\n    }\n  }\n\n  connect(signal, destination, outputNum, inputNum);\n}","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\n\nexport class TickParam extends Param {\n  constructor() {\n    super(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n    this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n\n    this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n\n    this._multiplier = 1;\n    const options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]); // set the multiplier\n\n    this._multiplier = options.multiplier; // clear the ticks from the beginning\n\n    this._events.cancel(0); // set an initial event\n\n\n    this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: this._fromType(options.value)\n    });\n\n    this.setValueAtTime(options.value, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign(Param.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  }\n\n  setTargetAtTime(value, time, constant) {\n    // approximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    this.setRampPoint(time);\n\n    const computedValue = this._fromType(value); // start from previously scheduled value\n\n\n    const prevEvent = this._events.get(time);\n\n    const segments = Math.round(Math.max(1 / constant, 1));\n\n    for (let i = 0; i <= segments; i++) {\n      const segTime = constant * i + time;\n\n      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  }\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.setValueAtTime(value, time);\n\n    const event = this._events.get(computedTime);\n\n    const previousEvent = this._events.previousEvent(event);\n\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.linearRampToValueAtTime(value, time);\n\n    const event = this._events.get(computedTime);\n\n    const previousEvent = this._events.previousEvent(event);\n\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    // aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n\n    const computedVal = this._fromType(value); // start from previously scheduled value\n\n\n    const prevEvent = this._events.get(time); // approx 10 segments per second\n\n\n    const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n    const segmentDur = (time - prevEvent.time) / segments;\n\n    for (let i = 0; i <= segments; i++) {\n      const segTime = segmentDur * i + prevEvent.time;\n\n      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  event The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  _getTicksUntilEvent(event, time) {\n    if (event === null) {\n      event = {\n        ticks: 0,\n        time: 0,\n        type: \"setValueAtTime\",\n        value: 0\n      };\n    } else if (isUndef(event.ticks)) {\n      const previousEvent = this._events.previousEvent(event);\n\n      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n    }\n\n    const val0 = this._fromType(this.getValueAtTime(event.time));\n\n    let val1 = this._fromType(this.getValueAtTime(time)); // if it's right on the line, take the previous value\n\n\n    const onTheLineEvent = this._events.get(time);\n\n    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n    }\n\n    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  time The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const event = this._events.get(computedTime);\n\n    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n  }\n  /**\n   * Return the elapsed time of the number of ticks from the given time\n   * @param ticks The number of ticks to calculate\n   * @param  time The time to get the next tick from\n   * @return The duration of the number of ticks from the given time in seconds\n   */\n\n\n  getDurationOfTicks(ticks, time) {\n    const computedTime = this.toSeconds(time);\n    const currentTick = this.getTicksAtTime(time);\n    return this.getTimeOfTick(currentTick + ticks) - computedTime;\n  }\n  /**\n   * Given a tick, returns the time that tick occurs at.\n   * @return The time that the tick occurs.\n   */\n\n\n  getTimeOfTick(tick) {\n    const before = this._events.get(tick, \"ticks\");\n\n    const after = this._events.getAfter(tick, \"ticks\");\n\n    if (before && before.ticks === tick) {\n      return before.time;\n    } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n      const val0 = this._fromType(this.getValueAtTime(before.time));\n\n      const val1 = this._fromType(this.getValueAtTime(after.time));\n\n      const delta = (val1 - val0) / (after.time - before.time);\n      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n      const sol1 = (-val0 + k) / delta;\n      const sol2 = (-val0 - k) / delta;\n      return (sol1 > 0 ? sol1 : sol2) + before.time;\n    } else if (before) {\n      if (before.value === 0) {\n        return Infinity;\n      } else {\n        return before.time + (tick - before.ticks) / before.value;\n      }\n    } else {\n      return tick / this._initialValue;\n    }\n  }\n  /**\n   * Convert some number of ticks their the duration in seconds accounting\n   * for any automation curves starting at the given time.\n   * @param  ticks The number of ticks to convert to seconds.\n   * @param  when  When along the automation timeline to convert the ticks.\n   * @return The duration in seconds of the ticks.\n   */\n\n\n  ticksToTime(ticks, when) {\n    return this.getDurationOfTicks(ticks, when);\n  }\n  /**\n   * The inverse of [[ticksToTime]]. Convert a duration in\n   * seconds to the corresponding number of ticks accounting for any\n   * automation curves starting at the given time.\n   * @param  duration The time interval to convert to ticks.\n   * @param  when When along the automation timeline to convert the ticks.\n   * @return The duration in ticks.\n   */\n\n\n  timeToTicks(duration, when) {\n    const computedTime = this.toSeconds(when);\n    const computedDuration = this.toSeconds(duration);\n    const startTicks = this.getTicksAtTime(computedTime);\n    const endTicks = this.getTicksAtTime(computedTime + computedDuration);\n    return endTicks - startTicks;\n  }\n  /**\n   * Convert from the type when the unit value is BPM\n   */\n\n\n  _fromType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return 1 / (60 / val / this.multiplier);\n    } else {\n      return super._fromType(val);\n    }\n  }\n  /**\n   * Special case of type conversion where the units === \"bpm\"\n   */\n\n\n  _toType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return val / this.multiplier * 60;\n    } else {\n      return super._toType(val);\n    }\n  }\n  /**\n   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n   */\n\n\n  get multiplier() {\n    return this._multiplier;\n  }\n\n  set multiplier(m) {\n    // get and reset the current value with the new multiplier\n    // might be necessary to clear all the previous values\n    const currentVal = this.value;\n    this._multiplier = m;\n    this.cancelScheduledValues(0);\n    this.setValueAtTime(currentVal, 0);\n  }\n\n}","import { Signal } from \"../../signal/Signal\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\n\nexport class TickSignal extends Signal {\n  constructor() {\n    super(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n    this.name = \"TickSignal\";\n    const options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n    this.input = this._param = new TickParam({\n      context: this.context,\n      convert: options.convert,\n      multiplier: options.multiplier,\n      param: this._constantSource.offset,\n      units: options.units,\n      value: options.value\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  }\n\n  ticksToTime(ticks, when) {\n    return this._param.ticksToTime(ticks, when);\n  }\n\n  timeToTicks(duration, when) {\n    return this._param.timeToTicks(duration, when);\n  }\n\n  getTimeOfTick(tick) {\n    return this._param.getTimeOfTick(tick);\n  }\n\n  getDurationOfTicks(ticks, time) {\n    return this._param.getDurationOfTicks(ticks, time);\n  }\n\n  getTicksAtTime(time) {\n    return this._param.getTicksAtTime(time);\n  }\n  /**\n   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n   */\n\n\n  get multiplier() {\n    return this._param.multiplier;\n  }\n\n  set multiplier(m) {\n    this._param.multiplier = m;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._param.dispose();\n\n    return this;\n  }\n\n}","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\"); // set the initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    this.setTicksAtTime(0, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n\n\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time); // cancel the previous stop\n\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n\n        this._state.cancel(event.time);\n      }\n    }\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n\n\n  cancel(time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._tickOffset.cancel(time);\n\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedTicks = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n\n\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n\n\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedSeconds = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n\n    this._tickOffset.cancel(time);\n\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick, before = this.now()) {\n    const offset = this._tickOffset.get(before);\n\n    const event = this._state.get(before);\n\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n\n\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n\n      lastStateEvent = event;\n    });\n\n    let error = null;\n\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n\n    if (error) {\n      throw error;\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._state.dispose();\n\n    this._tickOffset.dispose();\n\n    this.frequency.dispose();\n    return this;\n  }\n\n}","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nexport class Clock extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    this._boundLoop = this._loop.bind(this);\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\"); // add an initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    this.context.on(\"tick\", this._boundLoop);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n\n\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context); // start the loop\n\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this._tickSource.start(computedTime, offset);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this._tickSource.stop(computedTime);\n\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n\n      this._tickSource.pause(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n\n\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n\n\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick, before = this.now()) {\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n\n\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n\n\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n\n            this.emit(\"start\", e.time, offset);\n            break;\n\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n\n            break;\n\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      }); // the tick callbacks\n\n\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n\n\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n\n    this._tickSource.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Clock);","import { Timeline } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\n\nexport class TimelineValue extends Tone {\n  /**\n   * @param initialValue The value to return if there is no scheduled values\n   */\n  constructor(initialValue) {\n    super();\n    this.name = \"TimelineValue\";\n    /**\n     * The timeline which stores the values\n     */\n\n    this._timeline = new Timeline({\n      memory: 10\n    });\n    this._initialValue = initialValue;\n  }\n  /**\n   * Set the value at the given time\n   */\n\n\n  set(value, time) {\n    this._timeline.add({\n      value,\n      time\n    });\n\n    return this;\n  }\n  /**\n   * Get the value at the given time\n   */\n\n\n  get(time) {\n    const event = this._timeline.get(time);\n\n    if (event) {\n      return event.value;\n    } else {\n      return this._initialValue;\n    }\n  }\n\n}","import { getContext } from \"../Global\";\nimport { TransportTimeClass } from \"./TransportTime\";\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\n\nexport class TicksClass extends TransportTimeClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"Ticks\";\n    this.defaultUnits = \"i\";\n  }\n  /**\n   * Get the current time in the given units\n   */\n\n\n  _now() {\n    return this.context.transport.ticks;\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return this._getPPQ() * beats;\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ticks;\n  }\n  /**\n   * Return the time in ticks\n   */\n\n\n  toTicks() {\n    return this.valueOf();\n  }\n  /**\n   * Return the time in seconds\n   */\n\n\n  toSeconds() {\n    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());\n  }\n\n}\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\n\nexport function Ticks(value, units) {\n  return new TicksClass(getContext(), value, units);\n}","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\n\nexport class IntervalTimeline extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n\n    this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n\n    this._length = 0;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n\n\n  add(event) {\n    assert(isDefined(event.time), \"Events must have a time property\");\n    assert(isDefined(event.duration), \"Events must have a duration parameter\");\n    event.time = event.time.valueOf();\n    let node = new IntervalNode(event.time, event.time + event.duration, event);\n\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n\n    this._length++; // Restructure tree to be balanced\n\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n\n      this._rebalance(node);\n\n      node = node.parent;\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  event  The event to remove from the timeline\n   */\n\n\n  remove(event) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(event.time, results);\n\n      for (const node of results) {\n        if (node.event === event) {\n          this._removeNode(node);\n\n          this._length--;\n          break;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of items in the timeline.\n   * @readOnly\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Remove events whose time time is after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    this.forEachFrom(after, event => this.remove(event));\n    return this;\n  }\n  /**\n   * Set the root node as the given node\n   */\n\n\n  _setRoot(node) {\n    this._root = node;\n\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  }\n  /**\n   * Replace the references to the node in the node's parent\n   * with the replacement node.\n   */\n\n\n  _replaceNodeInParent(node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  }\n  /**\n   * Remove the node from the tree and replace it with\n   * a successor which follows the schema.\n   */\n\n\n  _removeNode(node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      const balance = node.getBalance();\n      let replacement;\n      let temp = null;\n\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n\n          if (replacement.parent) {\n            replacement.parent.right = replacement.left;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n\n        if (replacement.parent) {\n          replacement.parent.left = replacement.right;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      }\n\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      }\n\n      if (temp) {\n        this._rebalance(temp);\n      }\n    }\n\n    node.dispose();\n  }\n  /**\n   * Rotate the tree to the left\n   */\n\n\n  _rotateLeft(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)\n\n    const pivotNode = node.right;\n\n    if (pivotNode) {\n      node.right = pivotNode.left;\n      pivotNode.left = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Rotate the tree to the right\n   */\n\n\n  _rotateRight(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)\n\n    const pivotNode = node.left;\n\n    if (pivotNode) {\n      node.left = pivotNode.right;\n      pivotNode.right = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Balance the BST\n   */\n\n\n  _rebalance(node) {\n    const balance = node.getBalance();\n\n    if (balance > 1 && node.left) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1 && node.right) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  }\n  /**\n   * Get an event whose time and duration span the give time. Will\n   * return the match whose \"time\" value is closest to the given time.\n   * @return  The event which spans the desired time\n   */\n\n\n  get(time) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      if (results.length > 0) {\n        let max = results[0];\n\n        for (let i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n\n        return max.event;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Iterate over everything in the timeline.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    if (this._root !== null) {\n      const allNodes = [];\n\n      this._root.traverse(node => allNodes.push(node));\n\n      allNodes.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the given time\n   * overlaps with the time and duration time of the event.\n   * @param  time The time to check if items are overlapping\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the time is greater\n   * than or equal to the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.searchAfter(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._root !== null) {\n      this._root.traverse(node => node.dispose());\n    }\n\n    this._root = null;\n    return this;\n  }\n\n} //-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\n\nclass IntervalNode {\n  constructor(low, high, event) {\n    // the nodes to the left\n    this._left = null; // the nodes to the right\n\n    this._right = null; // the parent node\n\n    this.parent = null; // the number of child nodes\n\n    this.height = 0;\n    this.event = event; // the low value\n\n    this.low = low; // the high value\n\n    this.high = high; // the high value for this and all child nodes\n\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n\n\n  insert(node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  }\n  /**\n   * Search the tree for nodes which overlap\n   * with the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  search(point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    } // Search left children\n\n\n    if (this.left !== null) {\n      this.left.search(point, results);\n    } // Check this node\n\n\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    } // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n\n\n    if (this.low > point) {\n      return;\n    } // Search right children\n\n\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  }\n  /**\n   * Search the tree for nodes which are less\n   * than the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  searchAfter(point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    } // search the right side\n\n\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  }\n  /**\n   * Invoke the callback on this element and both it's branches\n   * @param  {Function}  callback\n   */\n\n\n  traverse(callback) {\n    callback(this);\n\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateHeight() {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateMax() {\n    this.max = this.high;\n\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  }\n  /**\n   * The balance is how the leafs are distributed on the node\n   * @return  Negative numbers are balanced to the right\n   */\n\n\n  getBalance() {\n    let balance = 0;\n\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n\n    return balance;\n  }\n  /**\n   * @returns true if this node is the left child of its parent\n   */\n\n\n  isLeftChild() {\n    return this.parent !== null && this.parent.left === this;\n  }\n  /**\n   * get/set the left node\n   */\n\n\n  get left() {\n    return this._left;\n  }\n\n  set left(node) {\n    this._left = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * get/set the right node\n   */\n\n\n  get right() {\n    return this._right;\n  }\n\n  set right(node) {\n    this._right = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * null out references.\n   */\n\n\n  dispose() {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  }\n\n}","import { noOp } from \"../util/Interface\";\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\n\nexport class TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    /**\n     * The unique id of the event\n     */\n    this.id = TransportEvent._eventId++;\n    const options = Object.assign(TransportEvent.getDefaults(), opts);\n    this.transport = transport;\n    this.callback = options.callback;\n    this._once = options.once;\n    this.time = options.time;\n  }\n\n  static getDefaults() {\n    return {\n      callback: noOp,\n      once: false,\n      time: 0\n    };\n  }\n  /**\n   * Invoke the event callback.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n\n\n  invoke(time) {\n    if (this.callback) {\n      this.callback(time);\n\n      if (this._once) {\n        this.transport.clear(this.id);\n      }\n    }\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    this.callback = undefined;\n    return this;\n  }\n\n}\n/**\n * Current ID counter\n */\n\nTransportEvent._eventId = 0;","import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\n\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = new TicksClass(transport.context, options.duration).valueOf();\n    this._interval = new TicksClass(transport.context, options.interval).valueOf();\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.context = this.transport.context;\n\n    this._restart();\n  }\n\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n\n\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time); // call the super class\n\n\n    super.invoke(time);\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _createEvents(time) {\n    // schedule the next event\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this._nextTick = this.time;\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n\n    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    this._nextTick += this._interval;\n    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    return this;\n  }\n\n}","import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\n\nexport class Transport extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Transport.getDefaults(), arguments));\n    this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    this._swingAmount = 0;\n    const options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    this._ppq = options.ppq;\n    this._clock = new Clock({\n      callback: this._processTick.bind(this),\n      context: this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    this._bindClockEvents();\n\n    this.bpm = this._clock.frequency;\n    this._clock.frequency.multiplier = options.ppq;\n    this.bpm.setValueAtTime(options.bpm, 0);\n    readOnly(this, \"bpm\");\n    this._timeSignature = options.timeSignature; // SWING\n\n    this._swingTicks = options.ppq / 2; // 8n\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      bpm: 120,\n      loopEnd: \"4m\",\n      loopStart: 0,\n      ppq: 192,\n      swing: 0,\n      swingSubdivision: \"8n\",\n      timeSignature: 4\n    });\n  } //-------------------------------------\n  // \tTICKS\n  //-------------------------------------\n\n  /**\n   * called on every tick\n   * @param  tickTime clock relative tick time\n   */\n\n\n  _processTick(tickTime, ticks) {\n    // handle swing\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      // add some swing\n      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n      const amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n    } // do the loop test\n\n\n    if (this._loop.get(tickTime)) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    } // invoke the timeline events scheduled on this tick\n\n\n    this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n  } //-------------------------------------\n  // \tSCHEDULABLE EVENTS\n  //-------------------------------------\n\n  /**\n   * Schedule an event along the timeline.\n   * @param callback The callback to be invoked at the time.\n   * @param time The time to invoke the callback at.\n   * @return The id of the event which can be used for canceling the event.\n   * @example\n   * // schedule an event on the 16th measure\n   * Tone.Transport.schedule((time) => {\n   * \t// invoked on measure 16\n   * \tconsole.log(\"measure 16!\");\n   * }, \"16:0:0\");\n   */\n\n\n  schedule(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Schedule a repeated event along the timeline. The event will fire\n   * at the `interval` starting at the `startTime` and for the specified\n   * `duration`.\n   * @param  callback   The callback to invoke.\n   * @param  interval   The duration between successive callbacks. Must be a positive number.\n   * @param  startTime  When along the timeline the events should start being invoked.\n   * @param  duration How long the event should repeat.\n   * @return  The ID of the scheduled event. Use this to cancel the event.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // a callback invoked every eighth note after the first measure\n   * Tone.Transport.scheduleRepeat((time) => {\n   * \tosc.start(time).stop(time + 0.1);\n   * }, \"8n\", \"1m\");\n   */\n\n\n  scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n    const event = new TransportRepeatEvent(this, {\n      callback,\n      duration: new TimeClass(this.context, duration).toTicks(),\n      interval: new TimeClass(this.context, interval).toTicks(),\n      time: new TransportTimeClass(this.context, startTime).toTicks()\n    }); // kick it off if the Transport is started\n    // @ts-ignore\n\n    return this._addEvent(event, this._repeatedEvents);\n  }\n  /**\n   * Schedule an event that will be removed after it is invoked.\n   * @param callback The callback to invoke once.\n   * @param time The time the callback should be invoked.\n   * @returns The ID of the scheduled event.\n   */\n\n\n  scheduleOnce(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      once: true,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Clear the passed in event id from the timeline\n   * @param eventId The id of the event.\n   */\n\n\n  clear(eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      const item = this._scheduledEvents[eventId.toString()];\n\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n\n    return this;\n  }\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @returns the event id which was just added\n   */\n\n\n  _addEvent(event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      event,\n      timeline\n    };\n    timeline.add(event);\n    return event.id;\n  }\n  /**\n   * Remove scheduled events from the timeline after\n   * the given time. Repeated events will be removed\n   * if their startTime is after the given time\n   * @param after Clear all events after this time.\n   */\n\n\n  cancel(after = 0) {\n    const computedAfter = this.toTicks(after);\n\n    this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    return this;\n  } //-------------------------------------\n  // \tSTART/STOP/PAUSE\n  //-------------------------------------\n\n  /**\n   * Bind start/stop/pause events from the clock and emit them.\n   */\n\n\n  _bindClockEvents() {\n    this._clock.on(\"start\", (time, offset) => {\n      offset = new TicksClass(this.context, offset).toSeconds();\n      this.emit(\"start\", time, offset);\n    });\n\n    this._clock.on(\"stop\", time => {\n      this.emit(\"stop\", time);\n    });\n\n    this._clock.on(\"pause\", time => {\n      this.emit(\"pause\", time);\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n   */\n\n\n  get state() {\n    return this._clock.getStateAtTime(this.now());\n  }\n  /**\n   * Start the transport and all sources synced to the transport.\n   * @param  time The time when the transport should start.\n   * @param  offset The timeline offset to start the transport.\n   * @example\n   * // start the transport in one second starting at beginning of the 5th measure.\n   * Tone.Transport.start(\"+1\", \"4:0:0\");\n   */\n\n\n  start(time, offset) {\n    let offsetTicks;\n\n    if (isDefined(offset)) {\n      offsetTicks = this.toTicks(offset);\n    } // start the clock\n\n\n    this._clock.start(time, offsetTicks);\n\n    return this;\n  }\n  /**\n   * Stop the transport and all sources synced to the transport.\n   * @param time The time when the transport should stop.\n   * @example\n   * Tone.Transport.stop();\n   */\n\n\n  stop(time) {\n    this._clock.stop(time);\n\n    return this;\n  }\n  /**\n   * Pause the transport and all sources synced to the transport.\n   */\n\n\n  pause(time) {\n    this._clock.pause(time);\n\n    return this;\n  }\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  time The time of the event\n   */\n\n\n  toggle(time) {\n    time = this.toSeconds(time);\n\n    if (this._clock.getStateAtTime(time) !== \"started\") {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n\n    return this;\n  } //-------------------------------------\n  // \tSETTERS/GETTERS\n  //-------------------------------------\n\n  /**\n   * The time signature as just the numerator over 4.\n   * For example 4/4 would be just 4 and 6/8 would be 3.\n   * @example\n   * // common time\n   * Tone.Transport.timeSignature = 4;\n   * // 7/8\n   * Tone.Transport.timeSignature = [7, 8];\n   * // this will be reduced to a single number\n   * Tone.Transport.timeSignature; // returns 3.5\n   */\n\n\n  get timeSignature() {\n    return this._timeSignature;\n  }\n\n  set timeSignature(timeSig) {\n    if (isArray(timeSig)) {\n      timeSig = timeSig[0] / timeSig[1] * 4;\n    }\n\n    this._timeSignature = timeSig;\n  }\n  /**\n   * When the Transport.loop = true, this is the starting position of the loop.\n   */\n\n\n  get loopStart() {\n    return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n  }\n\n  set loopStart(startPosition) {\n    this._loopStart = this.toTicks(startPosition);\n  }\n  /**\n   * When the Transport.loop = true, this is the ending position of the loop.\n   */\n\n\n  get loopEnd() {\n    return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n  }\n\n  set loopEnd(endPosition) {\n    this._loopEnd = this.toTicks(endPosition);\n  }\n  /**\n   * If the transport loops or not.\n   */\n\n\n  get loop() {\n    return this._loop.get(this.now());\n  }\n\n  set loop(loop) {\n    this._loop.set(loop, this.now());\n  }\n  /**\n   * Set the loop start and stop at the same time.\n   * @example\n   * // loop over the first measure\n   * Tone.Transport.setLoopPoints(0, \"1m\");\n   * Tone.Transport.loop = true;\n   */\n\n\n  setLoopPoints(startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  }\n  /**\n   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n   */\n\n\n  get swing() {\n    return this._swingAmount;\n  }\n\n  set swing(amount) {\n    // scale the values to a normal range\n    this._swingAmount = amount;\n  }\n  /**\n   * Set the subdivision which the swing will be applied to.\n   * The default value is an 8th note. Value must be less\n   * than a quarter note.\n   */\n\n\n  get swingSubdivision() {\n    return new TicksClass(this.context, this._swingTicks).toNotation();\n  }\n\n  set swingSubdivision(subdivision) {\n    this._swingTicks = this.toTicks(subdivision);\n  }\n  /**\n   * The Transport's position in Bars:Beats:Sixteenths.\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get position() {\n    const now = this.now();\n\n    const ticks = this._clock.getTicksAtTime(now);\n\n    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n  }\n\n  set position(progress) {\n    const ticks = this.toTicks(progress);\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's position in seconds\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get seconds() {\n    return this._clock.seconds;\n  }\n\n  set seconds(s) {\n    const now = this.now();\n\n    const ticks = this._clock.frequency.timeToTicks(s, now);\n\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's loop position as a normalized value. Always\n   * returns 0 if the transport if loop is not true.\n   */\n\n\n  get progress() {\n    if (this.loop) {\n      const now = this.now();\n\n      const ticks = this._clock.getTicksAtTime(now);\n\n      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The transports current tick position.\n   */\n\n\n  get ticks() {\n    return this._clock.ticks;\n  }\n\n  set ticks(t) {\n    if (this._clock.ticks !== t) {\n      const now = this.now(); // stop everything synced to the transport\n\n      if (this.state === \"started\") {\n        const ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n        const time = this._clock.getTimeOfTick(Math.ceil(ticks));\n\n        this.emit(\"stop\", time);\n\n        this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n        this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n      } else {\n        this._clock.setTicksAtTime(t, now);\n      }\n    }\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return Math.round(this._clock.getTicksAtTime(time));\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._clock.getSecondsAtTime(time);\n  }\n  /**\n   * Pulses Per Quarter note. This is the smallest resolution\n   * the Transport timing supports. This should be set once\n   * on initialization and not set again. Changing this value\n   * after other objects have been created can cause problems.\n   */\n\n\n  get PPQ() {\n    return this._clock.frequency.multiplier;\n  }\n\n  set PPQ(ppq) {\n    this._clock.frequency.multiplier = ppq;\n  } //-------------------------------------\n  // \tSYNCING\n  //-------------------------------------\n\n  /**\n   * Returns the time aligned to the next subdivision\n   * of the Transport. If the Transport is not started,\n   * it will return 0.\n   * Note: this will not work precisely during tempo ramps.\n   * @param  subdivision  The subdivision to quantize to\n   * @return  The context time of the next subdivision.\n   * @example\n   * // the transport must be started, otherwise returns 0\n   * Tone.Transport.start();\n   * Tone.Transport.nextSubdivision(\"4n\");\n   */\n\n\n  nextSubdivision(subdivision) {\n    subdivision = this.toTicks(subdivision);\n\n    if (this.state !== \"started\") {\n      // if the transport's not started, return 0\n      return 0;\n    } else {\n      const now = this.now(); // the remainder of the current ticks and the subdivision\n\n      const transportPos = this.getTicksAtTime(now);\n      const remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  }\n  /**\n   * Attaches the signal to the tempo control signal so that\n   * any changes in the tempo will change the signal in the same\n   * ratio.\n   *\n   * @param signal\n   * @param ratio Optionally pass in the ratio between the two signals.\n   * \t\t\tOtherwise it will be computed based on their current values.\n   */\n\n\n  syncSignal(signal, ratio) {\n    if (!ratio) {\n      // get the sync ratio\n      const now = this.now();\n\n      if (signal.getValueAtTime(now) !== 0) {\n        const bpm = this.bpm.getValueAtTime(now);\n        const computedFreq = 1 / (60 / bpm / this.PPQ);\n        ratio = signal.getValueAtTime(now) / computedFreq;\n      } else {\n        ratio = 0;\n      }\n    }\n\n    const ratioSignal = new Gain(ratio); // @ts-ignore\n\n    this.bpm.connect(ratioSignal); // @ts-ignore\n\n    ratioSignal.connect(signal._param);\n\n    this._syncedSignals.push({\n      initial: signal.value,\n      ratio: ratioSignal,\n      signal\n    });\n\n    signal.value = 0;\n    return this;\n  }\n  /**\n   * Unsyncs a previously synced signal from the transport's control.\n   * See Transport.syncSignal.\n   */\n\n\n  unsyncSignal(signal) {\n    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n      const syncedSignal = this._syncedSignals[i];\n\n      if (syncedSignal.signal === signal) {\n        syncedSignal.ratio.dispose();\n        syncedSignal.signal.value = syncedSignal.initial;\n\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._clock.dispose();\n\n    writable(this, \"bpm\");\n\n    this._timeline.dispose();\n\n    this._repeatedEvents.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.transport = new Transport({\n    context\n  });\n});\nonContextClose(context => {\n  context.transport.dispose();\n});","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\n\nexport class Volume extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"Volume\";\n    const options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n    this.input = this.output = new Gain({\n      context: this.context,\n      gain: options.volume,\n      units: \"decibels\"\n    });\n    this.volume = this.output.gain;\n    readOnly(this, \"volume\");\n    this._unmutedVolume = options.volume; // set the mute initially\n\n    this.mute = options.mute;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const vol = new Tone.Volume(-12).toDestination();\n   * const osc = new Tone.Oscillator().connect(vol).start();\n   * // mute the output\n   * vol.mute = true;\n   */\n\n\n  get mute() {\n    return this.volume.value === -Infinity;\n  }\n\n  set mute(mute) {\n    if (!this.mute && mute) {\n      this._unmutedVolume = this.volume.value; // maybe it should ramp here?\n\n      this.volume.value = -Infinity;\n    } else if (this.mute && !mute) {\n      this.volume.value = this._unmutedVolume;\n    }\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.volume.dispose();\n    return this;\n  }\n\n}","import { Volume } from \"../../component/channel/Volume\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { connectSeries, ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\n\nexport class Destination extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Destination.getDefaults(), arguments));\n    this.name = \"Destination\";\n    this.input = new Volume({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    /**\n     * The volume of the master output.\n     */\n\n    this.volume = this.input.volume;\n    const options = optionsFromArguments(Destination.getDefaults(), arguments);\n    connectSeries(this.input, this.output, this.context.rawContext.destination);\n    this.mute = options.mute;\n    this._internalChannels = [this.input, this.context.rawContext.destination, this.output];\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const oscillator = new Tone.Oscillator().start().toDestination();\n   * setTimeout(() => {\n   * \t// mute the output\n   * \tTone.Destination.mute = true;\n   * }, 1000);\n   */\n\n\n  get mute() {\n    return this.input.mute;\n  }\n\n  set mute(mute) {\n    this.input.mute = mute;\n  }\n  /**\n   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n   * chained in the master effects chain.\n   * @param args All arguments will be connected in a row and the Master will be routed through it.\n   * @example\n   * // route all audio through a filter and compressor\n   * const lowpass = new Tone.Filter(800, \"lowpass\");\n   * const compressor = new Tone.Compressor(-18);\n   * Tone.Destination.chain(lowpass, compressor);\n   */\n\n\n  chain(...args) {\n    this.input.disconnect();\n    args.unshift(this.input);\n    args.push(this.output);\n    connectSeries(...args);\n    return this;\n  }\n  /**\n   * The maximum number of channels the system can output\n   * @example\n   * console.log(Tone.Destination.maxChannelCount);\n   */\n\n\n  get maxChannelCount() {\n    return this.context.rawContext.destination.maxChannelCount;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.volume.dispose();\n    return this;\n  }\n\n} //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.destination = new Destination({\n    context\n  });\n});\nonContextClose(context => {\n  context.destination.dispose();\n});","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\nimport { assert } from \"../util/Debug\";\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tC1: \"https://tonejs.github.io/examples/audio/casio/C1.mp3\",\n * \tC2: \"https://tonejs.github.io/examples/audio/casio/C2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t C1: \"C1.mp3\",\n * \t\t C2: \"C2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/examples/audio/casio/\"\n * });\n * @category Core\n */\n\nexport class ToneAudioBuffers extends Tone {\n  constructor() {\n    super();\n    this.name = \"ToneAudioBuffers\";\n    /**\n     * All of the buffers\n     */\n\n    this._buffers = new Map();\n    /**\n     * Keep track of the number of loaded buffers\n     */\n\n    this._loadingCount = 0;\n    const options = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    this.baseUrl = options.baseUrl; // add each one\n\n    Object.keys(options.urls).forEach(name => {\n      this._loadingCount++;\n      const url = options.urls[name];\n      this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);\n    });\n  }\n\n  static getDefaults() {\n    return {\n      baseUrl: \"\",\n      onerror: noOp,\n      onload: noOp,\n      urls: {}\n    };\n  }\n  /**\n   * True if the buffers object has a buffer by that name.\n   * @param  name  The key or index of the buffer.\n   */\n\n\n  has(name) {\n    return this._buffers.has(name.toString());\n  }\n  /**\n   * Get a buffer by name. If an array was loaded,\n   * then use the array index.\n   * @param  name  The key or index of the buffer.\n   */\n\n\n  get(name) {\n    assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n    return this._buffers.get(name.toString());\n  }\n  /**\n   * A buffer was loaded. decrement the counter.\n   */\n\n\n  _bufferLoaded(callback) {\n    this._loadingCount--;\n\n    if (this._loadingCount === 0 && callback) {\n      callback();\n    }\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n  }\n  /**\n   * Add a buffer by name and url to the Buffers\n   * @param  name      A unique name to give the buffer\n   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   * @param  onerror  Invoked if the buffer can't be loaded\n   */\n\n\n  add(name, url, callback = noOp, onerror = noOp) {\n    if (isString(url)) {\n      this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));\n    } else {\n      this._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));\n    }\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._buffers.forEach(buffer => buffer.dispose());\n\n    this._buffers.clear();\n\n    return this;\n  }\n\n}","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { Timeline } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\n\nexport class Draw extends ToneWithContext {\n  constructor() {\n    super(...arguments);\n    this.name = \"Draw\";\n    /**\n     * The duration after which events are not invoked.\n     */\n\n    this.expiration = 0.25;\n    /**\n     * The amount of time before the scheduled time\n     * that the callback can be invoked. Default is\n     * half the time of an animation frame (0.008 seconds).\n     */\n\n    this.anticipation = 0.008;\n    /**\n     * All of the events.\n     */\n\n    this._events = new Timeline();\n    /**\n     * The draw loop\n     */\n\n    this._boundDrawLoop = this._drawLoop.bind(this);\n    /**\n     * The animation frame id\n     */\n\n    this._animationFrame = -1;\n  }\n  /**\n   * Schedule a function at the given time to be invoked\n   * on the nearest animation frame.\n   * @param  callback  Callback is invoked at the given time.\n   * @param  time      The time relative to the AudioContext time to invoke the callback.\n   * @example\n   * Tone.Transport.scheduleRepeat(time => {\n   * \tTone.Draw.schedule(() => console.log(time), time);\n   * }, 1);\n   * Tone.Transport.start();\n   */\n\n\n  schedule(callback, time) {\n    this._events.add({\n      callback,\n      time: this.toSeconds(time)\n    }); // start the draw loop on the first event\n\n\n    if (this._events.length === 1) {\n      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel events scheduled after the given time\n   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n   */\n\n\n  cancel(after) {\n    this._events.cancel(this.toSeconds(after));\n\n    return this;\n  }\n  /**\n   * The draw loop\n   */\n\n\n  _drawLoop() {\n    const now = this.context.currentTime;\n\n    while (this._events.length && this._events.peek().time - this.anticipation <= now) {\n      const event = this._events.shift();\n\n      if (event && now - event.time <= this.expiration) {\n        event.callback();\n      }\n    }\n\n    if (this._events.length > 0) {\n      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._events.dispose();\n\n    cancelAnimationFrame(this._animationFrame);\n    return this;\n  }\n\n} //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.draw = new Draw({\n    context\n  });\n});\nonContextClose(context => {\n  context.draw.dispose();\n});","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport class Source extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * Sources have no inputs\n     */\n\n    this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    this._syncedStart = noOp;\n    this._syncedStop = noOp;\n    this._state.memory = 100;\n    this._state.increasing = true;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.onstop = options.onstop;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n   * \tplayer.start();\n   * \tconsole.log(player.state);\n   * }).toDestination();\n   */\n\n\n  get state() {\n    if (this._synced) {\n      if (this.context.transport.state === \"started\") {\n        return this._state.getValueAtTime(this.context.transport.seconds);\n      } else {\n        return \"stopped\";\n      }\n    } else {\n      return this._state.getValueAtTime(this.now());\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // mute the output\n   * osc.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n\n\n  _clampToCurrentTime(time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  }\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n\n\n  start(time, offset, duration) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n    if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (this._synced) {\n        // add the offset time to the event\n        const event = this._state.get(computedTime);\n\n        if (event) {\n          event.offset = this.toSeconds(defaultArg(offset, 0));\n          event.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n\n        const sched = this.context.transport.schedule(t => {\n          this._start(t, offset, duration);\n        }, computedTime);\n\n        this._scheduled.push(sched); // if it's already started\n\n\n        if (this.context.transport.state === \"started\") {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        this._start(computedTime, offset, duration);\n      }\n\n      assertContextRunning(this.context);\n    }\n\n    return this;\n  }\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n\n\n  stop(time) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n        this._scheduled.push(sched);\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Restart the source.\n   */\n\n\n  restart(time, offset, duration) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n\n      this._restart(time, offset, duration);\n    }\n\n    return this;\n  }\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * const osc = new Tone.Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Tone.Transport.start();\n   * // set it to loop once a second\n   * Tone.Transport.loop = true;\n   * Tone.Transport.loopEnd = 1;\n   */\n\n\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncedStart = (time, offset) => {\n        if (offset > 0) {\n          // get the playback state at that time\n          const stateEvent = this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            const startOffset = offset - this.toSeconds(stateEvent.time);\n            let duration;\n\n            if (stateEvent.duration) {\n              duration = this.toSeconds(stateEvent.duration) - startOffset;\n            }\n\n            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n\n      this._syncedStop = time => {\n        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\n        if (this._state.getValueAtTime(seconds) === \"started\") {\n          this._stop(time);\n        }\n      };\n\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n\n    return this;\n  }\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n\n\n  unsync() {\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n\n    this._synced = false; // clear all of the scheduled ids\n\n    this._scheduled.forEach(id => this.context.transport.clear(id));\n\n    this._scheduled = [];\n\n    this._state.cancel(0);\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.onstop = noOp;\n    this.unsync();\n\n    this._volume.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\n\nexport class ToneBufferSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n\n    this._source = this.context.createBufferSource();\n    this._internalChannels = [this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n\n    this._sourceStarted = false;\n    this._sourceStopped = false;\n    const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    connect(this._source, this._gainNode);\n\n    this._source.onended = () => this._stopSource();\n    /**\n     * The playbackRate of the buffer\n     */\n\n\n    this.playbackRate = new Param({\n      context: this.context,\n      param: this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    }); // set some values initially\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n    this._internalChannels.push(this._source);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      url: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1\n    });\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(t) {\n    this._fadeIn = t;\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(t) {\n    this._fadeOut = t;\n  }\n  /**\n   * The curve applied to the fades, either \"linear\" or \"exponential\"\n   */\n\n\n  get curve() {\n    return this._curve;\n  }\n\n  set curve(t) {\n    this._curve = t;\n  }\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n\n\n  start(time, offset, duration, gain = 1) {\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    const computedTime = this.toSeconds(time); // apply the gain envelope\n\n    this._startGain(computedTime, gain); // if it's a loop the default offset is the loopstart point\n\n\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    } // make sure the offset is not less than 0\n\n\n    let computedOffset = Math.max(this.toSeconds(offset), 0); // start the buffer source\n\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      const loopStart = this.toSeconds(this.loopStart);\n      const loopDuration = loopEnd - loopStart; // move the offset back\n\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      } // when the offset is very close to the duration, set it to 0\n\n\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    } // this.buffer.loaded would have return false if the AudioBuffer was undefined\n\n\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n\n      this._source.start(computedTime, computedOffset);\n    } // if a duration is given, schedule a stop\n\n\n    if (isDefined(duration)) {\n      let computedDur = this.toSeconds(duration); // make sure it's never negative\n\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n\n    return this;\n  }\n\n  _stopSource(time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n\n      this._source.stop(this.toSeconds(time));\n\n      this._onended();\n    }\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n\n\n  get loopStart() {\n    return this._source.loopStart;\n  }\n\n  set loopStart(loopStart) {\n    this._source.loopStart = this.toSeconds(loopStart);\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n\n\n  get loopEnd() {\n    return this._source.loopEnd;\n  }\n\n  set loopEnd(loopEnd) {\n    this._source.loopEnd = this.toSeconds(loopEnd);\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n\n\n  get loop() {\n    return this._source.loop;\n  }\n\n  set loop(loop) {\n    this._source.loop = loop;\n\n    if (this._sourceStarted) {\n      this.cancelStop();\n    }\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._source.onended = null;\n\n    this._source.disconnect();\n\n    this._buffer.dispose();\n\n    this.playbackRate.dispose();\n    return this;\n  }\n\n}","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nexport class Noise extends Source {\n  constructor() {\n    super(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n    this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    this._source = null;\n    const options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    this._playbackRate = options.playbackRate;\n    this.type = options.type;\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      fadeIn: 0,\n      fadeOut: 0,\n      playbackRate: 1,\n      type: \"white\"\n    });\n  }\n  /**\n   * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n   * @example\n   * const noise = new Tone.Noise().toDestination().start();\n   * noise.type = \"brown\";\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n    if (this._type !== type) {\n      this._type = type; // if it's playing, stop and restart it\n\n      if (this.state === \"started\") {\n        const now = this.now();\n\n        this._stop(now);\n\n        this._start(now);\n      }\n    }\n  }\n  /**\n   * The playback rate of the noise. Affects\n   * the \"frequency\" of the noise.\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n\n    if (this._source) {\n      this._source.playbackRate.value = rate;\n    }\n  }\n  /**\n   * internal start method\n   */\n\n\n  _start(time) {\n    const buffer = _noiseBuffers[this._type];\n    this._source = new ToneBufferSource({\n      url: buffer,\n      context: this.context,\n      fadeIn: this._fadeIn,\n      fadeOut: this._fadeOut,\n      loop: true,\n      onended: () => this.onstop(this),\n      playbackRate: this._playbackRate\n    }).connect(this.output);\n\n    this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n  }\n  /**\n   * internal stop method\n   */\n\n\n  _stop(time) {\n    if (this._source) {\n      this._source.stop(this.toSeconds(time));\n\n      this._source = null;\n    }\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(time) {\n    this._fadeIn = time;\n\n    if (this._source) {\n      this._source.fadeIn = this._fadeIn;\n    }\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(time) {\n    this._fadeOut = time;\n\n    if (this._source) {\n      this._source.fadeOut = this._fadeOut;\n    }\n  }\n\n  _restart(time) {\n    // TODO could be optimized by cancelling the buffer source 'stop'\n    this._stop(time);\n\n    this._start(time);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._source) {\n      this._source.disconnect();\n    }\n\n    return this;\n  }\n\n} //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nconst _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nconst _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        let lastOut = 0.0;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          const white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        let b0, b1, b2, b3, b4, b5, b6;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          const white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","import { __awaiter } from \"tslib\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\n\nexport function generateWaveform(instance, length) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const duration = length / instance.context.sampleRate;\n    const context = new OfflineContext(1, duration, instance.context.sampleRate);\n    const clone = new instance.constructor(Object.assign(instance.get(), {\n      // should do 2 iterations\n      frequency: 2 / duration,\n      // zero out the detune\n      detune: 0,\n      context\n    })).toDestination();\n    clone.start(0);\n    const buffer = yield context.render();\n    return buffer.getChannelData(0);\n  });\n}","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\n\nexport class ToneOscillatorNode extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"ToneOscillatorNode\";\n    /**\n     * The oscillator\n     */\n\n    this._oscillator = this.context.createOscillator();\n    this._internalChannels = [this._oscillator];\n    const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    connect(this._oscillator, this._gainNode);\n    this.type = options.type;\n    this.frequency = new Param({\n      context: this.context,\n      param: this._oscillator.frequency,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Param({\n      context: this.context,\n      param: this._oscillator.detune,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      type: \"sine\"\n    });\n  }\n  /**\n   * Start the oscillator node at the given time\n   * @param  time When to start the oscillator\n   */\n\n\n  start(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    this._startGain(computedTime);\n\n    this._oscillator.start(computedTime);\n\n    return this;\n  }\n\n  _stopSource(time) {\n    this._oscillator.stop(time);\n  }\n  /**\n   * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n   */\n\n\n  setPeriodicWave(periodicWave) {\n    this._oscillator.setPeriodicWave(periodicWave);\n\n    return this;\n  }\n  /**\n   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this.state === \"started\") {\n      this.stop();\n    }\n\n    this._oscillator.disconnect();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\n\nexport class Oscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n\n    this._oscillator = null;\n    const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, \"detune\");\n    this._partials = options.partials;\n    this._partialCount = options.partialCount;\n    this._type = options.type;\n\n    if (options.partialCount && options.type !== \"custom\") {\n      this._type = this.baseType + options.partialCount.toString();\n    }\n\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      partialCount: 0,\n      partials: [],\n      phase: 0,\n      type: \"sine\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    const computedTime = this.toSeconds(time); // new oscillator with previous values\n\n    const oscillator = new ToneOscillatorNode({\n      context: this.context,\n      onended: () => this.onstop(this)\n    });\n    this._oscillator = oscillator;\n\n    if (this._wave) {\n      this._oscillator.setPeriodicWave(this._wave);\n    } else {\n      this._oscillator.type = this._type;\n    } // connect the control signal to the oscillator frequency & detune\n\n\n    this._oscillator.connect(this.output);\n\n    this.frequency.connect(this._oscillator.frequency);\n    this.detune.connect(this._oscillator.detune); // start the oscillator\n\n    this._oscillator.start(computedTime);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._oscillator) {\n      this._oscillator.stop(computedTime);\n    }\n  }\n  /**\n   * Restart the oscillator. Does not stop the oscillator, but instead\n   * just cancels any scheduled 'stop' from being invoked.\n   */\n\n\n  _restart(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"restart\", computedTime);\n\n    if (this._oscillator) {\n      this._oscillator.cancelStop();\n    }\n\n    this._state.cancel(computedTime);\n\n    return this;\n  }\n  /**\n   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n   * will also affect the oscillators frequency.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * osc.frequency.value = 440;\n   * // the ratio between the bpm and the frequency will be maintained\n   * osc.syncFrequency();\n   * // double the tempo\n   * Tone.Transport.bpm.value *= 2;\n   * // the frequency of the oscillator is doubled to 880\n   */\n\n\n  syncFrequency() {\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Unsync the oscillator's frequency from the Transport.\n   * See Oscillator.syncFrequency\n   */\n\n\n  unsyncFrequency() {\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Get a cached periodic wave. Avoids having to recompute\n   * the oscillator values when they have already been computed\n   * with the same values.\n   */\n\n\n  _getCachedPeriodicWave() {\n    if (this._type === \"custom\") {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.phase === this._phase && deepEquals(description.partials, this._partials);\n      });\n\n      return oscProps;\n    } else {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.type === this._type && description.phase === this._phase;\n      });\n\n      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n      return oscProps;\n    }\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n    const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\n    if (this._phase === 0 && isBasicType) {\n      this._wave = undefined;\n      this._partialCount = 0; // just go with the basic approach\n\n      if (this._oscillator !== null) {\n        // already tested that it's a basic type\n        this._oscillator.type = type;\n      }\n    } else {\n      // first check if the value is cached\n      const cache = this._getCachedPeriodicWave();\n\n      if (isDefined(cache)) {\n        const {\n          partials,\n          wave\n        } = cache;\n        this._wave = wave;\n        this._partials = partials;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        }\n      } else {\n        const [real, imag] = this._getRealImaginary(type, this._phase);\n\n        const periodicWave = this.context.createPeriodicWave(real, imag);\n        this._wave = periodicWave;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        } // set the cache\n\n\n        Oscillator._periodicWaveCache.push({\n          imag,\n          partialCount: this._partialCount,\n          partials: this._partials,\n          phase: this._phase,\n          real,\n          type: this._type,\n          wave: this._wave\n        });\n\n        if (Oscillator._periodicWaveCache.length > 100) {\n          Oscillator._periodicWaveCache.shift();\n        }\n      }\n    }\n  }\n\n  get baseType() {\n    return this._type.replace(this.partialCount.toString(), \"\");\n  }\n\n  set baseType(baseType) {\n    if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n      this.type = baseType + this.partialCount;\n    } else {\n      this.type = baseType;\n    }\n  }\n\n  get partialCount() {\n    return this._partialCount;\n  }\n\n  set partialCount(p) {\n    assertRange(p, 0);\n    let type = this._type;\n    const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\n    if (partial) {\n      type = partial[1];\n    }\n\n    if (this._type !== \"custom\") {\n      if (p === 0) {\n        this.type = type;\n      } else {\n        this.type = type + p.toString();\n      }\n    } else {\n      // extend or shorten the partials array\n      const fullPartials = new Float32Array(p); // copy over the partials array\n\n      this._partials.forEach((v, i) => fullPartials[i] = v);\n\n      this._partials = Array.from(fullPartials);\n      this.type = this._type;\n    }\n  }\n  /**\n   * Returns the real and imaginary components based\n   * on the oscillator type.\n   * @returns [real: Float32Array, imaginary: Float32Array]\n   */\n\n\n  _getRealImaginary(type, phase) {\n    const fftSize = 4096;\n    let periodicWaveSize = fftSize / 2;\n    const real = new Float32Array(periodicWaveSize);\n    const imag = new Float32Array(periodicWaveSize);\n    let partialCount = 1;\n\n    if (type === \"custom\") {\n      partialCount = this._partials.length + 1;\n      this._partialCount = this._partials.length;\n      periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation\n\n      if (this._partials.length === 0) {\n        return [real, imag];\n      }\n    } else {\n      const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\n      if (partial) {\n        partialCount = parseInt(partial[2], 10) + 1;\n        this._partialCount = parseInt(partial[2], 10);\n        type = partial[1];\n        partialCount = Math.max(partialCount, 2);\n        periodicWaveSize = partialCount;\n      } else {\n        this._partialCount = 0;\n      }\n\n      this._partials = [];\n    }\n\n    for (let n = 1; n < periodicWaveSize; ++n) {\n      const piFactor = 2 / (n * Math.PI);\n      let b;\n\n      switch (type) {\n        case \"sine\":\n          b = n <= partialCount ? 1 : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"square\":\n          b = n & 1 ? 2 * piFactor : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"sawtooth\":\n          b = piFactor * (n & 1 ? 1 : -1);\n          this._partials[n - 1] = b;\n          break;\n\n        case \"triangle\":\n          if (n & 1) {\n            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n          } else {\n            b = 0;\n          }\n\n          this._partials[n - 1] = b;\n          break;\n\n        case \"custom\":\n          b = this._partials[n - 1];\n          break;\n\n        default:\n          throw new TypeError(\"Oscillator: invalid type: \" + type);\n      }\n\n      if (b !== 0) {\n        real[n] = -b * Math.sin(phase * n);\n        imag[n] = b * Math.cos(phase * n);\n      } else {\n        real[n] = 0;\n        imag[n] = 0;\n      }\n    }\n\n    return [real, imag];\n  }\n  /**\n   * Compute the inverse FFT for a given phase.\n   */\n\n\n  _inverseFFT(real, imag, phase) {\n    let sum = 0;\n    const len = real.length;\n\n    for (let i = 0; i < len; i++) {\n      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n    }\n\n    return sum;\n  }\n  /**\n   * Returns the initial value of the oscillator when stopped.\n   * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n   */\n\n\n  getInitialValue() {\n    const [real, imag] = this._getRealImaginary(this._type, 0);\n\n    let maxValue = 0;\n    const twoPi = Math.PI * 2;\n    const testPositions = 32; // check for peaks in 16 places\n\n    for (let i = 0; i < testPositions; i++) {\n      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n    }\n\n    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n  }\n\n  get partials() {\n    return this._partials.slice(0, this.partialCount);\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this.type = \"custom\";\n    }\n  }\n\n  get phase() {\n    return this._phase * (180 / Math.PI);\n  }\n\n  set phase(phase) {\n    this._phase = phase * Math.PI / 180; // reset the type\n\n    this.type = this._type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._oscillator !== null) {\n      this._oscillator.dispose();\n    }\n\n    this._wave = undefined;\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\n\nOscillator._periodicWaveCache = [];","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\n\nexport class SignalOperator extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n  }\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    connectSignal(this, destination, outputNum, inputNum);\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\n\nexport class WaveShaper extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n\n    this._shaper = this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n\n    this.input = this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n\n    this.output = this._shaper;\n    const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      this.setMap(options.mapping, options.length);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      length: 1024\n    });\n  }\n  /**\n   * Uses a mapping function to set the value of the curve.\n   * @param mapping The function used to define the values.\n   *                The mapping function take two arguments:\n   *                the first is the value at the current position\n   *                which goes from -1 to 1 over the number of elements\n   *                in the curve array. The second argument is the array position.\n   * @example\n   * const shaper = new Tone.WaveShaper();\n   * // map the input signal from [-1, 1] to [0, 10]\n   * shaper.setMap((val, index) => (val + 1) * 5);\n   */\n\n\n  setMap(mapping, length = 1024) {\n    const array = new Float32Array(length);\n\n    for (let i = 0, len = length; i < len; i++) {\n      const normalized = i / (len - 1) * 2 - 1;\n      array[i] = mapping(normalized, i);\n    }\n\n    this.curve = array;\n    return this;\n  }\n  /**\n   * The array to set as the waveshaper curve. For linear curves\n   * array length does not make much difference, but for complex curves\n   * longer arrays will provide smoother interpolation.\n   */\n\n\n  get curve() {\n    return this._shaper.curve;\n  }\n\n  set curve(mapping) {\n    this._shaper.curve = mapping;\n  }\n  /**\n   * Specifies what type of oversampling (if any) should be used when\n   * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n   */\n\n\n  get oversample() {\n    return this._shaper.oversample;\n  }\n\n  set oversample(oversampling) {\n    const isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n    assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n    this._shaper.oversample = oversampling;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._shaper.disconnect();\n\n    return this;\n  }\n\n}","import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n * @category Signal\n */\n\nexport class AudioToGain extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"AudioToGain\";\n    /**\n     * The node which converts the audio ranges\n     */\n\n    this._norm = new WaveShaper({\n      context: this.context,\n      mapping: x => (x + 1) / 2\n    });\n    /**\n     * The AudioRange input [-1, 1]\n     */\n\n    this.input = this._norm;\n    /**\n     * The GainRange output [0, 1]\n     */\n\n    this.output = this._norm;\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._norm.dispose();\n\n    return this;\n  }\n\n}","import { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal } from \"./Signal\";\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\n\nexport class Multiply extends Signal {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n    this.name = \"Multiply\";\n    /**\n     * Indicates if the value should be overridden on connection\n     */\n\n    this.override = false;\n    const options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n    this._mult = this.input = this.output = new Gain({\n      context: this.context,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n    this.factor = this._param = this._mult.gain;\n    this.factor.setValueAtTime(options.value, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      value: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._mult.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @offline 0.2 1\n * @example\n * const amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * @category Source\n */\n\nexport class AMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    this.name = \"AMOscillator\";\n    /**\n     * convert the -1,1 output to 0,1\n     */\n\n    this._modulationScale = new AudioToGain({\n      context: this.context\n    });\n    /**\n     * the node where the modulation happens\n     */\n\n    this._modulationNode = new Gain({\n      context: this.context\n    });\n    const options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    this._carrier = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: options.type\n    });\n    this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;\n    this._modulator = new Oscillator({\n      context: this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    }); // connections\n\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\n    this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\n    this._carrier.chain(this._modulationNode, this.output);\n\n    readOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      harmonicity: 1,\n      modulationType: \"square\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._modulator.start(time);\n\n    this._carrier.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    this._modulator.stop(time);\n\n    this._carrier.stop(time);\n  }\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._carrier.restart(time);\n  }\n  /**\n   * The type of the carrier oscillator\n   */\n\n\n  get type() {\n    return this._carrier.type;\n  }\n\n  set type(type) {\n    this._carrier.type = type;\n  }\n\n  get baseType() {\n    return this._carrier.baseType;\n  }\n\n  set baseType(baseType) {\n    this._carrier.baseType = baseType;\n  }\n\n  get partialCount() {\n    return this._carrier.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._carrier.partialCount = partialCount;\n  }\n  /**\n   * The type of the modulator oscillator\n   */\n\n\n  get modulationType() {\n    return this._modulator.type;\n  }\n\n  set modulationType(type) {\n    this._modulator.type = type;\n  }\n\n  get phase() {\n    return this._carrier.phase;\n  }\n\n  set phase(phase) {\n    this._carrier.phase = phase;\n    this._modulator.phase = phase;\n  }\n\n  get partials() {\n    return this._carrier.partials;\n  }\n\n  set partials(partials) {\n    this._carrier.partials = partials;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n    this.harmonicity.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this._modulationNode.dispose();\n\n    this._modulationScale.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @offline 0.1 1\n * @example\n * const fmOsc = new Tone.FMOscillator({\n * \tfrequency: 200,\n * \ttype: \"square\",\n * \tmodulationType: \"triangle\",\n * \tharmonicity: 0.2,\n * \tmodulationIndex: 3\n * }).toDestination().start();\n * @category Source\n */\n\nexport class FMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    this.name = \"FMOscillator\";\n    /**\n     * the node where the modulation happens\n     */\n\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    this._carrier = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: 0,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: options.type\n    });\n    this.detune = this._carrier.detune;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this._modulator = new Oscillator({\n      context: this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    });\n    this.modulationIndex = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.modulationIndex\n    }); // connections\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.frequency.chain(this.modulationIndex, this._modulationNode);\n\n    this._modulator.connect(this._modulationNode.gain);\n\n    this._modulationNode.connect(this._carrier.frequency);\n\n    this._carrier.connect(this.output);\n\n    this.detune.connect(this._modulator.detune);\n    readOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      harmonicity: 1,\n      modulationIndex: 2,\n      modulationType: \"square\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._modulator.start(time);\n\n    this._carrier.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    this._modulator.stop(time);\n\n    this._carrier.stop(time);\n  }\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._carrier.restart(time);\n\n    return this;\n  }\n\n  get type() {\n    return this._carrier.type;\n  }\n\n  set type(type) {\n    this._carrier.type = type;\n  }\n\n  get baseType() {\n    return this._carrier.baseType;\n  }\n\n  set baseType(baseType) {\n    this._carrier.baseType = baseType;\n  }\n\n  get partialCount() {\n    return this._carrier.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._carrier.partialCount = partialCount;\n  }\n  /**\n   * The type of the modulator oscillator\n   */\n\n\n  get modulationType() {\n    return this._modulator.type;\n  }\n\n  set modulationType(type) {\n    this._modulator.type = type;\n  }\n\n  get phase() {\n    return this._carrier.phase;\n  }\n\n  set phase(phase) {\n    this._carrier.phase = phase;\n    this._modulator.phase = phase;\n  }\n\n  get partials() {\n    return this._carrier.partials;\n  }\n\n  set partials(partials) {\n    this._carrier.partials = partials;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.harmonicity.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this._modulationNode.dispose();\n\n    this.modulationIndex.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @offline 0.1 1\n * @example\n * const pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * @category Source\n */\n\nexport class PulseOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n    this.name = \"PulseOscillator\";\n    /**\n     * gate the width amount\n     */\n\n    this._widthGate = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * Threshold the signal to turn it into a square\n     */\n\n    this._thresh = new WaveShaper({\n      context: this.context,\n      mapping: val => val <= 0 ? -1 : 1\n    });\n    const options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n    this.width = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: options.width\n    });\n    this._triangle = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: \"triangle\"\n    });\n    this.frequency = this._triangle.frequency;\n    this.detune = this._triangle.detune; // connections\n\n    this._triangle.chain(this._thresh, this.output);\n\n    this.width.chain(this._widthGate, this._thresh);\n    readOnly(this, [\"width\", \"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      phase: 0,\n      type: \"pulse\",\n      width: 0.2\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._triangle.start(time);\n\n    this._widthGate.gain.setValueAtTime(1, time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._triangle.stop(time); // the width is still connected to the output.\n    // that needs to be stopped also\n\n\n    this._widthGate.gain.cancelScheduledValues(time);\n\n    this._widthGate.gain.setValueAtTime(0, time);\n  }\n\n  _restart(time) {\n    this._triangle.restart(time);\n\n    this._widthGate.gain.cancelScheduledValues(time);\n\n    this._widthGate.gain.setValueAtTime(1, time);\n  }\n  /**\n   * The phase of the oscillator in degrees.\n   */\n\n\n  get phase() {\n    return this._triangle.phase;\n  }\n\n  set phase(phase) {\n    this._triangle.phase = phase;\n  }\n  /**\n   * The type of the oscillator. Always returns \"pulse\".\n   */\n\n\n  get type() {\n    return \"pulse\";\n  }\n  /**\n   * The baseType of the oscillator. Always returns \"pulse\".\n   */\n\n\n  get baseType() {\n    return \"pulse\";\n  }\n  /**\n   * The partials of the waveform. Cannot set partials for this waveform type\n   */\n\n\n  get partials() {\n    return [];\n  }\n  /**\n   * No partials for this waveform type.\n   */\n\n\n  get partialCount() {\n    return 0;\n  }\n  /**\n   * *Internal use* The carrier oscillator type is fed through the\n   * waveshaper node to create the pulse. Using different carrier oscillators\n   * changes oscillator's behavior.\n   */\n\n\n  set carrierType(type) {\n    this._triangle.type = type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up method.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._triangle.dispose();\n\n    this.width.dispose();\n\n    this._widthGate.dispose();\n\n    this._thresh.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\n\nexport class FatOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n    this.name = \"FatOscillator\";\n    /**\n     * The array of oscillators\n     */\n\n    this._oscillators = [];\n    const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this._spread = options.spread;\n    this._type = options.type;\n    this._phase = options.phase;\n    this._partials = options.partials;\n    this._partialCount = options.partialCount; // set the count initially\n\n    this.count = options.count;\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      count: 3,\n      spread: 20,\n      type: \"sawtooth\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.start(time));\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.stop(time));\n  }\n\n  _restart(time) {\n    this._forEach(osc => osc.restart(time));\n  }\n  /**\n   * Iterate over all of the oscillators\n   */\n\n\n  _forEach(iterator) {\n    for (let i = 0; i < this._oscillators.length; i++) {\n      iterator(this._oscillators[i], i);\n    }\n  }\n  /**\n   * The type of the oscillator\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n\n    this._forEach(osc => osc.type = type);\n  }\n  /**\n   * The detune spread between the oscillators. If \"count\" is\n   * set to 3 oscillators and the \"spread\" is set to 40,\n   * the three oscillators would be detuned like this: [-20, 0, 20]\n   * for a total detune spread of 40 cents.\n   * @example\n   * const fatOsc = new Tone.FatOscillator().toDestination().start();\n   * fatOsc.spread = 70;\n   */\n\n\n  get spread() {\n    return this._spread;\n  }\n\n  set spread(spread) {\n    this._spread = spread;\n\n    if (this._oscillators.length > 1) {\n      const start = -spread / 2;\n      const step = spread / (this._oscillators.length - 1);\n\n      this._forEach((osc, i) => osc.detune.value = start + step * i);\n    }\n  }\n  /**\n   * The number of detuned oscillators. Must be an integer greater than 1.\n   * @example\n   * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n   * // use 4 sawtooth oscillators\n   * fatOsc.count = 4;\n   */\n\n\n  get count() {\n    return this._oscillators.length;\n  }\n\n  set count(count) {\n    assertRange(count, 1);\n\n    if (this._oscillators.length !== count) {\n      // dispose the previous oscillators\n      this._forEach(osc => osc.dispose());\n\n      this._oscillators = [];\n\n      for (let i = 0; i < count; i++) {\n        const osc = new Oscillator({\n          context: this.context,\n          volume: -6 - count * 1.1,\n          type: this._type,\n          phase: this._phase + i / count * 360,\n          partialCount: this._partialCount,\n          onstop: i === 0 ? () => this.onstop(this) : noOp\n        });\n\n        if (this.type === \"custom\") {\n          osc.partials = this._partials;\n        }\n\n        this.frequency.connect(osc.frequency);\n        this.detune.connect(osc.detune);\n        osc.detune.overridden = false;\n        osc.connect(this.output);\n        this._oscillators[i] = osc;\n      } // set the spread\n\n\n      this.spread = this._spread;\n\n      if (this.state === \"started\") {\n        this._forEach(osc => osc.start());\n      }\n    }\n  }\n\n  get phase() {\n    return this._phase;\n  }\n\n  set phase(phase) {\n    this._phase = phase;\n\n    this._forEach(osc => osc.phase = phase);\n  }\n\n  get baseType() {\n    return this._oscillators[0].baseType;\n  }\n\n  set baseType(baseType) {\n    this._forEach(osc => osc.baseType = baseType);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  get partials() {\n    return this._oscillators[0].partials;\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this._type = \"custom\";\n\n      this._forEach(osc => osc.partials = partials);\n    }\n  }\n\n  get partialCount() {\n    return this._oscillators[0].partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._partialCount = partialCount;\n\n    this._forEach(osc => osc.partialCount = partialCount);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n\n    this._forEach(osc => osc.dispose());\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @offline 0.1 1\n * @example\n * const pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * @category Source\n */\n\nexport class PWMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n    this.name = \"PWMOscillator\";\n    this.sourceType = \"pwm\";\n    /**\n     * Scale the oscillator so it doesn't go silent\n     * at the extreme values.\n     */\n\n    this._scale = new Multiply({\n      context: this.context,\n      value: 2\n    });\n    const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n    this._pulse = new PulseOscillator({\n      context: this.context,\n      frequency: options.modulationFrequency\n    }); // change the pulse oscillator type\n\n    this._pulse.carrierType = \"sine\";\n    this.modulationFrequency = this._pulse.frequency;\n    this._modulator = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase\n    });\n    this.frequency = this._modulator.frequency;\n    this.detune = this._modulator.detune; // connections\n\n    this._modulator.chain(this._scale, this._pulse.width);\n\n    this._pulse.connect(this.output);\n\n    readOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      modulationFrequency: 0.4,\n      phase: 0,\n      type: \"pwm\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._modulator.start(time);\n\n    this._pulse.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._modulator.stop(time);\n\n    this._pulse.stop(time);\n  }\n  /**\n   * restart the oscillator\n   */\n\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._pulse.restart(time);\n  }\n  /**\n   * The type of the oscillator. Always returns \"pwm\".\n   */\n\n\n  get type() {\n    return \"pwm\";\n  }\n  /**\n   * The baseType of the oscillator. Always returns \"pwm\".\n   */\n\n\n  get baseType() {\n    return \"pwm\";\n  }\n  /**\n   * The partials of the waveform. Cannot set partials for this waveform type\n   */\n\n\n  get partials() {\n    return [];\n  }\n  /**\n   * No partials for this waveform type.\n   */\n\n\n  get partialCount() {\n    return 0;\n  }\n  /**\n   * The phase of the oscillator in degrees.\n   */\n\n\n  get phase() {\n    return this._modulator.phase;\n  }\n\n  set phase(phase) {\n    this._modulator.phase = phase;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._pulse.dispose();\n\n    this._scale.dispose();\n\n    this._modulator.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @offline 0.1 1\n * @example\n * const omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * @category Source\n */\n\nexport class OmniOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"OmniOscillator\";\n    const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]); // set the options\n\n    this.set(options);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._oscillator.start(time);\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _stop(time) {\n    this._oscillator.stop(time);\n  }\n\n  _restart(time) {\n    this._oscillator.restart(time);\n\n    return this;\n  }\n  /**\n   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n   * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n   * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n   * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n   * when it's not.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n   * omniOsc.type = \"pwm\";\n   * // modulationFrequency is parameter which is available\n   * // only when the type is \"pwm\".\n   * omniOsc.modulationFrequency.value = 0.5;\n   */\n\n\n  get type() {\n    let prefix = \"\";\n\n    if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n      prefix = this._sourceType;\n    }\n\n    return prefix + this._oscillator.type;\n  }\n\n  set type(type) {\n    if (type.substr(0, 2) === \"fm\") {\n      this._createNewOscillator(\"fm\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 2) === \"am\") {\n      this._createNewOscillator(\"am\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 3) === \"fat\") {\n      this._createNewOscillator(\"fat\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(3);\n    } else if (type === \"pwm\") {\n      this._createNewOscillator(\"pwm\");\n\n      this._oscillator = this._oscillator;\n    } else if (type === \"pulse\") {\n      this._createNewOscillator(\"pulse\");\n    } else {\n      this._createNewOscillator(\"oscillator\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type;\n    }\n  }\n  /**\n   * The value is an empty array when the type is not \"custom\".\n   * This is not available on \"pwm\" and \"pulse\" oscillator types.\n   * See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partials = partials;\n    }\n  }\n\n  get partialCount() {\n    return this._oscillator.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partialCount = partialCount;\n    }\n  }\n\n  set(props) {\n    // make sure the type is set first\n    if (Reflect.has(props, \"type\") && props.type) {\n      this.type = props.type;\n    } // then set the rest\n\n\n    super.set(props);\n    return this;\n  }\n  /**\n   * connect the oscillator to the frequency and detune signals\n   */\n\n\n  _createNewOscillator(oscType) {\n    if (oscType !== this._sourceType) {\n      this._sourceType = oscType;\n      const OscConstructor = OmniOscillatorSourceMap[oscType]; // short delay to avoid clicks on the change\n\n      const now = this.now();\n\n      if (this._oscillator) {\n        const oldOsc = this._oscillator;\n        oldOsc.stop(now); // dispose the old one\n\n        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n      }\n\n      this._oscillator = new OscConstructor({\n        context: this.context\n      });\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune);\n\n      this._oscillator.connect(this.output);\n\n      this._oscillator.onstop = () => this.onstop(this);\n\n      if (this.state === \"started\") {\n        this._oscillator.start(now);\n      }\n    }\n  }\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n  }\n  /**\n   * The source type of the oscillator.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n   * console.log(omniOsc.sourceType); // 'fm'\n   */\n\n\n  get sourceType() {\n    return this._sourceType;\n  }\n\n  set sourceType(sType) {\n    // the basetype defaults to sine\n    let baseType = \"sine\";\n\n    if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n      baseType = this._oscillator.type;\n    } // set the type\n\n\n    if (sType === \"fm\") {\n      this.type = \"fm\" + baseType;\n    } else if (sType === \"am\") {\n      this.type = \"am\" + baseType;\n    } else if (sType === \"fat\") {\n      this.type = \"fat\" + baseType;\n    } else if (sType === \"oscillator\") {\n      this.type = baseType;\n    } else if (sType === \"pulse\") {\n      this.type = \"pulse\";\n    } else if (sType === \"pwm\") {\n      this.type = \"pwm\";\n    }\n  }\n\n  _getOscType(osc, sourceType) {\n    return osc instanceof OmniOscillatorSourceMap[sourceType];\n  }\n  /**\n   * The base type of the oscillator. See [[Oscillator.baseType]]\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n   */\n\n\n  get baseType() {\n    return this._oscillator.baseType;\n  }\n\n  set baseType(baseType) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n      this._oscillator.baseType = baseType;\n    }\n  }\n  /**\n   * The width of the oscillator when sourceType === \"pulse\".\n   * See [[PWMOscillator.width]]\n   */\n\n\n  get width() {\n    if (this._getOscType(this._oscillator, \"pulse\")) {\n      return this._oscillator.width;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The number of detuned oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get count() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.count;\n    } else {\n      return undefined;\n    }\n  }\n\n  set count(count) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n      this._oscillator.count = count;\n    }\n  }\n  /**\n   * The detune spread between the oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get spread() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.spread;\n    } else {\n      return undefined;\n    }\n  }\n\n  set spread(spread) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n      this._oscillator.spread = spread;\n    }\n  }\n  /**\n   * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get modulationType() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.modulationType;\n    } else {\n      return undefined;\n    }\n  }\n\n  set modulationType(mType) {\n    if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n      this._oscillator.modulationType = mType;\n    }\n  }\n  /**\n   * The modulation index when the sourceType === \"fm\"\n   * See [[FMOscillator]].\n   */\n\n\n  get modulationIndex() {\n    if (this._getOscType(this._oscillator, \"fm\")) {\n      return this._oscillator.modulationIndex;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get harmonicity() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.harmonicity;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n   * see [[PWMOscillator]]\n   * @min 0.1\n   * @max 5\n   */\n\n\n  get modulationFrequency() {\n    if (this._getOscType(this._oscillator, \"pwm\")) {\n      return this._oscillator.modulationFrequency;\n    } else {\n      return undefined;\n    }\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.detune.dispose();\n    this.frequency.dispose();\n\n    this._oscillator.dispose();\n\n    return this;\n  }\n\n}","import { assertRange } from \"./Debug\";\n/**\n * Assert that the number is in the given range.\n */\n\nexport function range(min, max = Infinity) {\n  const valueMap = new WeakMap();\n  return function (target, propertyKey) {\n    Reflect.defineProperty(target, propertyKey, {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        return valueMap.get(this);\n      },\n      set: function (newValue) {\n        assertRange(newValue, min, max);\n        valueMap.set(this, newValue);\n      }\n    });\n  };\n}\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\n\nexport function timeRange(min, max = Infinity) {\n  const valueMap = new WeakMap();\n  return function (target, propertyKey) {\n    Reflect.defineProperty(target, propertyKey, {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        return valueMap.get(this);\n      },\n      set: function (newValue) {\n        assertRange(this.toSeconds(newValue), min, max);\n        valueMap.set(this, newValue);\n      }\n    });\n  };\n}","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\n\nexport class Player extends Source {\n  constructor() {\n    super(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"Player\";\n    /**\n     * All of the active buffer source nodes\n     */\n\n    this._activeSources = new Set();\n    const options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n    this._buffer = new ToneAudioBuffer({\n      onload: this._onload.bind(this, options.onload),\n      onerror: options.onerror,\n      reverse: options.reverse,\n      url: options.url\n    });\n    this.autostart = options.autostart;\n    this._loop = options.loop;\n    this._loopStart = options.loopStart;\n    this._loopEnd = options.loopEnd;\n    this._playbackRate = options.playbackRate;\n    this.fadeIn = options.fadeIn;\n    this.fadeOut = options.fadeOut;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      autostart: false,\n      fadeIn: 0,\n      fadeOut: 0,\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1,\n      reverse: false\n    });\n  }\n  /**\n   * Load the audio file as an audio buffer.\n   * Decodes the audio asynchronously and invokes\n   * the callback once the audio buffer loads.\n   * Note: this does not need to be called if a url\n   * was passed in to the constructor. Only use this\n   * if you want to manually load a new url.\n   * @param url The url of the buffer to load. Filetype support depends on the browser.\n   */\n\n\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._buffer.load(url);\n\n      this._onload();\n\n      return this;\n    });\n  }\n  /**\n   * Internal callback when the buffer is loaded.\n   */\n\n\n  _onload(callback = noOp) {\n    callback();\n\n    if (this.autostart) {\n      this.start();\n    }\n  }\n  /**\n   * Internal callback when the buffer is done playing.\n   */\n\n\n  _onSourceEnd(source) {\n    // invoke the onstop function\n    this.onstop(this); // delete the source from the active sources\n\n    this._activeSources.delete(source);\n\n    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === \"started\") {\n      this._state.setStateAtTime(\"stopped\", this.now());\n    }\n  }\n  /**\n   * Play the buffer at the given startTime. Optionally add an offset\n   * and/or duration which will play the buffer from a position\n   * within the buffer for the given duration.\n   *\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   */\n\n\n  start(time, offset, duration) {\n    super.start(time, offset, duration);\n    return this;\n  }\n  /**\n   * Internal start method\n   */\n\n\n  _start(startTime, offset, duration) {\n    // if it's a loop the default offset is the loopStart point\n    if (this._loop) {\n      offset = defaultArg(offset, this._loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    } // compute the values in seconds\n\n\n    let computedOffset = this.toSeconds(offset); // if it's synced, it should factor in the playback rate for computing the offset\n\n    if (this._synced) {\n      computedOffset *= this._playbackRate;\n    } // compute the duration which is either the passed in duration of the buffer.duration - offset\n\n\n    const origDuration = duration;\n    duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n    let computedDuration = this.toSeconds(duration); // scale it by the playback rate\n\n    computedDuration = computedDuration / this._playbackRate; // get the start time\n\n    startTime = this.toSeconds(startTime); // make the source\n\n    const source = new ToneBufferSource({\n      url: this._buffer,\n      context: this.context,\n      fadeIn: this.fadeIn,\n      fadeOut: this.fadeOut,\n      loop: this._loop,\n      loopEnd: this._loopEnd,\n      loopStart: this._loopStart,\n      onended: this._onSourceEnd.bind(this),\n      playbackRate: this._playbackRate\n    }).connect(this.output); // set the looping properties\n\n    if (!this._loop && !this._synced) {\n      // cancel the previous stop\n      this._state.cancel(startTime + computedDuration); // if it's not looping, set the state change at the end of the sample\n\n\n      this._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n        implicitEnd: true\n      });\n    } // add it to the array of active sources\n\n\n    this._activeSources.add(source); // start it\n\n\n    if (this._loop && isUndef(origDuration)) {\n      source.start(startTime, computedOffset);\n    } else {\n      // subtract the fade out time\n      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n    }\n  }\n  /**\n   * Stop playback.\n   */\n\n\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(source => source.stop(computedTime));\n  }\n  /**\n   * Stop and then restart the player from the beginning (or offset)\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given,\n   * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n   */\n\n\n  restart(time, offset, duration) {\n    super.restart(time, offset, duration);\n    return this;\n  }\n\n  _restart(time, offset, duration) {\n    this._stop(time);\n\n    this._start(time, offset, duration);\n  }\n  /**\n   * Seek to a specific time in the player's buffer. If the\n   * source is no longer playing at that time, it will stop.\n   * @param offset The time to seek to.\n   * @param when The time for the seek event to occur.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n   * \tplayer.start();\n   * \t// seek to the offset in 1 second from now\n   * \tplayer.seek(0.4, \"+1\");\n   * }).toDestination();\n   */\n\n\n  seek(offset, when) {\n    const computedTime = this.toSeconds(when);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      const computedOffset = this.toSeconds(offset); // if it's currently playing, stop it\n\n      this._stop(computedTime); // restart it at the given time\n\n\n      this._start(computedTime, computedOffset);\n    }\n\n    return this;\n  }\n  /**\n   * Set the loop start and end. Will only loop if loop is set to true.\n   * @param loopStart The loop start time\n   * @param loopEnd The loop end time\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\").toDestination();\n   * // loop between the given points\n   * player.setLoopPoints(0.2, 0.3);\n   * player.loop = true;\n   * player.autostart = true;\n   */\n\n\n  setLoopPoints(loopStart, loopEnd) {\n    this.loopStart = loopStart;\n    this.loopEnd = loopEnd;\n    return this;\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(loopStart) {\n    this._loopStart = loopStart;\n\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n    } // get the current source\n\n\n    this._activeSources.forEach(source => {\n      source.loopStart = loopStart;\n    });\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(loopEnd) {\n    this._loopEnd = loopEnd;\n\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n    } // get the current source\n\n\n    this._activeSources.forEach(source => {\n      source.loopEnd = loopEnd;\n    });\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n\n\n  get loop() {\n    return this._loop;\n  }\n\n  set loop(loop) {\n    // if no change, do nothing\n    if (this._loop === loop) {\n      return;\n    }\n\n    this._loop = loop; // set the loop of all of the sources\n\n    this._activeSources.forEach(source => {\n      source.loop = loop;\n    });\n\n    if (loop) {\n      // remove the next stopEvent\n      const stopEvent = this._state.getNextState(\"stopped\", this.now());\n\n      if (stopEvent) {\n        this._state.cancel(stopEvent.time);\n      }\n    }\n  }\n  /**\n   * The playback speed. 1 is normal speed. This is not a signal because\n   * Safari and iOS currently don't support playbackRate as a signal.\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n    const now = this.now(); // cancel the stop event since it's at a different time now\n\n    const stopEvent = this._state.getNextState(\"stopped\", now);\n\n    if (stopEvent && stopEvent.implicitEnd) {\n      this._state.cancel(stopEvent.time);\n\n      this._activeSources.forEach(source => source.cancelStop());\n    } // set all the sources\n\n\n    this._activeSources.forEach(source => {\n      source.playbackRate.setValueAtTime(rate, now);\n    });\n  }\n  /**\n   * The direction the buffer should play in\n   */\n\n\n  get reverse() {\n    return this._buffer.reverse;\n  }\n\n  set reverse(rev) {\n    this._buffer.reverse = rev;\n  }\n  /**\n   * If the buffer is loaded\n   */\n\n\n  get loaded() {\n    return this._buffer.loaded;\n  }\n\n  dispose() {\n    super.dispose(); // disconnect all of the players\n\n    this._activeSources.forEach(source => source.dispose());\n\n    this._activeSources.clear();\n\n    this._buffer.dispose();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Player.prototype, \"fadeIn\", void 0);\n\n__decorate([timeRange(0)], Player.prototype, \"fadeOut\", void 0);","import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See {@link AudioToGain}.\n * @category Signal\n */\n\nexport class GainToAudio extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"GainToAudio\";\n    /**\n     * The node which converts the audio ranges\n     */\n\n    this._norm = new WaveShaper({\n      context: this.context,\n      mapping: x => Math.abs(x) * 2 - 1\n    });\n    /**\n     * The NormalRange input [0, 1]\n     */\n\n    this.input = this._norm;\n    /**\n     * The AudioRange output [-1, 1]\n     */\n\n    this.output = this._norm;\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._norm.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @offline 2 1\n * @example\n * const env = new Tone.Envelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1,\n * \trelease: 0.8,\n * }).toDestination();\n * env.triggerAttackRelease(0.5);\n * @category Component\n */\n\nexport class Envelope extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n\n    this._sig = new Signal({\n      context: this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n\n    this.output = this._sig;\n    /**\n     * Envelope has no input\n     */\n\n    this.input = undefined;\n    const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    this.attack = options.attack;\n    this.decay = options.decay;\n    this.sustain = options.sustain;\n    this.release = options.release;\n    this.attackCurve = options.attackCurve;\n    this.releaseCurve = options.releaseCurve;\n    this.decayCurve = options.decayCurve;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      attack: 0.01,\n      attackCurve: \"linear\",\n      decay: 0.1,\n      decayCurve: \"exponential\",\n      release: 1,\n      releaseCurve: \"exponential\",\n      sustain: 0.5\n    });\n  }\n  /**\n   * Read the current value of the envelope. Useful for\n   * synchronizing visual output to the envelope.\n   */\n\n\n  get value() {\n    return this.getValueAtTime(this.now());\n  }\n  /**\n   * Get the curve\n   * @param  curve\n   * @param  direction  In/Out\n   * @return The curve name\n   */\n\n\n  _getCurve(curve, direction) {\n    if (isString(curve)) {\n      return curve;\n    } else {\n      // look up the name in the curves array\n      let curveName;\n\n      for (curveName in EnvelopeCurves) {\n        if (EnvelopeCurves[curveName][direction] === curve) {\n          return curveName;\n        }\n      } // return the custom curve\n\n\n      return curve;\n    }\n  }\n  /**\n   * Assign a the curve to the given name using the direction\n   * @param  name\n   * @param  direction In/Out\n   * @param  curve\n   */\n\n\n  _setCurve(name, direction, curve) {\n    // check if it's a valid type\n    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n      const curveDef = EnvelopeCurves[curve];\n\n      if (isObject(curveDef)) {\n        if (name !== \"_decayCurve\") {\n          this[name] = curveDef[direction];\n        }\n      } else {\n        this[name] = curveDef;\n      }\n    } else if (isArray(curve) && name !== \"_decayCurve\") {\n      this[name] = curve;\n    } else {\n      throw new Error(\"Envelope: invalid curve: \" + curve);\n    }\n  }\n  /**\n   * The shape of the attack.\n   * Can be any of these strings:\n   * * \"linear\"\n   * * \"exponential\"\n   * * \"sine\"\n   * * \"cosine\"\n   * * \"bounce\"\n   * * \"ripple\"\n   * * \"step\"\n   *\n   * Can also be an array which describes the curve. Values\n   * in the array are evenly subdivided and linearly\n   * interpolated over the duration of the attack.\n   * @offline 1 1\n   * @example\n   * const env = new Tone.Envelope().toDestination();\n   * env.attackCurve = \"linear\";\n   * env.triggerAttack();\n   * @example\n   * const env = new Tone.Envelope().toDestination();\n   * // can also be an array\n   * env.attackCurve = [0, 0.2, 0.3, 0.4, 1];\n   * env.triggerAttack();\n   */\n\n\n  get attackCurve() {\n    return this._getCurve(this._attackCurve, \"In\");\n  }\n\n  set attackCurve(curve) {\n    this._setCurve(\"_attackCurve\", \"In\", curve);\n  }\n  /**\n   * The shape of the release. See the attack curve types.\n   * @offline 1 1\n   * @example\n   * const env = new Tone.Envelope({\n   * \trelease: 0.5\n   * });\n   * env.releaseCurve = \"linear\";\n   * env.triggerAttack();\n   * env.triggerRelease(0.5);\n   */\n\n\n  get releaseCurve() {\n    return this._getCurve(this._releaseCurve, \"Out\");\n  }\n\n  set releaseCurve(curve) {\n    this._setCurve(\"_releaseCurve\", \"Out\", curve);\n  }\n  /**\n   * The shape of the decay either \"linear\" or \"exponential\"\n   * @offline 1 1\n   * @example\n   * const env = new Tone.Envelope({\n   * \tsustain: 0.1,\n   * \tdecay: 0.5\n   * });\n   * env.decayCurve = \"linear\";\n   * env.triggerAttack();\n   */\n\n\n  get decayCurve() {\n    return this._decayCurve;\n  }\n\n  set decayCurve(curve) {\n    assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n    this._decayCurve = curve;\n  }\n  /**\n   * Trigger the attack/decay portion of the ADSR envelope.\n   * @param  time When the attack should start.\n   * @param velocity The velocity of the envelope scales the vales.\n   *                             number between 0-1\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n   * env.triggerAttack(\"+0.5\", 0.2);\n   */\n\n\n  triggerAttack(time, velocity = 1) {\n    this.log(\"triggerAttack\", time, velocity);\n    time = this.toSeconds(time);\n    const originalAttack = this.toSeconds(this.attack);\n    let attack = originalAttack;\n    const decay = this.toSeconds(this.decay); // check if it's not a complete attack\n\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      // subtract the current value from the attack time\n      const attackRate = 1 / attack;\n      const remainingDistance = 1 - currentValue; // the attack is now the remaining time\n\n      attack = remainingDistance / attackRate;\n    } // attack\n\n\n    if (attack < this.sampleTime) {\n      this._sig.cancelScheduledValues(time); // case where the attack time is 0 should set instantly\n\n\n      this._sig.setValueAtTime(velocity, time);\n    } else if (this._attackCurve === \"linear\") {\n      this._sig.linearRampTo(velocity, attack, time);\n    } else if (this._attackCurve === \"exponential\") {\n      this._sig.targetRampTo(velocity, attack, time);\n    } else {\n      this._sig.cancelAndHoldAtTime(time);\n\n      let curve = this._attackCurve; // find the starting position in the curve\n\n      for (let i = 1; i < curve.length; i++) {\n        // the starting index is between the two values\n        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n          curve = this._attackCurve.slice(i); // the first index is the current value\n\n          curve[0] = currentValue;\n          break;\n        }\n      }\n\n      this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n    } // decay\n\n\n    if (decay && this.sustain < 1) {\n      const decayValue = velocity * this.sustain;\n      const decayStart = time + attack;\n      this.log(\"decay\", decayStart);\n\n      if (this._decayCurve === \"linear\") {\n        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n      } else {\n        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Triggers the release of the envelope.\n   * @param  time When the release portion of the envelope should start.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator({\n   * \ttype: \"sawtooth\"\n   * }).connect(env).start();\n   * env.triggerAttack();\n   * // trigger the release half a second after the attack\n   * env.triggerRelease(\"+0.5\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    time = this.toSeconds(time);\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      const release = this.toSeconds(this.release);\n\n      if (release < this.sampleTime) {\n        this._sig.setValueAtTime(0, time);\n      } else if (this._releaseCurve === \"linear\") {\n        this._sig.linearRampTo(0, release, time);\n      } else if (this._releaseCurve === \"exponential\") {\n        this._sig.targetRampTo(0, release, time);\n      } else {\n        assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\n        this._sig.cancelAndHoldAtTime(time);\n\n        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get the scheduled value at the given time. This will\n   * return the unconverted (raw) value.\n   */\n\n\n  getValueAtTime(time) {\n    return this._sig.getValueAtTime(time);\n  }\n  /**\n   * triggerAttackRelease is shorthand for triggerAttack, then waiting\n   * some duration, then triggerRelease.\n   * @param duration The duration of the sustain.\n   * @param time When the attack should be triggered.\n   * @param velocity The velocity of the envelope.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the release 0.5 seconds after the attack\n   * env.triggerAttackRelease(0.5);\n   */\n\n\n  triggerAttackRelease(duration, time, velocity = 1) {\n    time = this.toSeconds(time);\n    this.triggerAttack(time, velocity);\n    this.triggerRelease(time + this.toSeconds(duration));\n    return this;\n  }\n  /**\n   * Cancels all scheduled envelope changes after the given time.\n   */\n\n\n  cancel(after) {\n    this._sig.cancelScheduledValues(this.toSeconds(after));\n\n    return this;\n  }\n  /**\n   * Connect the envelope to a destination node.\n   */\n\n\n  connect(destination, outputNumber = 0, inputNumber = 0) {\n    connectSignal(this, destination, outputNumber, inputNumber);\n    return this;\n  }\n  /**\n   * Render the envelope curve to an array of the given length.\n   * Good for visualizing the envelope curve. Rescales the duration of the\n   * envelope to fit the length.\n   */\n\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const duration = length / this.context.sampleRate;\n      const context = new OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time\n\n      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n      const envelopeDuration = attackPortion + this.toSeconds(this.release);\n      const sustainTime = envelopeDuration * 0.1;\n      const totalDuration = envelopeDuration + sustainTime; // @ts-ignore\n\n      const clone = new this.constructor(Object.assign(this.get(), {\n        attack: duration * this.toSeconds(this.attack) / totalDuration,\n        decay: duration * this.toSeconds(this.decay) / totalDuration,\n        release: duration * this.toSeconds(this.release) / totalDuration,\n        context\n      }));\n\n      clone._sig.toDestination();\n\n      clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n      const buffer = yield context.render();\n      return buffer.getChannelData(0);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._sig.dispose();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n\n__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\n\n\nconst EnvelopeCurves = (() => {\n  const curveLen = 128;\n  let i;\n  let k; // cosine curve\n\n  const cosineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  } // ripple curve\n\n\n  const rippleCurve = [];\n  const rippleCurveFreq = 6.4;\n\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n\n  rippleCurve[curveLen - 1] = 1; // stairs curve\n\n  const stairsCurve = [];\n  const steps = 5;\n\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  } // in-out easing curve\n\n\n  const sineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  } // a bounce curve\n\n\n  const bounceCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    const freq = Math.pow(k, 3) * 4 + 0.2;\n    const val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n\n\n  function invertCurve(curve) {\n    const out = new Array(curve.length);\n\n    for (let j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n\n\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n\n\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n})();","import { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base-class for all instruments\n */\n\nexport class Instrument extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Instrument.getDefaults(), arguments));\n    /**\n     * Keep track of all events scheduled to the transport\n     * when the instrument is 'synced'\n     */\n\n    this._scheduledEvents = [];\n    /**\n     * If the instrument is currently synced\n     */\n\n    this._synced = false;\n    this._original_triggerAttack = this.triggerAttack;\n    this._original_triggerRelease = this.triggerRelease;\n    const options = optionsFromArguments(Instrument.getDefaults(), arguments);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      volume: 0\n    });\n  }\n  /**\n   * Sync the instrument to the Transport. All subsequent calls of\n   * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n   * @example\n   * const fmSynth = new Tone.FMSynth().toDestination();\n   * fmSynth.volume.value = -6;\n   * fmSynth.sync();\n   * // schedule 3 notes when the transport first starts\n   * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n   * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n   * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n   * // start the transport to hear the notes\n   * Tone.Transport.start();\n   */\n\n\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 0);\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the given method so that it can be synchronized\n   * @param method Which method to wrap and sync\n   * @param  timePosition What position the time argument appears in\n   */\n\n\n  _syncMethod(method, timePosition) {\n    const originalMethod = this[\"_original_\" + method] = this[method];\n\n    this[method] = (...args) => {\n      const time = args[timePosition];\n      const id = this.context.transport.schedule(t => {\n        args[timePosition] = t;\n        originalMethod.apply(this, args);\n      }, time);\n\n      this._scheduledEvents.push(id);\n    };\n  }\n  /**\n   * Unsync the instrument from the Transport\n   */\n\n\n  unsync() {\n    this._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\n    this._scheduledEvents = [];\n\n    if (this._synced) {\n      this._synced = false;\n      this.triggerAttack = this._original_triggerAttack;\n      this.triggerRelease = this._original_triggerRelease;\n    }\n\n    return this;\n  }\n  /**\n   * Trigger the attack and then the release after the duration.\n   * @param  note     The note to trigger.\n   * @param  duration How long the note should be held for before\n   *                         triggering the release. This value must be greater than 0.\n   * @param time  When the note should be triggered.\n   * @param  velocity The velocity the note should be triggered at.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger \"C4\" for the duration of an 8th note\n   * synth.triggerAttackRelease(\"C4\", \"8n\");\n   */\n\n\n  triggerAttackRelease(note, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    const computedDuration = this.toSeconds(duration);\n    this.triggerAttack(note, computedTime, velocity);\n    this.triggerRelease(computedTime + computedDuration);\n    return this;\n  }\n  /**\n   * clean up\n   * @returns {Instrument} this\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._volume.dispose();\n\n    this.unsync();\n    this._scheduledEvents = [];\n    return this;\n  }\n\n}","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\n\nexport class Monophonic extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Monophonic.getDefaults(), arguments));\n    const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    this.portamento = options.portamento;\n    this.onsilence = options.onsilence;\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      detune: 0,\n      onsilence: noOp,\n      portamento: 0\n    });\n  }\n  /**\n   * Trigger the attack of the note optionally with a given velocity.\n   * @param  note The note to trigger.\n   * @param  time When the note should start.\n   * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger the note a half second from now at half velocity\n   * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n   */\n\n\n  triggerAttack(note, time, velocity = 1) {\n    this.log(\"triggerAttack\", note, time, velocity);\n    const seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeAttack(seconds, velocity);\n\n    this.setNote(note, seconds);\n    return this;\n  }\n  /**\n   * Trigger the release portion of the envelope\n   * @param  time If no time is given, the release happens immediatly\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // trigger the release a second from now\n   * synth.triggerRelease(\"+1\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    const seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeRelease(seconds);\n\n    return this;\n  }\n  /**\n   * Set the note at the given time. If no time is given, the note\n   * will set immediately.\n   * @param note The note to change to.\n   * @param  time The time when the note should be set.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // change to F#6 in one quarter note from now.\n   * synth.setNote(\"F#6\", \"+4n\");\n   */\n\n\n  setNote(note, time) {\n    const computedTime = this.toSeconds(time);\n    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\n    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n      const portTime = this.toSeconds(this.portamento);\n      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n    } else {\n      this.frequency.setValueAtTime(computedFrequency, computedTime);\n    }\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope } from \"./Envelope\";\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * const ampEnv = new Tone.AmplitudeEnvelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1.0,\n * \trelease: 0.8\n * }).toDestination();\n * // create an oscillator and connect it\n * const osc = new Tone.Oscillator().connect(ampEnv).start();\n * // trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\n\nexport class AmplitudeEnvelope extends Envelope {\n  constructor() {\n    super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"AmplitudeEnvelope\";\n    this._gainNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    this.output = this._gainNode;\n    this.input = this._gainNode;\n\n    this._sig.connect(this._gainNode.gain);\n\n    this.output = this._gainNode;\n    this.input = this._gainNode;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._gainNode.dispose();\n\n    return this;\n  }\n\n}","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic } from \"./Monophonic\";\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\n\nexport class Synth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(Synth.getDefaults(), arguments));\n    this.name = \"Synth\";\n    const options = optionsFromArguments(Synth.getDefaults(), arguments);\n    this.oscillator = new OmniOscillator(Object.assign({\n      context: this.context,\n      detune: options.detune,\n      onstop: () => this.onsilence(this)\n    }, options.oscillator));\n    this.frequency = this.oscillator.frequency;\n    this.detune = this.oscillator.detune;\n    this.envelope = new AmplitudeEnvelope(Object.assign({\n      context: this.context\n    }, options.envelope)); // connect the oscillators to the output\n\n    this.oscillator.chain(this.envelope, this.output);\n    readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.005,\n        decay: 0.1,\n        release: 1,\n        sustain: 0.3\n      }),\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"triangle\"\n      })\n    });\n  }\n  /**\n   * start the attack portion of the envelope\n   * @param time the time the attack should start\n   * @param velocity the velocity of the note (0-1)\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // the envelopes\n    this.envelope.triggerAttack(time, velocity);\n    this.oscillator.start(time); // if there is no release portion, stop the oscillator\n\n    if (this.envelope.sustain === 0) {\n      const computedAttack = this.toSeconds(this.envelope.attack);\n      const computedDecay = this.toSeconds(this.envelope.decay);\n      this.oscillator.stop(time + computedAttack + computedDecay);\n    }\n  }\n  /**\n   * start the release portion of the envelope\n   * @param time the time the release should start\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n    this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.oscillator.dispose();\n    this.envelope.dispose();\n    return this;\n  }\n\n}","import { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Monophonic } from \"./Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Synth } from \"./Synth\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n/**\n * Base class for both AM and FM synths\n */\n\nexport class ModulationSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(ModulationSynth.getDefaults(), arguments));\n    this.name = \"ModulationSynth\";\n    const options = optionsFromArguments(ModulationSynth.getDefaults(), arguments);\n    this._carrier = new Synth({\n      context: this.context,\n      oscillator: options.oscillator,\n      envelope: options.envelope,\n      onsilence: () => this.onsilence(this),\n      volume: -10\n    });\n    this._modulator = new Synth({\n      context: this.context,\n      oscillator: options.modulation,\n      envelope: options.modulationEnvelope,\n      volume: -10\n    });\n    this.oscillator = this._carrier.oscillator;\n    this.envelope = this._carrier.envelope;\n    this.modulation = this._modulator.oscillator;\n    this.modulationEnvelope = this._modulator.envelope;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\"\n    });\n    this.detune = new Signal({\n      context: this.context,\n      value: options.detune,\n      units: \"cents\"\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      value: options.harmonicity,\n      minValue: 0\n    });\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    readOnly(this, [\"frequency\", \"harmonicity\", \"oscillator\", \"envelope\", \"modulation\", \"modulationEnvelope\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      harmonicity: 3,\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"sine\"\n      }),\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.01,\n        decay: 0.01,\n        sustain: 1,\n        release: 0.5\n      }),\n      modulation: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"square\"\n      }),\n      modulationEnvelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.5,\n        decay: 0.0,\n        sustain: 1,\n        release: 0.5\n      })\n    });\n  }\n  /**\n   * Trigger the attack portion of the note\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // @ts-ignore\n    this._carrier._triggerEnvelopeAttack(time, velocity); // @ts-ignore\n\n\n    this._modulator._triggerEnvelopeAttack(time, velocity);\n  }\n  /**\n   * Trigger the release portion of the note\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    // @ts-ignore\n    this._carrier._triggerEnvelopeRelease(time); // @ts-ignore\n\n\n    this._modulator._triggerEnvelopeRelease(time);\n\n    return this;\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    this.harmonicity.dispose();\n\n    this._modulationNode.dispose();\n\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { ModulationSynth } from \"./ModulationSynth\";\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n * @example\n * const fmSynth = new Tone.FMSynth().toDestination();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n *\n * @category Instrument\n */\n\nexport class FMSynth extends ModulationSynth {\n  constructor() {\n    super(optionsFromArguments(FMSynth.getDefaults(), arguments));\n    this.name = \"FMSynth\";\n    const options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n    this.modulationIndex = new Multiply({\n      context: this.context,\n      value: options.modulationIndex\n    }); // control the two voices frequency\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.frequency.chain(this.modulationIndex, this._modulationNode);\n    this.detune.fan(this._carrier.detune, this._modulator.detune);\n\n    this._modulator.connect(this._modulationNode.gain);\n\n    this._modulationNode.connect(this._carrier.frequency);\n\n    this._carrier.connect(this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(ModulationSynth.getDefaults(), {\n      modulationIndex: 10\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.modulationIndex.dispose();\n    return this;\n  }\n\n}","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\n\nexport class MembraneSynth extends Synth {\n  constructor() {\n    super(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n    this.name = \"MembraneSynth\";\n    /**\n     * Portamento is ignored in this synth. use pitch decay instead.\n     */\n\n    this.portamento = 0;\n    const options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n    this.pitchDecay = options.pitchDecay;\n    this.octaves = options.octaves;\n    readOnly(this, [\"oscillator\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n      envelope: {\n        attack: 0.001,\n        attackCurve: \"exponential\",\n        decay: 0.4,\n        release: 1.4,\n        sustain: 0.01\n      },\n      octaves: 10,\n      oscillator: {\n        type: \"sine\"\n      },\n      pitchDecay: 0.05\n    });\n  }\n\n  setNote(note, time) {\n    const seconds = this.toSeconds(time);\n    const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n    const maxNote = hertz * this.octaves;\n    this.oscillator.frequency.setValueAtTime(maxNote, seconds);\n    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    return this;\n  }\n\n}\n\n__decorate([range(0)], MembraneSynth.prototype, \"octaves\", void 0);\n\n__decorate([timeRange(0)], MembraneSynth.prototype, \"pitchDecay\", void 0);","const workletContext = new Set();\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\n\nexport function addToWorklet(classOrFunction) {\n  workletContext.add(classOrFunctionToString(classOrFunction));\n}\n/**\n * Converts a class or a function to a string so it can be used in the worklet context\n */\n\nfunction classOrFunctionToString(classOrFunction) {\n  const regexp = new RegExp(/class.*extends.*\\{/m);\n  const matches = classOrFunction.toString().match(regexp);\n\n  if (matches) {\n    // if it extends another class, get that class name\n    return classOrFunction.toString().replace(matches[0], `class ${classOrFunction.name} extends ${Object.getPrototypeOf(classOrFunction).name} {`);\n  } else {\n    // otherwise just return the class as a string\n    return classOrFunction.toString();\n  }\n}\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\n\n\nexport function registerProcessor(name, classDesc) {\n  const processor =\n  /* javascript */\n  `registerProcessor(\"${name}\", ${classOrFunctionToString(classDesc)})`;\n  workletContext.add(processor);\n}\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\n\nexport function getWorkletGlobalScope() {\n  return Array.from(workletContext).join(\"\\n\");\n}","import { AudioWorkletProcessor } from \"./AudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\n/**\n * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]].\n */\n\nexport class ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n  constructor(options) {\n    super(options);\n    /**\n     * If the processor was disposed or not. Keep alive until it's disposed.\n     */\n\n    this.disposed = false;\n    /**\n     * The number of samples in the processing block\n     */\n\n    this.blockSize = 128;\n    /**\n     * the sample rate\n     */\n    // @ts-ignore\n\n    this.sampleRate = sampleRate;\n\n    this.port.onmessage = event => {\n      // when it receives a dispose \n      if (event.data === \"dispose\") {\n        this.disposed = true;\n      }\n    };\n  }\n\n}\naddToWorklet(ToneAudioWorkletProcessor);","/**\n * This is just an interface for the AudioWorkletProcessor\n */\nexport class AudioWorkletProcessor {\n  constructor(_options) {\n    this.parameterDescriptors = [];\n    this.port = new MessagePort();\n  }\n\n  process(_inputs, _outputs, _parameters) {\n    return false;\n  }\n\n}","import { ToneAudioWorkletProcessor } from \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\nexport class SingleIOProcessor extends ToneAudioWorkletProcessor {\n  constructor(options) {\n    super(Object.assign(options, {\n      numberOfInputs: 1,\n      numberOfOutputs: 1\n    }));\n    /**\n     * Holds the name of the parameter and a single value of that\n     * parameter at the current sample\n     */\n\n    this.params = {};\n  }\n  /**\n   * Update the private `params` object with the\n   * values of the parameters at the given index\n   */\n\n\n  updateParams(parameters, index) {\n    for (const paramName in parameters) {\n      const param = parameters[paramName];\n\n      if (param.length > 1) {\n        this.params[paramName] = parameters[paramName][index];\n      } else {\n        this.params[paramName] = parameters[paramName][0];\n      }\n    }\n  }\n  /**\n   * Process a single frame of the audio\n   */\n\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0]; // get the parameter values\n\n    const channelCount = Math.max((input === null || input === void 0 ? void 0 : input.length) || 0, output.length);\n\n    for (let sample = 0; sample < this.blockSize; sample++) {\n      this.updateParams(parameters, sample);\n\n      for (let channel = 0; channel < channelCount; channel++) {\n        const inputSample = (input === null || input === void 0 ? void 0 : input.length) ? input[channel][sample] : 0;\n        output[channel][sample] = this.generate(inputSample, channel, this.params);\n      }\n    }\n\n    return !this.disposed;\n  }\n\n}\n;\naddToWorklet(SingleIOProcessor);","import { addToWorklet } from \"./WorkletGlobalScope\";\n/**\n * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n */\n\nexport class DelayLine {\n  constructor(size, channels) {\n    this.buffer = [];\n    this.writeHead = [];\n    this.size = size; // create the empty channels\n\n    for (let i = 0; i < channels; i++) {\n      this.buffer[i] = new Float32Array(this.size);\n      this.writeHead[i] = 0;\n    }\n  }\n  /**\n   * Push a value onto the end\n   */\n\n\n  push(channel, value) {\n    this.writeHead[channel] += 1;\n\n    if (this.writeHead[channel] > this.size) {\n      this.writeHead[channel] = 0;\n    }\n\n    this.buffer[channel][this.writeHead[channel]] = value;\n  }\n  /**\n   * Get the recorded value of the channel given the delay\n   */\n\n\n  get(channel, delay) {\n    let readHead = this.writeHead[channel] - Math.floor(delay);\n\n    if (readHead < 0) {\n      readHead += this.size;\n    }\n\n    return this.buffer[channel][readHead];\n  }\n\n}\naddToWorklet(DelayLine);","import { SingleIOProcessor } from \"../../core/worklet/SingleIOProcessor.worklet\";\nimport \"../../core/worklet/DelayLine.worklet\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope\";\nexport const workletName = \"feedback-comb-filter\";\nexport class FeedbackCombFilterWorklet extends SingleIOProcessor {\n  constructor(options) {\n    super(options); // @ts-ignore\n\n    this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n  }\n\n  static get parameterDescriptors() {\n    return [{\n      name: \"delayTime\",\n      defaultValue: 0.1,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      name: \"feedback\",\n      defaultValue: 0.5,\n      minValue: 0,\n      maxValue: 0.9999\n    }];\n  }\n\n  generate(input, channel, parameters) {\n    const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n    this.delayLine.push(channel, input + delayedSample * parameters.feedback); // console.log(channel);\n\n    return delayedSample;\n  }\n\n}\nregisterProcessor(workletName, FeedbackCombFilterWorklet);","import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tC1: \"C1.mp3\",\n * \t\tC2: \"C2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/examples/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t},\n * });\n * @category Instrument\n */\n\nexport class Sampler extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n    this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n\n    this._activeSources = new Map();\n    const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    const urlMap = {};\n    Object.keys(options.urls).forEach(note => {\n      const noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        const mid = new FrequencyClass(this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    this.attack = options.attack;\n    this.release = options.release;\n    this.curve = options.curve; // invoke the callback if it's already loaded\n\n    if (this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      attack: 0,\n      baseUrl: \"\",\n      curve: \"exponential\",\n      onload: noOp,\n      onerror: noOp,\n      release: 0.1,\n      urls: {}\n    });\n  }\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   */\n\n\n  _findClosest(midi) {\n    // searches within 8 octaves of the given midi note\n    const MAX_INTERVAL = 96;\n    let interval = 0;\n\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n\n      interval++;\n    }\n\n    throw new Error(`No available buffers for note: ${midi}`);\n  }\n  /**\n   * @param  notes\tThe note to play, or an array of notes.\n   * @param  time     When to play the note\n   * @param  velocity The velocity to play the sample back.\n   */\n\n\n  triggerAttack(notes, time, velocity = 1) {\n    this.log(\"triggerAttack\", notes, time, velocity);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi(); // find the closest note pitch\n\n      const difference = this._findClosest(midi);\n\n      const closestNote = midi - difference;\n\n      const buffer = this._buffers.get(closestNote);\n\n      const playbackRate = intervalToFrequencyRatio(difference); // play that note\n\n      const source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        curve: this.curve,\n        fadeIn: this.attack,\n        fadeOut: this.release,\n        playbackRate\n      }).connect(this.output);\n      source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources\n\n      if (!isArray(this._activeSources.get(midi))) {\n        this._activeSources.set(midi, []);\n      }\n\n      this._activeSources.get(midi).push(source); // remove it when it's done\n\n\n      source.onended = () => {\n        if (this._activeSources && this._activeSources.has(midi)) {\n          const sources = this._activeSources.get(midi);\n\n          const index = sources.indexOf(source);\n\n          if (index !== -1) {\n            sources.splice(index, 1);\n          }\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * @param  notes\tThe note to release, or an array of notes.\n   * @param  time     \tWhen to release the note.\n   */\n\n\n  triggerRelease(notes, time) {\n    this.log(\"triggerRelease\", notes, time);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi(); // find the note\n\n      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n        const sources = this._activeSources.get(midi);\n\n        time = this.toSeconds(time);\n        sources.forEach(source => {\n          source.stop(time);\n        });\n\n        this._activeSources.set(midi, []);\n      }\n    });\n    return this;\n  }\n  /**\n   * Release all currently active notes.\n   * @param  time     \tWhen to release the notes.\n   */\n\n\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(sources => {\n      while (sources.length) {\n        const source = sources.shift();\n        source.stop(computedTime);\n      }\n    });\n\n    return this;\n  }\n\n  sync() {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 1);\n\n    return this;\n  }\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  notes\tThe note to play and release, or an array of notes.\n   * @param  duration The time the note should be held\n   * @param  time     When to start the attack\n   * @param  velocity The velocity of the attack\n   */\n\n\n  triggerAttackRelease(notes, duration, time, velocity = 1) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"notes must be an array when duration is array\");\n      notes.forEach((note, index) => {\n        const d = duration[Math.min(index, duration.length - 1)];\n        this.triggerRelease(note, computedTime + this.toSeconds(d));\n      });\n    } else {\n      this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n    }\n\n    return this;\n  }\n  /**\n   * Add a note to the sampler.\n   * @param  note      The buffer's pitch.\n   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   */\n\n\n  add(note, url, callback) {\n    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\n    if (isNote(note)) {\n      // convert the note name to MIDI\n      const mid = new FrequencyClass(this.context, note).toMidi();\n\n      this._buffers.add(mid, url, callback);\n    } else {\n      // otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    }\n\n    return this;\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return this._buffers.loaded;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._buffers.dispose();\n\n    this._activeSources.forEach(sources => {\n      sources.forEach(source => source.dispose());\n    });\n\n    this._activeSources.clear();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * const crossFade = new Tone.CrossFade().toDestination();\n * // connect two inputs Tone.to a/b\n * const inputA = new Tone.Oscillator(440, \"square\").connect(crossFade.a).start();\n * const inputB = new Tone.Oscillator(440, \"sine\").connect(crossFade.b).start();\n * // use the fade to control the mix between the two\n * crossFade.fade.value = 0.5;\n * @category Component\n */\n\nexport class CrossFade extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n    this.name = \"CrossFade\";\n    /**\n     * The crossfading is done by a StereoPannerNode\n     */\n\n    this._panner = this.context.createStereoPanner();\n    /**\n     * Split the output of the panner node into two values used to control the gains.\n     */\n\n    this._split = this.context.createChannelSplitter(2);\n    /**\n     * Convert the fade value into an audio range value so it can be connected\n     * to the panner.pan AudioParam\n     */\n\n    this._g2a = new GainToAudio({\n      context: this.context\n    });\n    /**\n     * The input which is at full level when fade = 0\n     */\n\n    this.a = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The input which is at full level when fade = 1\n     */\n\n    this.b = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The output is a mix between `a` and `b` at the ratio of `fade`\n     */\n\n    this.output = new Gain({\n      context: this.context\n    });\n    this._internalChannels = [this.a, this.b];\n    const options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n    this.fade = new Signal({\n      context: this.context,\n      units: \"normalRange\",\n      value: options.fade\n    });\n    readOnly(this, \"fade\");\n    this.context.getConstant(1).connect(this._panner);\n\n    this._panner.connect(this._split); // this is necessary for standardized-audio-context\n    // doesn't make any difference for the native AudioContext\n    // https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\n\n    this._panner.channelCount = 1;\n    this._panner.channelCountMode = \"explicit\";\n    connect(this._split, this.a.gain, 0);\n    connect(this._split, this.b.gain, 1);\n    this.fade.chain(this._g2a, this._panner.pan);\n    this.a.connect(this.output);\n    this.b.connect(this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      fade: 0.5\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.a.dispose();\n    this.b.dispose();\n    this.output.dispose();\n    this.fade.dispose();\n\n    this._g2a.dispose();\n\n    this._panner.disconnect();\n\n    this._split.disconnect();\n\n    return this;\n  }\n\n}","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\n\nexport class Effect extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"Effect\";\n    /**\n     * the drywet knob to control the amount of effect\n     */\n\n    this._dryWet = new CrossFade({\n      context: this.context\n    });\n    /**\n     * The wet control is how much of the effected\n     * will pass through to the output. 1 = 100% effected\n     * signal, 0 = 100% dry signal.\n     */\n\n    this.wet = this._dryWet.fade;\n    /**\n     * connect the effectSend to the input of hte effect\n     */\n\n    this.effectSend = new Gain({\n      context: this.context\n    });\n    /**\n     * connect the output of the effect to the effectReturn\n     */\n\n    this.effectReturn = new Gain({\n      context: this.context\n    });\n    /**\n     * The effect input node\n     */\n\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * The effect output\n     */\n\n    this.output = this._dryWet; // connections\n\n    this.input.fan(this._dryWet.a, this.effectSend);\n    this.effectReturn.connect(this._dryWet.b);\n    this.wet.setValueAtTime(options.wet, 0);\n    this._internalChannels = [this.effectReturn, this.effectSend];\n    readOnly(this, \"wet\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      wet: 1\n    });\n  }\n  /**\n   * chains the effect in between the effectSend and effectReturn\n   */\n\n\n  connectEffect(effect) {\n    // add it to the internal channels\n    this._internalChannels.push(effect);\n\n    this.effectSend.chain(effect, this.effectReturn);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dryWet.dispose();\n\n    this.effectSend.dispose();\n    this.effectReturn.dispose();\n    this.wet.dispose();\n    return this;\n  }\n\n}","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @offline 0.5 2\n * @example\n * // move the input signal from right to left\n * const panner = new Tone.Panner(1).toDestination();\n * panner.pan.rampTo(-1, 0.5);\n * const osc = new Tone.Oscillator(100).connect(panner).start();\n * @category Component\n */\n\nexport class Panner extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n    this.name = \"Panner\";\n    /**\n     * the panner node\n     */\n\n    this._panner = this.context.createStereoPanner();\n    this.input = this._panner;\n    this.output = this._panner;\n    const options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n    this.pan = new Param({\n      context: this.context,\n      param: this._panner.pan,\n      value: options.pan,\n      minValue: -1,\n      maxValue: 1\n    }); // this is necessary for standardized-audio-context\n    // doesn't make any difference for the native AudioContext\n    // https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\n    this._panner.channelCount = options.channelCount;\n    this._panner.channelCountMode = \"explicit\"; // initial value\n\n    readOnly(this, \"pan\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      pan: 0,\n      channelCount: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panner.disconnect();\n\n    this.pan.dispose();\n    return this;\n  }\n\n}","import { SingleIOProcessor } from \"../core/worklet/SingleIOProcessor.worklet\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope\";\nexport const workletName = \"bit-crusher\";\nexport default class BitCrusherWorklet extends SingleIOProcessor {\n  static get parameterDescriptors() {\n    return [{\n      name: \"bits\",\n      defaultValue: 12,\n      minValue: 1,\n      maxValue: 16\n    }];\n  }\n\n  generate(input, _channel, parameters) {\n    const step = Math.pow(0.5, parameters.bits - 1);\n    const val = step * Math.floor(input / step + 0.5);\n    return val;\n  }\n\n}\nregisterProcessor(workletName, BitCrusherWorklet);","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * const merge = new Tone.Merge().toDestination();\n * // routing a sine tone in the left channel\n * const osc = new Tone.Oscillator().connect(merge, 0, 0).start();\n * // and noise in the right channel\n * const noise = new Tone.Noise().connect(merge, 0, 1).start();;\n * @category Component\n */\n\nexport class Merge extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n    this.name = \"Merge\";\n    const options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n    this._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      channels: 2\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._merger.disconnect();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nexport class Reverb extends Effect {\n  constructor() {\n    super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    this._convolver = this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    this.ready = Promise.resolve();\n    const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    this._decay = options.decay;\n    this._preDelay = options.preDelay;\n    this.generate();\n    this.connectEffect(this._convolver);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  }\n  /**\n   * The duration of the reverb.\n   */\n\n\n  get decay() {\n    return this._decay;\n  }\n\n  set decay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0.001);\n    this._decay = time;\n    this.generate();\n  }\n  /**\n   * The amount of time before the reverb is fully ramped in.\n   */\n\n\n  get preDelay() {\n    return this._preDelay;\n  }\n\n  set preDelay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0);\n    this._preDelay = time;\n    this.generate();\n  }\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n\n\n  generate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n\n      const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n      const noiseL = new Noise({\n        context\n      });\n      const noiseR = new Noise({\n        context\n      });\n      const merge = new Merge({\n        context\n      });\n      noiseL.connect(merge, 0, 0);\n      noiseR.connect(merge, 0, 1);\n      const gainNode = new Gain({\n        context\n      }).toDestination();\n      merge.connect(gainNode);\n      noiseL.start(0);\n      noiseR.start(0); // predelay\n\n      gainNode.gain.setValueAtTime(0, 0);\n      gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer\n\n      const renderPromise = context.render();\n      this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n      yield previousReady; // set the buffer\n\n      this._convolver.buffer = (yield renderPromise).get();\n      return this;\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._convolver.disconnect();\n\n    return this;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\n\nexport class Solo extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n    this.name = \"Solo\";\n    const options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n    this.input = this.output = new Gain({\n      context: this.context\n    });\n\n    if (!Solo._allSolos.has(this.context)) {\n      Solo._allSolos.set(this.context, new Set());\n    }\n\n    Solo._allSolos.get(this.context).add(this); // set initially\n\n\n    this.solo = options.solo;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      solo: false\n    });\n  }\n  /**\n   * Isolates this instance and mutes all other instances of Solo.\n   * Only one instance can be soloed at a time. A soloed\n   * instance will report `solo=false` when another instance is soloed.\n   */\n\n\n  get solo() {\n    return this._isSoloed();\n  }\n\n  set solo(solo) {\n    if (solo) {\n      this._addSolo();\n    } else {\n      this._removeSolo();\n    }\n\n    Solo._allSolos.get(this.context).forEach(instance => instance._updateSolo());\n  }\n  /**\n   * If the current instance is muted, i.e. another instance is soloed\n   */\n\n\n  get muted() {\n    return this.input.gain.value === 0;\n  }\n  /**\n   * Add this to the soloed array\n   */\n\n\n  _addSolo() {\n    if (!Solo._soloed.has(this.context)) {\n      Solo._soloed.set(this.context, new Set());\n    }\n\n    Solo._soloed.get(this.context).add(this);\n  }\n  /**\n   * Remove this from the soloed array\n   */\n\n\n  _removeSolo() {\n    if (Solo._soloed.has(this.context)) {\n      Solo._soloed.get(this.context).delete(this);\n    }\n  }\n  /**\n   * Is this on the soloed array\n   */\n\n\n  _isSoloed() {\n    return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);\n  }\n  /**\n   * Returns true if no one is soloed\n   */\n\n\n  _noSolos() {\n    // either does not have any soloed added\n    return !Solo._soloed.has(this.context) || // or has a solo set but doesn't include any items\n    Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;\n  }\n  /**\n   * Solo the current instance and unsolo all other instances.\n   */\n\n\n  _updateSolo() {\n    if (this._isSoloed()) {\n      this.input.gain.value = 1;\n    } else if (this._noSolos()) {\n      // no one is soloed\n      this.input.gain.value = 1;\n    } else {\n      this.input.gain.value = 0;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    Solo._allSolos.get(this.context).delete(this);\n\n    this._removeSolo();\n\n    return this;\n  }\n\n}\n/**\n * Hold all of the solo'ed tracks belonging to a specific context\n */\n\nSolo._allSolos = new Map();\n/**\n * Hold the currently solo'ed instance(s)\n */\n\nSolo._soloed = new Map();","import { readOnly } from \"../../core/util/Interface\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Panner } from \"./Panner\";\nimport { Volume } from \"./Volume\";\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\n\nexport class PanVol extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]));\n    this.name = \"PanVol\";\n    const options = optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]);\n    this._panner = this.input = new Panner({\n      context: this.context,\n      pan: options.pan,\n      channelCount: options.channelCount\n    });\n    this.pan = this._panner.pan;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume; // connections\n\n    this._panner.connect(this._volume);\n\n    this.mute = options.mute;\n    readOnly(this, [\"pan\", \"volume\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      pan: 0,\n      volume: 0,\n      channelCount: 1\n    });\n  }\n  /**\n   * Mute/unmute the volume\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panner.dispose();\n\n    this.pan.dispose();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Solo } from \"./Solo\";\nimport { PanVol } from \"./PanVol\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Gain } from \"../../core/context/Gain\";\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls.\n * See [[PanVol]] and [[Solo]]\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\n\nexport class Channel extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]));\n    this.name = \"Channel\";\n    const options = optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]);\n    this._solo = this.input = new Solo({\n      solo: options.solo,\n      context: this.context\n    });\n    this._panVol = this.output = new PanVol({\n      context: this.context,\n      pan: options.pan,\n      volume: options.volume,\n      mute: options.mute\n    });\n    this.pan = this._panVol.pan;\n    this.volume = this._panVol.volume;\n\n    this._solo.connect(this._panVol);\n\n    readOnly(this, [\"pan\", \"volume\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      pan: 0,\n      volume: 0,\n      mute: false,\n      solo: false\n    });\n  }\n  /**\n   * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances\n   */\n\n\n  get solo() {\n    return this._solo.solo;\n  }\n\n  set solo(solo) {\n    this._solo.solo = solo;\n  }\n  /**\n   * If the current instance is muted, i.e. another instance is soloed,\n   * or the channel is muted\n   */\n\n\n  get muted() {\n    return this._solo.muted || this.mute;\n  }\n  /**\n   * Mute/unmute the volume\n   */\n\n\n  get mute() {\n    return this._panVol.mute;\n  }\n\n  set mute(mute) {\n    this._panVol.mute = mute;\n  }\n  /**\n   * Get the gain node belonging to the bus name. Create it if\n   * it doesn't exist\n   * @param name The bus name\n   */\n\n\n  _getBus(name) {\n    if (!Channel.buses.has(name)) {\n      Channel.buses.set(name, new Gain({\n        context: this.context\n      }));\n    }\n\n    return Channel.buses.get(name);\n  }\n  /**\n   * Send audio to another channel using a string. `send` is a lot like\n   * [[connect]], except it uses a string instead of an object. This can\n   * be useful in large applications to decouple sections since [[send]]\n   * and [[receive]] can be invoked separately in order to connect an object\n   * @param name The channel name to send the audio\n   * @param volume The amount of the signal to send.\n   * \tDefaults to 0db, i.e. send the entire signal\n   * @returns Returns the gain node of this connection.\n   */\n\n\n  send(name, volume = 0) {\n    const bus = this._getBus(name);\n\n    const sendKnob = new Gain({\n      context: this.context,\n      units: \"decibels\",\n      gain: volume\n    });\n    this.connect(sendKnob);\n    sendKnob.connect(bus);\n    return sendKnob;\n  }\n  /**\n   * Receive audio from a channel which was connected with [[send]].\n   * @param name The channel name to receive audio from.\n   */\n\n\n  receive(name) {\n    const bus = this._getBus(name);\n\n    bus.connect(this);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panVol.dispose();\n\n    this.pan.dispose();\n    this.volume.dispose();\n\n    this._solo.dispose();\n\n    return this;\n  }\n\n}\n/**\n * Store the send/receive channels by name.\n */\n\nChannel.buses = new Map();","import { ToneAudioNode } from \"./ToneAudioNode\";\nimport { Param } from \"./Param\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with [[Panner3D]] makes up the Web Audio API's 3D panning system. Panner3D allows you\n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context.\n */\n\nexport class Listener extends ToneAudioNode {\n  constructor() {\n    super(...arguments);\n    this.name = \"Listener\";\n    this.positionX = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.positionX\n    });\n    this.positionY = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.positionY\n    });\n    this.positionZ = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.positionZ\n    });\n    this.forwardX = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.forwardX\n    });\n    this.forwardY = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.forwardY\n    });\n    this.forwardZ = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.forwardZ\n    });\n    this.upX = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.upX\n    });\n    this.upY = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.upY\n    });\n    this.upZ = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.upZ\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      positionX: 0,\n      positionY: 0,\n      positionZ: 0,\n      forwardX: 0,\n      forwardY: 0,\n      forwardZ: -1,\n      upX: 0,\n      upY: 1,\n      upZ: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.positionX.dispose();\n    this.positionY.dispose();\n    this.positionZ.dispose();\n    this.forwardX.dispose();\n    this.forwardY.dispose();\n    this.forwardZ.dispose();\n    this.upX.dispose();\n    this.upY.dispose();\n    this.upZ.dispose();\n    return this;\n  }\n\n} //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.listener = new Listener({\n    context\n  });\n});\nonContextClose(context => {\n  context.listener.dispose();\n});","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nexport * from \"./version\";\nimport { getContext } from \"./core/Global\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer\";\nexport { start } from \"./core/Global\";\nexport { supported } from \"./core/context/AudioContext\";\n/**\n * The current audio context time of the global [[Context]].\n * See [[Context.now]]\n * @category Core\n */\n\nexport const now = getContext().now.bind(getContext());\n/**\n * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]\n * See [[Context.immediate]]\n * @category Core\n */\n\nexport const immediate = getContext().immediate.bind(getContext());\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\n\nexport const Transport = getContext().transport;\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\n\nexport const Destination = getContext().destination;\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\n\nexport const Listener = getContext().listener;\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * See [[Draw]]\n * @category Core\n */\n\nexport const Draw = getContext().draw;\n/**\n * A reference to the global context\n * See [[Context]]\n * @category Core\n */\n\nexport const context = getContext();\n/**\n * Promise which resolves when all of the loading promises are resolved.\n * Alias for static [[ToneAudioBuffer.loaded]] method.\n * @category Core\n */\n\nexport const loaded = ToneAudioBuffer.loaded.bind(ToneAudioBuffer); // this fills in name changes from 13.x to 14.x\n\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource\";\nexport const Buffer = ToneAudioBuffer;\nexport const Buffers = ToneAudioBuffers;\nexport const BufferSource = ToneBufferSource;","import \"./styles/index.scss\";\nimport * as Tone from 'tone';\nimport regeneratorRuntime from \"regenerator-runtime\";\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n // const play = document.body.querySelector(\".play\");\n// const pause = document.getElementById(\"pause\");\n\n  const info = document.getElementById(\n    \"more-info\"\n  );\n  const modal = document.getElementById(\n    \"modal\"\n  );\n  const modalChild = document.getElementById(\n    \"modal-child\"\n  );\n  info.addEventListener(\n    \"click\",\n    openModal\n  );\n  modal.addEventListener(\n    \"click\",\n    closeModal\n  );\n\n  function openModal(e) {\n    e.preventDefault();\n    modal.style.display =\n      \"block\";\n    modalChild.style.display =\n      \"block\";\n  }\n\n  function closeModal(e) {\n    e.preventDefault();\n    modal.style.display =\n      \"none\";\n    modalChild.style.display =\n      \"none\";\n  }\n\n  const synths = [\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n    new Tone.FMSynth(),\n  ];\n\n  synths[0].oscillator.type = \"sine\";\n  synths[1].oscillator.type = \"sine\";\n  synths[2].oscillator.type = \"sine\";\n  synths[3].oscillator.type = \"sine\";\n  synths[4].oscillator.type = \"sine\";\n  synths[5].oscillator.type = \"sine\";\n  synths[6].oscillator.type = \"sine\";\n  synths[7].oscillator.type = \"sine\";\n  \n  const gain = new Tone.Gain(0.1);\n  gain.toDestination();\n  const reverb = new Tone.Reverb({\"decay\": 5});\n  reverb.toDestination();\n\n  let notes = [\"C5\",\"B4\",\"A4\",\"G4\",\"F4\",\"E4\",\"D4\",\"C4\"]; //['C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'A4', 'A#4', 'B4', 'C5']\n  synths.forEach((synth) => synth.toDestination());\n  const $rows = document.body.querySelectorAll(\".note\"); //array of note divs\n  let index = 0;\n  Tone.Transport.scheduleRepeat(repeat, \"8n\");\n\n  function repeat(time) {\n    let step = index % 24;\n\n    for (let i = 0; i < $rows.length; i++) {\n      let synth = synths[i];\n      let note = notes[i];\n      let $row = $rows[i];\n      let $input = $row.querySelector(`input:nth-child(${step + 1})`);\n\n      if ($input.checked) {\n        synth.triggerAttackRelease(note, \"8n\",time);\n      }\n    }\n\n    index++;\n  }\n\n  const play = document.getElementById(\"play\");\n  const pause = document.getElementById( \"pause\");\n\n  play.addEventListener(\"click\", async () => {\n      await Tone.start();\n      await Tone.Transport.start();\n    }\n  );\n\n  pause.addEventListener( \"click\", async () => {\n      await Tone.Transport.stop();\n    }\n  );\n\n  const wavetype = document.getElementById(\"wavetype\");\n  let waveval = wavetype.options[wavetype.selectedIndex].value\n\n  wavetype.addEventListener(\"change\", () => {\n    synths.forEach(synth => {\n      synth.oscillator.type = waveval;\n    })\n  })\n\n  const vol_up= document.getElementById(\"vol-up\");\n  const vol_down= document.getElementById(\"vol-down\");\n  const mute = document.getElementById(\"mute\");\n\n  \n\n  mute.addEventListener(\"click\", () => {\n    if (Tone.Master.mute === false) {\n      Tone.Master.mute = true;\n    } else {\n      Tone.Master.mute = false;\n    }\n  });\n\n\n\n});"],"sourceRoot":""}